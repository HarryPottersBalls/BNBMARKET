<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BNBmarket - Decentralized Prediction Markets</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: Inter, system-ui, -apple-system, sans-serif;
      background: linear-gradient(180deg, #0b0b0f 0%, #111217 100%);
      color: #e6eef8;
      line-height: 1.4;
      min-height: 100vh;
    }

    .header {
      background: rgba(6, 6, 8, 0.55);
      backdrop-filter: blur(8px);
      border-bottom: 1px solid rgba(154, 255, 0, 0.06);
      padding: 16px 20px;
      position: sticky;
      top: 0;
      z-index: 40;
    }
    
    .header-inner {
      max-width: 1200px;
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 20px;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 700;
      color: #9aff00;
      font-size: 20px;
    }

    .brand .logo {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      background: linear-gradient(135deg, #9aff00, #7acc00);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #041;
      font-weight: 900;
    }

    .nav {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .nav a {
      padding: 10px 16px;
      border-radius: 8px;
      color: #d1d5db;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      text-decoration: none;
      transition: all 0.2s;
    }

    .nav a.active, .nav a:hover {
      color: #9aff00;
      background: rgba(154, 255, 0, 0.04);
    }

    .nav a.admin {
      background: rgba(255, 107, 107, 0.1);
      color: #ff6b6b;
      border: 1px solid rgba(255, 107, 107, 0.2);
    }

    .wallet-group {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .balance {
      background: rgba(255, 255, 255, 0.03);
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.04);
      font-size: 13px;
      font-weight: 600;
      color: #cfeccf;
    }

    .wallet-btn {
      background: linear-gradient(90deg, #9aff00, #7acc00);
      color: #041;
      border: none;
      padding: 10px 16px;
      border-radius: 8px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .wallet-btn:hover {
      transform: translateY(-1px);
    }

    .wallet-btn.connected {
      background: transparent;
      border: 1px solid #9aff00;
      color: #9aff00;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      min-height: calc(100vh - 200px);
    }

    .section {
      display: none;
    }

    .section.active {
      display: block;
    }

    .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 20px;
    }

    .section-title {
      font-size: 24px;
      font-weight: 700;
      color: #f9fafb;
    }

    .controls {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }

    .search-input {
      flex: 1;
      min-width: 200px;
      background: rgba(55, 65, 81, 0.5);
      border: 1px solid rgba(75, 85, 99, 0.3);
      padding: 10px 12px;
      border-radius: 8px;
      color: #f3f4f6;
      font-size: 14px;
    }

    .btn {
      background: linear-gradient(90deg, #9aff00, #7acc00);
      color: #041;
      border: none;
      padding: 10px 16px;
      border-radius: 8px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .btn:hover {
      transform: translateY(-1px);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.05);
      color: #bcd3e6;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .btn-danger {
      background: linear-gradient(90deg, #ff6b6b, #dc2626);
      color: white;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
      gap: 16px;
    }

    .market-card {
      background: linear-gradient(180deg, rgba(55, 65, 81, 0.4), rgba(31, 41, 55, 0.6));
      border: 1.5px solid rgba(154, 255, 0, 0.25); /* #9aff00 accent border */
      border-radius: 12px;
      padding: 16px;
      transition: all 0.3s ease;
      cursor: pointer;
    }

    .market-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 32px rgba(154, 255, 0, 0.18);
      border-color: #9aff00;
      background: linear-gradient(180deg, #23293a 60%, #23293a 80%, #181e29 100%);
    }

    .market-title {
      font-weight: 700;
      color: #9aff00;
      font-size: 16px;
      margin-bottom: 8px;
      line-height: 1.3;
      letter-spacing: 0.01em;
      text-shadow: 0 1px 8px rgba(154,255,0,0.08);
    }

    .market-meta {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }

    .badge {
      background: rgba(154, 255, 0, 0.08);
      color: #9aff00;
      padding: 4px 8px;
      border-radius: 6px;
      font-weight: 600;
      font-size: 11px;
      text-transform: uppercase;
    }

    .badge.pending {
      background: rgba(245, 158, 11, 0.1);
      color: #f59e0b;
    }

    .volume {
      color: #9aff00;
      font-weight: 700;
      font-size: 14px;
    }

    .options-preview {
      display: flex;
      gap: 8px;
      margin-top: 12px;
      flex-wrap: wrap;
    }

    .option-preview {
      display: flex;
      align-items: center;
      gap: 6px;
      background: rgba(154, 255, 0, 0.08); /* subtle accent background */
      padding: 6px 10px;
      border-radius: 20px;
      border: 1px solid rgba(154, 255, 0, 0.13);
      transition: background 0.2s, border 0.2s;
    }

    .option-avatar {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      object-fit: cover;
      border: 1px solid rgba(156, 163, 175, 0.3);
    }

    .option-name {
      font-size: 12px;
      font-weight: 600;
      color: #9aff00;
      letter-spacing: 0.01em;
    }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(8px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
      padding: 20px;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: linear-gradient(180deg, #1f2937, #111827);
      border-radius: 16px;
      padding: 24px;
      width: 100%;
      max-width: 600px;
      max-height: 90vh;
      overflow-y: auto;
      border: 1px solid rgba(75, 85, 99, 0.3);
    }

    .modal-title {
      font-size: 20px;
      font-weight: 700;
      color: #10b981;
      margin-bottom: 20px;
    }

    .form-group {
      margin-bottom: 16px;
    }

    .form-label {
      display: block;
      font-size: 14px;
      font-weight: 600;
      color: #d1d5db;
      margin-bottom: 6px;
    }

    .form-input, .form-select, .form-textarea {
      width: 100%;
      background: rgba(55, 65, 81, 0.5);
      border: 1px solid rgba(75, 85, 99, 0.3);
      padding: 12px;
      border-radius: 8px;
      color: #f3f4f6;
      font-size: 14px;
    }

    .form-textarea {
      resize: vertical;
      min-height: 80px;
    }

    .form-input:focus, .form-select:focus, .form-textarea:focus {
      outline: none;
      border-color: #10b981;
      box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.1);
    }

    .options-builder {
      background: rgba(31, 41, 55, 0.3);
      border: 1px solid rgba(75, 85, 99, 0.3);
      border-radius: 8px;
      padding: 16px;
    }

    .option-item {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
      padding: 16px;
      background: rgba(31, 41, 55, 0.6);
      border-radius: 12px;
      border: 1px solid rgba(75, 85, 99, 0.2);
    }

    .option-avatar-container {
      position: relative;
      width: 50px;
      height: 50px;
    }

    .option-avatar-preview {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      object-fit: cover;
      border: 2px solid rgba(156, 163, 175, 0.3);
      background: rgba(55, 65, 81, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #9ca3af;
      font-size: 20px;
      font-weight: 700;
    }

    .image-status {
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      background: #10b981;
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 600;
      white-space: nowrap;
    }

    .option-input-group {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .option-name-input {
      background: rgba(55, 65, 81, 0.5);
      border: 1px solid rgba(75, 85, 99, 0.3);
      padding: 8px 12px;
      border-radius: 6px;
      color: #f3f4f6;
      font-size: 14px;
    }

    .file-input-wrapper {
      position: relative;
      overflow: hidden;
      display: inline-block;
    }

    .file-input-custom {
      background: rgba(75, 85, 99, 0.5);
      color: #d1d5db;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
      border: 1px solid rgba(107, 114, 128, 0.3);
    }

    .file-input-hidden {
      position: absolute;
      left: -9999px;
      opacity: 0;
    }

    .remove-option-btn {
      background: linear-gradient(90deg, #ff6b6b, #dc2626);
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      min-width: 70px;
    }

    .add-option-btn {
      background: rgba(154, 255, 0, 0.1);
      color: #9aff00;
      border: 1px solid rgba(154, 255, 0, 0.3);
      padding: 10px 16px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      width: 100%;
      margin-top: 12px;
    }

    .odds-input {
      background: rgba(55, 65, 81, 0.5);
      border: 1px solid rgba(75, 85, 99, 0.3);
      padding: 6px 10px;
      border-radius: 4px;
      color: #f3f4f6;
      font-size: 12px;
      width: 80px;
    }

    .admin-odds-section {
      margin-top: 16px;
      padding: 12px;
      background: rgba(245, 158, 11, 0.1);
      border: 1px solid rgba(245, 158, 11, 0.3);
      border-radius: 8px;
    }

    .odds-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
      padding: 8px;
      background: rgba(31, 41, 55, 0.6);
      border-radius: 6px;
    }

    .modal-actions {
      display: flex;
      gap: 12px;
      margin-top: 24px;
      justify-content: flex-end;
    }

    .admin-card {
      background: linear-gradient(180deg, rgba(75, 85, 99, 0.2), rgba(55, 65, 81, 0.3));
      border: 1px solid rgba(107, 114, 128, 0.3);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 16px;
    }

    .admin-actions {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }

    .admin-actions button {
      font-size: 12px;
      padding: 6px 12px;
    }

    .empty-state {
      text-align: center;
      padding: 40px 20px;
      color: #9ca3af;
    }

    .empty-state h3 {
      color: #f3f4f6;
      margin-bottom: 8px;
      font-size: 18px;
    }

    .loading {
      opacity: 0.6;
      pointer-events: none;
    }

    .spinner {
      border: 2px solid rgba(16, 185, 129, 0.1);
      border-radius: 50%;
      border-top: 2px solid #10b981;
      width: 14px;
      height: 14px;
      animation: spin 1s linear infinite;
      display: inline-block;
      margin-right: 6px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .status-indicator {
      position: fixed;
      top: 10px;
      left: 10px;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      z-index: 1000;
    }

    .status-indicator.online {
      background: rgba(16, 185, 129, 0.2);
      color: #10b981;
      border: 1px solid rgba(16, 185, 129, 0.3);
    }

    .status-indicator.offline {
      background: rgba(239, 68, 68, 0.2);
      color: #ef4444;
      border: 1px solid rgba(239, 68, 68, 0.3);
    }

    .rpc-warning {
      background: rgba(245, 158, 11, 0.1);
      border: 1px solid rgba(245, 158, 11, 0.3);
      color: #f59e0b;
      padding: 12px 16px;
      border-radius: 8px;
      margin-bottom: 20px;
      font-size: 14px;
    }
  </style>
</head>
<body>

  <header class="header">
    <div class="header-inner">
      <div class="brand">
        <div class="logo">B</div>
        BNBmarket
      </div>
      <nav class="nav">
  <a href="#" class="nav-link active" data-section="markets">Markets</a>
  <a href="#" class="nav-link" data-section="mybets" id="myBetsNavLink">My Bets</a>
  <a href="#" class="nav-link" data-section="claim" id="claimNavLink" style="display:none">Claim Winnings</a>
        <a href="#" class="nav-link" data-section="treasury">Treasury</a>
        <a href="#" class="nav-link" data-section="how">How It Works</a>
        <a href="#" id="adminTab" class="nav-link admin" data-section="admin" style="display:none">Admin Panel</a>
      </nav>
      <div class="wallet-group">
        <div class="balance" id="balanceDisplay" style="display:none">
          BNB: <span id="bnbBalance">0.000</span>
        </div>
        <button id="walletBtn" class="wallet-btn">Connect Wallet</button>
      </div>
    </div>
  </header>

  <main class="container">
    <div id="rpcWarning" class="rpc-warning" style="display:none">
      <strong>RPC Connection Issue:</strong> Using fallback mode. Some features may be limited until you configure a proper RPC endpoint.
    </div>

    <!-- Markets Section -->
    <section id="marketsSection" class="section active">
      <div class="section-header">
        <h2 class="section-title">Prediction Markets</h2>
        <div class="controls">
          <input id="searchInput" class="search-input" placeholder="Search markets..." />
          <button id="createMarketBtn" class="btn">+ Create Market</button>
        </div>
      </div>
      <div id="marketsGrid" class="grid"></div>
    </section>

    <!-- My Bets Section -->
    <section id="mybetsSection" class="section">
      <div class="section-header">
        <h2 class="section-title">My Betting History</h2>
      </div>
      <div id="betsContainer">
        <div class="empty-state">
          <h3>Connect Wallet</h3>
          <p>Connect your wallet to view your betting history.</p>
        </div>
      </div>
    </section>

    <!-- Claim Winnings Section -->
    <section id="claimSection" class="section">
      <div class="section-header">
        <h2 class="section-title">Claim Winnings</h2>
        <p style="color: #9ca3af; margin-top: 8px;">Claim your winnings from resolved markets</p>
      </div>
      <div id="claimContainer">
        <div class="empty-state">
          <h3>Connect Wallet</h3>
          <p>Connect your wallet to view and claim your winnings.</p>
        </div>
      </div>
    </section>

    <!-- Treasury Section -->
    <section id="treasurySection" class="section">
      <div class="section-header">
        <h2 class="section-title">Platform Treasury</h2>
      </div>
      <div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));">
        <div class="admin-card">
          <h3 style="color: #10b981; margin-bottom: 8px;">Treasury Balance</h3>
          <div style="font-size: 28px; font-weight: 700; color: #f9fafb;" id="treasuryBalance">0 BNB</div>
        </div>
        <div class="admin-card">
          <h3 style="color: #10b981; margin-bottom: 8px;">Total Markets</h3>
          <div style="font-size: 28px; font-weight: 700; color: #f9fafb;" id="marketCount">0</div>
        </div>
        <div class="admin-card">
          <h3 style="color: #10b981; margin-bottom: 8px;">Total Volume</h3>
          <div style="font-size: 28px; font-weight: 700; color: #f9fafb;" id="totalVolume">0 BNB</div>
        </div>
        <div class="admin-card">
          <h3 style="color: #10b981; margin-bottom: 8px;">Creation Fees</h3>
          <div style="font-size: 28px; font-weight: 700; color: #f9fafb;" id="creationFees">0 BNB</div>
        </div>
      </div>
    </section>

    <!-- How It Works Section -->
    <section id="howSection" class="section">
      <div class="section-header">
        <h2 class="section-title">How BNBmarket Works</h2>
      </div>
      <div class="admin-card">
        <h3 style="color: #10b981; margin-bottom: 16px;">Decentralized Prediction Markets</h3>
        <p style="color: #d1d5db; line-height: 1.6; margin-bottom: 16px;">
          BNBmarket is a decentralized prediction market platform built on Binance Smart Chain. Create markets on any topic or trade on existing ones with transparent, blockchain-based odds.
        </p>
        <ul style="color: #9ca3af; line-height: 1.8; padding-left: 20px;">
          <li><strong>Real BNB Betting:</strong> All transactions happen on Binance Smart Chain</li>
          <li><strong>Market Creation:</strong> 0.00078 BNB fee to create new markets</li>
          <li><strong>Admin Review:</strong> All markets reviewed before going live</li>
          <li><strong>Up to 8 Options:</strong> Each with custom images and odds</li>
          <li><strong>Treasury System:</strong> Secure fund management</li>
        </ul>
      </div>
    </section>

    <!-- Admin Panel Section -->
    <section id="adminSection" class="section">
      <div class="section-header">
        <h2 class="section-title">Admin Panel</h2>
        <button id="refreshPendingBtn" class="btn-secondary btn">Refresh</button>
      </div>
      
      <div style="margin-bottom: 24px;">
        <h3 style="color: #f59e0b; margin-bottom: 12px;">Pending Market Reviews</h3>
        <div id="pendingMarketsContainer">
          <div class="empty-state">
            <h3>No Pending Markets</h3>
            <p>All markets have been reviewed.</p>
          </div>
        </div>
      </div>
    </section>
  </main>

  <!-- Create Market Modal -->
  <div id="createMarketModal" class="modal">
    <div class="modal-content">
      <h3 class="modal-title">Create Prediction Market</h3>
      
      <div class="form-group">
        <label class="form-label">Market Question</label>
        <input id="marketTitle" class="form-input" placeholder="Type in your bet or your question
      </div>

      <div class="form-group">
        <label class="form-label">Category</label>
        <select id="marketCategory" class="form-select">
          <option value="other">Other</option>
          <option value="politics">Politics</option>
          <option value="crypto">Crypto</option>
          <option value="sports">Sports</option>
          <option value="tech">Technology</option>
          <option value="business">Business</option>
        </select>
      </div>

      <div class="form-group">

        <label class="form-label">Market Profile Image <span style="color:#ef4444">*</span></label>
        <div class="file-input-wrapper" style="display:flex;align-items:center;gap:16px;">
          <div id="marketImagePreviewContainer" style="width:80px;height:80px;display:flex;align-items:center;justify-content:center;background:#f3f4f6;border-radius:12px;overflow:hidden;">
            <img id="marketImagePreview" src="" alt="Preview" style="display:none;width:64px;height:64px;object-fit:cover;border-radius:50%;background:#e5e7eb;" />
            <span id="marketImagePlaceholder" style="font-size:40px;color:#9ca3af;">?</span>
          </div>
          <div>
            <label class="file-input-custom" id="marketImageLabel">
              <span id="marketImageLabelText">Choose image</span>
              <input type="file" accept="image/*" class="file-input-hidden" id="marketImageInput" onchange="handleMarketImageChange(event)">
            </label>
          </div>
        </div>
      </div>

      <div class="form-group">
        <label class="form-label">Market Options (Max 5)</label>
        <div class="options-builder">
          <div id="optionsContainer"></div>
          <button id="addOptionBtn" class="add-option-btn">+ Add Option</button>
        </div>
      </div>

      <div class="form-group">
        <label class="form-label">End Date</label>
        <input id="marketEndDate" class="form-input" type="datetime-local" />
      </div>

      <div class="modal-actions">
        <button id="cancelCreateBtn" class="btn-secondary">Cancel</button>
        <button id="submitCreateBtn" class="btn">Create Market (0.05 BNB)</button>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
  <script>
    // Wait for Web3 library to load


    // Configuration
    // API base URL auto-detect (prod, dev, tunnel, etc.)
    // Dynamically set API base URL for local, render, or production (never use api.solymarket.cc)
    const API_BASE_URL = (function() {
      const { hostname, protocol } = window.location;
      console.log('Current hostname:', hostname);
      console.log('Current protocol:', protocol);

      if (hostname === 'localhost' || hostname === '127.0.0.1') {
        return 'http://localhost:3001/api';
      }

      // For Render or any production domain, use same origin
      const url = `${protocol}//${hostname}/api`;
      console.log('API_BASE_URL set to:', url);
      return url;
    })();
  // Only this wallet is admin for UI/admin panel
  const ADMIN_WALLET = '0x742d35Cc6A0de1234567890abcdef1234567890';
  const TREASURY_WALLET = '0x742d35Cc6A0de1234567890abcdef1234567890';
    
    // All BSC RPC requests are now proxied through the backend for security
    // No API keys are exposed in the frontend
    const RPC_ENDPOINTS = [API_BASE_URL + '/bsc-proxy'];
    
    const CREATION_FEE = 0.0007803101839841827;

    // Global state
    let wallet = null;
    let walletAdapter = null;
    let web3 = null;
    let bnbBalance = 0;
    let oddsEngine = null;
    let oddsVisualizer = null;
    let markets = [];
    let currentSection = 'markets';
    let backendConnected = false;
  let isAdmin = false;
    let selectedOption = null;
    let currentMarket = null;
    let options = []; // For market creation

    // Market Detail Modal Functions
    function openMarketDetailModal(market) {
      currentMarket = market;
      selectedOption = null;
      
      document.getElementById('marketDetailTitle').textContent = market.title;
      
      // Populate market details
      const detailContent = document.getElementById('marketDetailContent');
      detailContent.innerHTML = `
        <div class="admin-card" style="margin: 0;">
          <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 16px;">
            <div>
              <div class="badge" style="margin-bottom: 8px;">${escapeHtml(market.category || 'Other')}</div>
              <div style="color: #9ca3af; font-size: 14px;">
                Created: ${new Date(market.created_at).toLocaleDateString()} | 
                Volume: ${parseFloat(market.total_volume || 0).toFixed(3)} BNB
              </div>
              ${market.end_date ? `<div style="color: #9ca3af; font-size: 14px;">Ends: ${new Date(market.end_date).toLocaleDateString()}</div>` : ''}
            </div>
            <div class="badge ${market.status === 'under_review' ? 'pending' : ''}">${market.status === 'under_review' ? 'Under Review' : 'Active'}</div>
          </div>
          ${market.description ? `<p style="color: #d1d5db; margin-bottom: 16px;">${escapeHtml(market.description)}</p>` : ''}
        </div>
      `;
      
      // Populate betting options
      renderBettingOptions(market);
      
      // Update betting interface state
      updateBettingInterface();
      
      document.getElementById('marketDetailModal').classList.add('active');
    }

    function closeMarketDetailModal() {
      document.getElementById('marketDetailModal').classList.remove('active');
      selectedOption = null;
      currentMarket = null;
    }

    // --- Odds Helper: Single Source of Truth ---
    function getOptionOdds(market, optionIndex) {
      if (!market || !oddsEngine) return null;

      // Try to get dynamic odds from the new engine first
      const marketOdds = oddsEngine.getMarketOdds(market.id);
      if (marketOdds && marketOdds[optionIndex]) {
        return marketOdds[optionIndex].odds;
      }

      // Fallback to admin-set odds if engine not initialized
      let metadata = market.metadata;
      if (typeof metadata === 'string') {
        try { metadata = JSON.parse(metadata); } catch (e) { metadata = {}; }
      }
      if (!metadata || typeof metadata !== 'object') metadata = {};
      if (Array.isArray(metadata.admin_odds) && optionIndex < metadata.admin_odds.length && metadata.admin_odds[optionIndex] !== null && metadata.admin_odds[optionIndex] !== undefined && metadata.admin_odds[optionIndex] !== '' && metadata.admin_odds[optionIndex] !== 'null') {
        const odds = parseFloat(metadata.admin_odds[optionIndex]);
        if (!isNaN(odds) && odds >= 1.1) return odds;
      }
      return null;
    }

    function renderBettingOptions(market) {
      const container = document.getElementById('bettingOptions');
      if (!market.options || market.options.length === 0) {
        container.innerHTML = '<div style="color: #9ca3af;">No betting options available</div>';
        return;
      }
      container.innerHTML = market.options.map((option, index) => {
        const odds = getOptionOdds(market, index);
        const isSelected = selectedOption === index;
        let oddsDisplay = '';
        let probabilityBar = '';

        if (odds !== null) {
          const probability = (1 / odds) * 100;
          const probabilityColor = probability >= 60 ? '#10b981' : probability >= 40 ? '#f59e0b' : probability >= 20 ? '#3b82f6' : '#ef4444';

          oddsDisplay = `
            <div style='color:#f59e0b;font-size:0.98em;font-weight:600;margin-top:2px;'>
              x${odds.toFixed(2)} (${probability.toFixed(1)}%)
            </div>`;

          probabilityBar = `
            <div style="margin-top: 8px;">
              <div style="background: #2a2a2a; height: 6px; border-radius: 3px; overflow: hidden;">
                <div style="
                  width: ${probability}%;
                  height: 100%;
                  background: ${probabilityColor};
                  transition: all 0.3s ease;
                "></div>
              </div>
            </div>`;
        } else {
          oddsDisplay = `<div style='color:#ef4444;font-size:0.98em;font-weight:600;margin-top:2px;'>Odds not set</div>`;
        }
        return `
          <div class="betting-option ${isSelected ? 'selected' : ''}" 
               onclick="selectBettingOption(${index})"
               style="
                 padding: 16px; 
                 border-radius: 12px; 
                 border: 2px solid ${isSelected ? '#10b981' : 'rgba(75, 85, 99, 0.3)'}; 
                 background: ${isSelected ? 'rgba(16, 185, 129, 0.1)' : 'rgba(31, 41, 55, 0.6)'};
                 cursor: pointer;
                 transition: all 0.2s;
                 text-align: center;
               ">
            <div style="display: flex; align-items: center; justify-content: center; gap: 12px; margin-bottom: 8px;">
              <img src="${option.image || 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMjAiIGN5PSIyMCIgcj0iMTkiIGZpbGw9IiM0Yjc4OTAiLz4KPHRleHQgeD0iMjAiIHk9IjI2IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSJ3aGl0ZSIgZm9udC1zaXplPSIxNiIgZm9udC1mYW1pbHk9IkFyaWFsIj4/PC90ZXh0Pgo8L3N2Zz4='}" 
                   alt="${escapeHtml(option.name)}"
                   style="width: 40px; height: 40px; border-radius: 50%; object-fit: cover;">
              <div>
                <div style="color: #f9fafb; font-weight: 700; font-size: 16px;">${escapeHtml(option.name)}</div>
                ${oddsDisplay}
              </div>
            </div>
            ${probabilityBar}
          </div>
        `;
      }).join('');
    }

    function selectBettingOption(index) {
      selectedOption = index;
      renderBettingOptions(currentMarket);
      updateBettingInterface();
    }

    function updateBettingInterface() {
      const bettingWarning = document.getElementById('bettingWarning');
      const placeBetBtn = document.getElementById('placeBetBtn');
      const betAmountInput = document.getElementById('betAmount');
      if (!wallet) {
        bettingWarning.style.display = 'block';
        bettingWarning.textContent = 'Connect your wallet to place bets';
        placeBetBtn.disabled = true;
        betAmountInput.disabled = true;
        return;
      }
      if (!currentMarket || currentMarket.status !== 'active') {
        bettingWarning.style.display = 'block';
        bettingWarning.textContent = 'This market is not available for betting';
        placeBetBtn.disabled = true;
        betAmountInput.disabled = true;
        return;
      }
      // Check if odds are set for selected option
      if (selectedOption !== null) {
        const odds = getOptionOdds(currentMarket, selectedOption);
        if (odds === null) {
          bettingWarning.style.display = 'block';
          bettingWarning.textContent = 'Odds not set for this option. Admin must set odds first.';
          placeBetBtn.disabled = true;
          betAmountInput.disabled = true;
          return;
        }
      }
      bettingWarning.style.display = 'none';
      placeBetBtn.disabled = selectedOption === null;
      betAmountInput.disabled = false;
      calculatePotentialReturn();
    }

    function calculatePotentialReturn() {
      const betAmount = parseFloat(document.getElementById('betAmount').value || 0);
      const returnDisplay = document.getElementById('potentialReturn');

      if (!betAmount || selectedOption === null || !currentMarket) {
        returnDisplay.textContent = '0.00 BNB';
        // Clear price impact display
        const impactDisplay = document.getElementById('priceImpactDisplay');
        if (impactDisplay) impactDisplay.innerHTML = '';
        return;
      }

      // Get dynamic payout calculation from odds engine
      if (oddsEngine && oddsEngine.markets.has(currentMarket.id)) {
        const payoutInfo = oddsEngine.calculatePayout(currentMarket.id, selectedOption, betAmount);
        if (payoutInfo) {
          const priceImpactColor = Math.abs(payoutInfo.priceImpact) > 5 ? '#ef4444' : payoutInfo.priceImpact < -2 ? '#f59e0b' : '#10b981';

          // Enhanced return display with live updates
          returnDisplay.innerHTML = `
            <div style="line-height: 1.4;">
              <div><strong>${payoutInfo.payout.toFixed(3)} BNB</strong></div>
              <div style="font-size: 12px; color: #9ca3af;">
                Profit: <span style="color: ${payoutInfo.profit > 0 ? '#10b981' : '#ef4444'};">
                  ${payoutInfo.profit > 0 ? '+' : ''}${payoutInfo.profit.toFixed(3)} BNB
                </span>
              </div>
              <div style="font-size: 11px; color: #6b7280;">
                Avg execution odds: ${payoutInfo.averageOdds.toFixed(3)}
              </div>
            </div>
          `;

          // Show real-time price impact
          showPriceImpactPreview(payoutInfo, priceImpactColor);
          return;
        }
      }

      // Fallback to simple calculation
      const odds = getOptionOdds(currentMarket, selectedOption);
      if (odds === null) {
        returnDisplay.textContent = 'Odds not set';
        return;
      }
      const potentialReturn = betAmount * odds;
      const profit = potentialReturn - betAmount;

      returnDisplay.innerHTML = `
        <div style="line-height: 1.4;">
          <div><strong>${potentialReturn.toFixed(3)} BNB</strong></div>
          <div style="font-size: 12px; color: #9ca3af;">
            Profit: <span style="color: ${profit > 0 ? '#10b981' : '#ef4444'};">
              ${profit > 0 ? '+' : ''}${profit.toFixed(3)} BNB
            </span>
          </div>
          <div style="font-size: 11px; color: #6b7280;">
            Fixed odds: ${odds.toFixed(3)}
          </div>
        </div>
      `;
    }

    // New function for price impact preview
    function showPriceImpactPreview(payoutInfo, impactColor) {
      let impactDisplay = document.getElementById('priceImpactDisplay');

      // Create price impact display if it doesn't exist
      if (!impactDisplay) {
        impactDisplay = document.createElement('div');
        impactDisplay.id = 'priceImpactDisplay';
        impactDisplay.style.cssText = `
          margin-top: 8px;
          padding: 8px;
          border-radius: 6px;
          font-size: 12px;
          line-height: 1.3;
          transition: all 0.3s ease;
        `;

        const returnDisplay = document.getElementById('potentialReturn');
        returnDisplay.parentNode.insertBefore(impactDisplay, returnDisplay.nextSibling);
      }

      // Determine impact severity
      const severity = Math.abs(payoutInfo.priceImpact);
      let impactClass = 'neutral';
      let impactText = 'Minimal impact';

      if (severity > 10) {
        impactClass = 'high';
        impactText = 'High price impact';
      } else if (severity > 5) {
        impactClass = 'medium';
        impactText = 'Moderate price impact';
      }

      // Style based on impact level
      const backgrounds = {
        neutral: 'rgba(59, 130, 246, 0.1)',
        medium: 'rgba(245, 158, 11, 0.1)',
        high: 'rgba(239, 68, 68, 0.1)'
      };

      const borders = {
        neutral: 'rgba(59, 130, 246, 0.3)',
        medium: 'rgba(245, 158, 11, 0.3)',
        high: 'rgba(239, 68, 68, 0.3)'
      };

      impactDisplay.style.background = backgrounds[impactClass];
      impactDisplay.style.border = `1px solid ${borders[impactClass]}`;

      // Real-time impact display with animation
      impactDisplay.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <span style="color: ${impactColor};">📊 ${impactText}</span>
          <span style="font-weight: 600; color: ${impactColor};">
            ${payoutInfo.priceImpact > 0 ? '+' : ''}${payoutInfo.priceImpact.toFixed(2)}%
          </span>
        </div>
        <div style="margin-top: 4px; font-size: 11px; color: #9ca3af;">
          Odds: ${payoutInfo.currentOdds.toFixed(3)} → ${payoutInfo.finalOdds.toFixed(3)}
          ${severity > 3 ? ` | Slippage: ${payoutInfo.slippage.toFixed(2)}%` : ''}
        </div>
      `;

      // Add flash animation for significant changes
      if (severity > 5) {
        impactDisplay.classList.add('odds-flash');
        setTimeout(() => impactDisplay.classList.remove('odds-flash'), 600);
      }
    }

    async function placeBet() {
      if (!wallet || selectedOption === null || !currentMarket) {
        toast('Please connect wallet and select an option');
        return;
      }
      
      const betAmount = parseFloat(document.getElementById('betAmount').value || 0);
      if (betAmount <= 0) {
        toast('Please enter a valid bet amount');
        return;
      }
      
      if (!rpcFallbackMode && betAmount > bnbBalance) {
        toast('Insufficient balance');
        return;
      }
      
      const placeBetBtn = document.getElementById('placeBetBtn');
      
      try {
        setLoading(placeBetBtn, true);
        toast('Placing bet on BSC...');
        
        // Create Web3 transaction to treasury
        const amountInWei = web3.utils.toWei(betAmount.toString(), 'ether');
        
        const transaction = {
          from: wallet,
          to: TREASURY_WALLET,
          value: amountInWei,
          gas: 21000,
        };
        
        // Send transaction through MetaMask
        const transactionHash = await window.ethereum.request({
          method: 'eth_sendTransaction',
          params: [transaction],
        });
        
        console.log('Bet transaction sent:', transactionHash);
        
        // Get execution odds from odds engine before recording
        let executionOdds = getOptionOdds(currentMarket, selectedOption);
        let betResult = null;

        // Update odds engine with the bet
        if (oddsEngine && oddsEngine.markets.has(currentMarket.id)) {
          betResult = oddsEngine.placeBet(currentMarket.id, selectedOption, betAmount);
          executionOdds = betResult.executedOdds;
          console.log('Bet executed in odds engine:', betResult);
        }

        // Record bet in database
        await apiRequest('/bets', {
          method: 'POST',
          body: JSON.stringify({
            marketId: currentMarket.id,
            bettorAddress: wallet.toString(),
            optionId: selectedOption,
            amount: betAmount,
            transactionSignature: transactionHash,
            executionOdds: executionOdds,
            priceImpact: betResult ? betResult.priceImpact : 0
          })
        });
        
        // Update balance (skip if Web3 is having issues)
        if (web3 && !rpcFallbackMode) {
          try {
            const balance = await web3.eth.getBalance(wallet);
            bnbBalance = parseFloat(web3.utils.fromWei(balance, 'ether'));
            updateWalletUI();
          } catch (error) {
            console.warn('Could not update balance:', error.message);
          }
        }
        
        // Reset form
        document.getElementById('betAmount').value = '';
        selectedOption = null;
        renderBettingOptions(currentMarket);
        
        toast('Bet placed successfully!');
        
        // Reload market data
        await loadMarkets();
        
      } catch (error) {
        console.error('Bet placement failed:', error);
        if (error.message.includes('User rejected')) {
          toast('Transaction cancelled by user');
        } else {
          toast('Failed to place bet: ' + error.message);
        }
      } finally {
        setLoading(placeBetBtn, false);
      }
    }

    async function claimWinnings(betId, expectedPayout) {
      if (!wallet) {
        toast('Please connect your wallet');
        return;
      }
      
      try {
        toast('Processing claim transaction...');
        
        // Create Web3 transaction from treasury to user
        const amountInWei = web3.utils.toWei(expectedPayout.toString(), 'ether');
        
        const transaction = {
          from: TREASURY_WALLET, // This would need admin signature in real implementation
          to: wallet,
          value: amountInWei,
          gas: 21000,
        };
        
        // For now, simulate the transaction with a dummy signature
        // In production, this would be handled by a backend service with admin keys
        const dummySignature = `0x${Math.random().toString(16).substr(2, 64)}${Math.random().toString(16).substr(2, 64)}`;
        
        toast('Submitting claim to blockchain...');
        
        // Record claim in backend
        const response = await apiRequest(`/claim/${betId}`, {
          method: 'POST',
          body: JSON.stringify({
            address: wallet.toString(),
            transactionSignature: dummySignature
          })
        });
        
        if (response.bet) {
          toast(`Successfully claimed ${expectedPayout.toFixed(4)} BNB!`);
          
          // Refresh the claims page
          await loadClaimableWinnings();
          
          // Update balance
          await updateBalance();
          
        } else {
          throw new Error('Failed to record claim');
        }
        
      } catch (error) {
        console.error('Claim error:', error);
        if (error.message.includes('rejected')) {
          toast('Transaction cancelled by user');
        } else {
          toast('Failed to claim winnings: ' + error.message);
        }
      }
    }

    let rpcFallbackMode = false;

    // Utility functions
    function toast(msg, type = 'info') {
      // Enhanced toast: show a non-blocking message at the top of the page
      let toastDiv = document.getElementById('toastMsg');
      if (!toastDiv) {
        toastDiv = document.createElement('div');
        toastDiv.id = 'toastMsg';
        toastDiv.style.position = 'fixed';
        toastDiv.style.top = '20px';
        toastDiv.style.left = '50%';
        toastDiv.style.transform = 'translateX(-50%)';
        toastDiv.style.background = type === 'error' ? '#ef4444' : '#10b981';
        toastDiv.style.color = '#fff';
        toastDiv.style.padding = '12px 24px';
        toastDiv.style.borderRadius = '8px';
        toastDiv.style.fontWeight = '700';
        toastDiv.style.fontSize = '1rem';
        toastDiv.style.zIndex = '9999';
        toastDiv.style.boxShadow = '0 2px 12px rgba(0,0,0,0.13)';
        document.body.appendChild(toastDiv);
      }
      toastDiv.textContent = msg;
      toastDiv.style.display = 'block';
      toastDiv.style.background = type === 'error' ? '#ef4444' : '#10b981';
      setTimeout(() => { toastDiv.style.display = 'none'; }, 2200);
    }

    function setLoading(element, loading) {
      if (loading) {
        element.classList.add('loading');
        element.disabled = true;
        // Store original text
        if (!element.dataset.originalText) {
          element.dataset.originalText = element.textContent;
        }
        element.innerHTML = '<span class="spinner"></span>' + element.dataset.originalText;
      } else {
        element.classList.remove('loading');
        element.disabled = false;
        // Restore original text
        if (element.dataset.originalText) {
          element.textContent = element.dataset.originalText;
        }
      }
    }

    function updateStatus(connected) {
      backendConnected = connected;
      // No UI indicator needed
    }

    function showRpcWarning(show = true) {
      const warning = document.getElementById('rpcWarning');
      warning.style.display = show ? 'block' : 'none';
      rpcFallbackMode = show;
    }

    // API helper
    async function apiRequest(endpoint, options = {}) {
      const maxRetries = 2;
      let lastError = null;
      for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
          // Always use full API_BASE_URL, never relative
          const fullUrl = API_BASE_URL + endpoint;
          const response = await fetch(fullUrl, {
            headers: { 'Content-Type': 'application/json', ...options.headers },
            ...options
          });
          if (!response.ok) {
            throw new Error(`API error: ${response.status} - ${response.statusText}`);
          }
          updateStatus(true);
          return await response.json();
        } catch (error) {
          lastError = error;
          if (attempt < maxRetries) {
            await new Promise(r => setTimeout(r, 500 * (attempt + 1)));
            continue;
          }
          updateStatus(false);
          throw error;
        }
      }
      throw lastError;
    }

    // Initialize Web3 connection with fallback
    async function initializeWeb3() {
      try {
        if (!window.ethereum) {
          console.log('MetaMask not detected');
          return false;
        }
        
        web3 = new Web3(window.ethereum);
        
        // Check if wallet was previously connected
        const accounts = await window.ethereum.request({ method: 'eth_accounts' });
        if (accounts.length > 0) {
          wallet = accounts[0];
          walletAdapter = window.ethereum;
          // Check if this wallet is admin
          isAdmin = wallet.toString() === ADMIN_WALLET;
          updateWalletUI();
        }
        
        console.log('Successfully initialized Web3 connection');
        return true;
      } catch (error) {
        console.error('Failed to initialize Web3:', error);
        toast('Failed to connect to BSC network: ' + error.message);
        return false;
      }
    }

    // Wallet functions
    async function connectWallet() {
      try {
        if (!window.ethereum) {
          toast('MetaMask wallet not detected. Please install MetaMask extension.', 'error');
          window.open('https://metamask.io/', '_blank');
          return;
        }

        // Request account access
        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
        
        if (accounts.length === 0) {
          toast('No accounts found');
          return;
        }

        wallet = accounts[0];
        walletAdapter = window.ethereum;
        
        // Switch to BSC network if not already
        try {
          await window.ethereum.request({
            method: 'wallet_switchEthereumChain',
            params: [{ chainId: '0x38' }], // BSC Mainnet
          });
        } catch (switchError) {
          // If the chain has not been added to the user's wallet
          if (switchError.code === 4902) {
            try {
              await window.ethereum.request({
                method: 'wallet_addEthereumChain',
                params: [{
                  chainId: '0x38',
                  chainName: 'Binance Smart Chain',
                  nativeCurrency: {
                    name: 'BNB',
                    symbol: 'BNB',
                    decimals: 18,
                  },
                  rpcUrls: ['https://bsc-dataseed1.binance.org/'],
                  blockExplorerUrls: ['https://bscscan.com/'],
                }],
              });
            } catch (addError) {
              console.error('Failed to add BSC network:', addError);
            }
          }
        }
        
        // Get balance (skip if Web3 is having issues)
        if (web3 && !rpcFallbackMode) {
          try {
            const balance = await web3.eth.getBalance(wallet);
            bnbBalance = parseFloat(web3.utils.fromWei(balance, 'ether'));
          } catch (error) {
            bnbBalance = 0;
          }
        }
        // Only this wallet is admin
        isAdmin = wallet.toString() === ADMIN_WALLET;
        updateWalletUI();
        // No popup, just update UI
        if (currentSection === 'mybets') {
          loadMyBets();
        }
      } catch (error) {
        console.error('Wallet connection failed:', error);
        if (error.code === 4001 || error.message.includes('User rejected')) {
          toast('Wallet connection rejected by user');
        } else {
          toast('Failed to connect wallet. Please try again.');
        }
      }
    }

    async function disconnectWallet() {
      wallet = null;
      walletAdapter = null;
      bnbBalance = 0;
      isAdmin = false;
      updateWalletUI();
      toast('Wallet disconnected');
    }

    function updateWalletUI() {
      const btn = document.getElementById('walletBtn');
      const balanceDiv = document.getElementById('balanceDisplay');
      const adminTab = document.getElementById('adminTab');
      const claimTab = document.getElementById('claimNavLink');
      if (wallet) {
        btn.textContent = wallet.toString().slice(0, 4) + '...' + wallet.toString().slice(-4);
        btn.classList.add('connected');
        if (bnbBalance > 0) {
          document.getElementById('bnbBalance').textContent = bnbBalance.toFixed(3);
          balanceDiv.style.display = '';
        } else {
          balanceDiv.style.display = 'none';
        }
        // Show claim tab when wallet is connected
        claimTab.style.display = '';
        // Show admin tab only for admin wallet
        if (isAdmin) {
          adminTab.style.display = '';
        } else {
          adminTab.style.display = 'none';
        }
      } else {
        btn.textContent = 'Connect Wallet';
        btn.classList.remove('connected');
        balanceDiv.style.display = 'none';
        // Hide tabs when wallet not connected
        if (claimTab) claimTab.style.display = 'none';
        if (adminTab) adminTab.style.display = 'none';
      }
    }

    // Navigation
    function showSection(sectionName) {
      // Hide all sections
      document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
      document.querySelectorAll('.nav-link').forEach(l => l.classList.remove('active'));
      
      // Show target section
      document.getElementById(sectionName + 'Section').classList.add('active');
      document.querySelector(`[data-section="${sectionName}"]`).classList.add('active');
      
      currentSection = sectionName;
      
      // Load section-specific data
      if (sectionName === 'markets') {
        loadMarkets();
      } else if (sectionName === 'mybets') {
        loadMyBets();
      } else if (sectionName === 'claim') {
        loadClaimableWinnings();
      } else if (sectionName === 'treasury') {
        loadTreasuryStats();
      } else if (sectionName === 'admin' && isAdmin) {
        loadPendingMarkets();
      }
    }

    // Market functions
    async function loadMarkets() {
      try {
        const response = await apiRequest('/markets?status=active');
        markets = response.markets || [];

        // Initialize markets in the odds engine
        if (oddsEngine) {
          markets.forEach(market => {
            if (market.options && !oddsEngine.markets.has(market.id)) {
              // Initialize with equal odds or use admin odds as starting point
              let initialLiquidity = 100; // Default starting liquidity

              // If admin odds exist, use them to set initial liquidity distribution
              if (market.metadata && market.metadata.admin_odds) {
                const adminOdds = market.metadata.admin_odds;
                if (Array.isArray(adminOdds) && adminOdds.length === market.options.length) {
                  // Convert admin odds to implied probabilities for initial liquidity
                  const totalProbability = adminOdds.reduce((sum, odds) => {
                    const prob = odds > 0 ? 1 / parseFloat(odds) : 1 / market.options.length;
                    return sum + prob;
                  }, 0);

                  // Normalize and set initial liquidity
                  initialLiquidity = adminOdds.map(odds => {
                    const prob = odds > 0 ? 1 / parseFloat(odds) : 1 / market.options.length;
                    return (prob / totalProbability) * 100;
                  });
                }
              }

              oddsEngine.initializeMarket(market.id, market.options, initialLiquidity);
              console.log(`Initialized odds engine for market ${market.id}`);
            }
          });
        }

        renderMarkets(markets);

      } catch (error) {
        console.error('Failed to load markets:', error);
        document.getElementById('marketsGrid').innerHTML = `
          <div class="empty-state">
            <h3>Connection Error</h3>
            <p>Failed to load markets: ${error.message}</p>
            <button class="btn" onclick="loadMarkets()">Retry</button>
          </div>
        `;
      }
    }

    function renderMarkets(marketList) {
      const grid = document.getElementById('marketsGrid');
      
      if (!marketList || marketList.length === 0) {
        grid.innerHTML = `
          <div class="empty-state">
            <h3>No Markets Available</h3>
            <p>Be the first to create a prediction market.</p>
            <button class="btn" onclick="openCreateMarketModal()">Create Market</button>
          </div>
        `;
        return;
      }
      
      grid.innerHTML = marketList.map(market => {
        const optionsHtml = (market.options || []).slice(0, 4).map(option => `
          <div class="option-preview">
            <img src="${option.image || 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iMTEiIGZpbGw9IiM0Yjc4OTAiLz4KPHRleHQgeD0iMTIiIHk9IjE2IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSJ3aGl0ZSIgZm9udC1zaXplPSIxMiIgZm9udC1mYW1pbHk9IkFyaWFsIj4/PC90ZXh0Pgo8L3N2Zz4='}" 
                 alt="${escapeHtml(option.name || 'Option')}" 
                 class="option-avatar" />
            <span class="option-name">${escapeHtml(option.name || 'Option')}</span>
          </div>
        `).join('');
        // Market image display (prominent circle next to title)
        const marketImageHtml = market.metadata && market.metadata.marketImage
          ? `<img src="${market.metadata.marketImage}" alt="${escapeHtml(market.title)}" style="width:64px;height:64px;object-fit:cover;border-radius:50%;background:#e5e7eb;margin-right:12px;vertical-align:middle;">`
          : `<span style="display:inline-block;width:64px;height:64px;border-radius:50%;background:#f3f4f6;color:#9ca3af;font-size:32px;line-height:64px;text-align:center;margin-right:12px;vertical-align:middle;">?</span>`;
        // Admin delete button logic
        let deleteBtn = '';
        if (isAdmin) {
          deleteBtn = `<button class="btn-danger" style="float:right; margin-top: -8px; margin-bottom: 8px;" onclick="event.stopPropagation(); deleteMarket(${market.id})">Delete</button>`;
        }
        return `
          <div class="market-card" data-market-id="${market.id}" onclick="showMarketDetail(${market.id})" style="display:flex;flex-direction:column;">
            <div style="display:flex;align-items:center;gap:8px;">
              ${marketImageHtml}
              <div style="flex:1;">
                <div class="market-title" style="font-size:1.1em;font-weight:600;">${escapeHtml(market.title || 'Untitled Market')}</div>
                <div class="market-meta">
                  <div class="badge ${market.status === 'under_review' ? 'pending' : ''}">${escapeHtml(market.category || 'Other')}</div>
                  <div class="volume">${parseFloat(market.total_volume || 0).toFixed(3)} BNB</div>
                  ${market.status === 'under_review' ? '<div class="badge pending">Under Review</div>' : ''}
                </div>
              </div>
              ${deleteBtn}
            </div>
            <div class="options-preview" style="margin-top:8px;">${optionsHtml}</div>
            <div class="odds-display" data-market-id="${market.id}" style="margin-top:8px;">
              <!-- Reactive odds will be injected here -->
            </div>
            <div style="margin-top: 12px; font-size: 12px; color: #9ca3af;">
              Created: ${new Date(market.created_at).toLocaleDateString()}
            </div>
          </div>
        `;
      }).join('');
    }

    function escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
function showMarketDetail(marketId) {
  // Instead of opening a modal, redirect to the market detail page
  window.location.href = `market.html?id=${marketId}`;
}

    // Market creation functions
    function openCreateMarketModal() {
      if (!wallet) {
        toast('Connect wallet to create markets');
        return;
      }
      // Admin wallet can create for free, skip balance check
      if (!isAdmin) {
        if (!rpcFallbackMode && bnbBalance < CREATION_FEE) {
          toast(`Insufficient balance. Need ${CREATION_FEE} BNB to create market`);
          return;
        }
      }
      resetCreateForm();
      document.getElementById('createMarketModal').classList.add('active');
    }

    function closeCreateMarketModal() {
      document.getElementById('createMarketModal').classList.remove('active');
    }

    function resetCreateForm() {
      document.getElementById('marketTitle').value = '';
      document.getElementById('marketCategory').value = 'other';
      document.getElementById('marketEndDate').value = '';
      // Reset market image preview and input
      const preview = document.getElementById('marketImagePreview');
      const placeholder = document.getElementById('marketImagePlaceholder');
      const labelText = document.getElementById('marketImageLabelText');
      const input = document.getElementById('marketImageInput');
      if (preview) preview.src = '';
      if (preview) preview.style.display = 'none';
      if (placeholder) placeholder.style.display = 'block';
      if (labelText) labelText.textContent = 'Choose image';
      if (input) input.value = '';
      // Reset options
      options = [
        { name: 'Yes', image: null, file: null },
        { name: 'No', image: null, file: null }
      ];
      renderOptionsBuilder();
      // Set minimum date
      const minDate = new Date();
      minDate.setHours(minDate.getHours() + 1);
      document.getElementById('marketEndDate').min = minDate.toISOString().slice(0, 16);
    }

    function renderOptionsBuilder() {
      const container = document.getElementById('optionsContainer');
      container.innerHTML = '';
      
      options.forEach((option, index) => {
        const optionDiv = document.createElement('div');
        optionDiv.className = 'option-item';
        // Determine display content for avatar
        let avatarContent = '';
        let showImageStatus = false;
        if (option.image) {
          avatarContent = `<img src="${option.image}" alt="Option ${index + 1}" class="option-avatar-preview">`;
          showImageStatus = true;
        } else {
          const letter = option.name ? option.name.charAt(0).toUpperCase() : '?';
          avatarContent = `<div class="option-avatar-preview">${letter}</div>`;
        }
        optionDiv.innerHTML = `
          <div class="option-avatar-container">
            ${avatarContent}
            ${showImageStatus ? '<div class="image-status">Image Ready</div>' : ''}
          </div>
          <div class="option-input-group" style="display:flex;gap:8px;align-items:center;">
            <input type="text" 
                   class="option-name-input" 
                   placeholder="Enter option name" 
                   value="${option.name || ''}" 
                   onchange="updateOptionName(${index}, this.value)">
            <div class="file-input-wrapper">
              <label class="file-input-custom">
                ${option.file ? option.file.name : 'Choose image'}
                <input type="file" 
                       accept="image/*" 
                       class="file-input-hidden"
                       onchange="handleOptionImage(${index}, this)">
              </label>
            </div>
          </div>
          <button onclick="removeOption(${index})" class="remove-option-btn">Remove</button>
        `;
        container.appendChild(optionDiv);
      });

    }

    function addOption() {
      if (options.length >= 8) {
        toast('Maximum 8 options allowed');
        return;
      }
      
  options.push({ name: '', image: null, file: null });
      renderOptionsBuilder();
    }

    function removeOption(index) {
      if (options.length <= 2) {
        toast('Minimum 2 options required');
        return;
      }
      
      options.splice(index, 1);
      renderOptionsBuilder();
    }

    function updateOptionName(index, name) {
      options[index].name = name;
    }

    async function handleOptionImage(index, input) {
      const file = input.files[0];
      if (!file) return;
      
      options[index].file = file;
      
      // Show preview
      const reader = new FileReader();
      reader.onload = (e) => {
        options[index].image = e.target.result;
        renderOptionsBuilder();
      };
      reader.readAsDataURL(file);
    }

    async function createMarket() {
      const submitBtn = document.getElementById('submitCreateBtn');
      const title = document.getElementById('marketTitle').value.trim();
      const category = document.getElementById('marketCategory').value;
      const endDate = document.getElementById('marketEndDate').value;
      const marketImageInput = document.getElementById('marketImageInput');
      const marketImageFile = marketImageInput.files[0];
      // Validation
      if (!title || title.length < 10) {
        toast('Market question must be at least 10 characters');
        return;
      }
      if (!endDate) {
        toast('Please set an end date');
        return;
      }
      if (!marketImageFile) {
        toast('Please upload a market profile image');
        return;
      }
      // Market image is optional, but recommended
      if (!marketImageFile) {
        toast('No market profile image selected (recommended)', 'info');
      }
      // Validate options
      const validOptions = options.filter(opt => opt.name && opt.name.trim());
      if (validOptions.length < 2) {
        toast('At least 2 options with names are required');
        return;
      }
      try {
        setLoading(submitBtn, true);
        toast('Creating market on MAINNET...');
        // Upload market profile image
        let marketImageUrl = null;
        if (marketImageFile) {
          const formData = new FormData();
          formData.append('file', marketImageFile);
          const uploadResponse = await fetch(API_BASE_URL + '/upload', {
            method: 'POST',
            body: formData
          });
          if (uploadResponse.ok) {
            const uploadData = await uploadResponse.json();
            marketImageUrl = uploadData.url;
          } else {
            toast('Failed to upload market image', 'error');
            setLoading(submitBtn, false);
            return;
          }
        }
        // Upload option images (if any)
        const processedOptions = [];
        for (let index = 0; index < validOptions.length; index++) {
          const option = validOptions[index];
          let imageUrl = null;
          if (option.file) {
            try {
              const formData = new FormData();
              formData.append('file', option.file);
              const uploadResponse = await fetch(API_BASE_URL + '/upload', {
                method: 'POST',
                body: formData
              });
              if (uploadResponse.ok) {
                const uploadData = await uploadResponse.json();
                imageUrl = uploadData.url;
              } else {
                console.warn('Image upload failed:', uploadResponse.status);
                toast('Warning: Image upload failed, continuing without image');
              }
            } catch (error) {
              console.warn('Image upload error:', error);
              toast('Warning: Image upload failed, continuing without image');
            }
          }
          processedOptions.push({
            name: option.name.trim(),
            image: imageUrl
          });
        }
        let signature = null;
        // Admin wallet creates for free (no transaction)
        if (isAdmin) {
          signature = 'ADMIN_FREE_MARKET';
        } else {
          // Create Web3 transaction
          const amountInWei = web3.utils.toWei(CREATION_FEE.toString(), 'ether');
          
          const transaction = {
            from: wallet,
            to: TREASURY_WALLET,
            value: amountInWei,
            gas: 21000,
          };
          
          // Send transaction through MetaMask
          signature = await window.ethereum.request({
            method: 'eth_sendTransaction',
            params: [transaction],
          });
          
          console.log('Market creation transaction sent:', signature);
        }
        // Save to database
        const marketData = await apiRequest('/markets', {
          method: 'POST',
          body: JSON.stringify({
            title: title,
            description: '',
            category: category,
            creator_address: wallet.toString(),
            endDate: endDate,
            initialLiquidity: 0,
            options: processedOptions,
            creationSignature: signature,
            marketImage: marketImageUrl
          })
        });
    // ...existing code...
        // Update balance (skip if Web3 is having issues)
        if (web3 && !rpcFallbackMode && !isAdmin) {
          try {
            const balance = await web3.eth.getBalance(wallet);
            bnbBalance = parseFloat(web3.utils.fromWei(balance, 'ether'));
            updateWalletUI();
          } catch (error) {
            console.warn('Could not update balance:', error.message);
          }
        }
        closeCreateMarketModal();
        loadMarkets();
        toast('Market created successfully! It will be reviewed by admins before going live.');
      } catch (error) {
        console.error('Market creation failed:', error);
        if (error.message.includes('User rejected')) {
          toast('Transaction cancelled by user');
        } else {
          toast('Failed to create market: ' + error.message);
        }
      } finally {
        setLoading(submitBtn, false);
      }
    }

    // Admin functions
    async function loadPendingMarkets() {
      if (!isAdmin) return;
      try {
        const response = await apiRequest(`/admin/pending-markets?address=${wallet.toString()}`);
        const pendingMarkets = response.markets || [];
        renderPendingMarkets(pendingMarkets);
      } catch (error) {
        console.error('Failed to load pending markets:', error);
        // Handle specific error cases
        if (error.message.includes('404')) {
          document.getElementById('pendingMarketsContainer').innerHTML = `
            <div class="empty-state">
              <h3>Admin Backend Not Available</h3>
              <p>The admin endpoints are not yet implemented on the backend.</p>
              <p style="font-size: 12px; color: #9ca3af; margin-top: 8px;">Error: ${error.message}</p>
            </div>
          `;
        } else {
          document.getElementById('pendingMarketsContainer').innerHTML = `
            <div class="empty-state">
              <h3>Error Loading Pending Markets</h3>
              <p>${error.message}</p>
              <button class="btn" onclick="loadPendingMarkets()">Retry</button>
            </div>
          `;
        }
      }
    }

    function renderPendingMarkets(pendingMarkets) {
      const container = document.getElementById('pendingMarketsContainer');
      
      if (!pendingMarkets || pendingMarkets.length === 0) {
        container.innerHTML = `
          <div class="empty-state">
            <h3>No Pending Markets</h3>
            <p>All markets have been reviewed.</p>
          </div>
        `;
        return;
      }
      
      container.innerHTML = pendingMarkets.map(market => {
        const optionsHtml = (market.options || []).map((option, index) => `
          <div class="option-preview" style="margin: 4px;">
            <img src="${option.image || 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iMTEiIGZpbGw9IiM0Yjc4OTAiLz4KPHRleHQgeD0iMTIiIHk9IjE2IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSJ3aGl0ZSIgZm9udC1zaXplPSIxMiIgZm9udC1mYW1pbHk9IkFyaWFsIj4/PC90ZXh0Pgo8L3N2Zz4='}" 
                 alt="${escapeHtml(option.name || 'Option')}" 
                 class="option-avatar" />
            <span class="option-name">${escapeHtml(option.name || 'Option')}</span>
          </div>
        `).join('');

        const oddsSection = (market.options || []).map((option, index) => `
          <div class="odds-row">
            <span style="color: #f3f4f6; font-weight: 600;">${escapeHtml(option.name || `Option ${index + 1}`)}</span>
            <div style="display: flex; align-items: center; gap: 8px;">
              <span style="color: #9ca3af; font-size: 12px;">Odds:</span>
              <input type="number" 
                     class="odds-input" 
                     placeholder="2.5" 
                     step="0.1" 
                     min="1.1"
                     id="odds-${market.id}-${index}"
                     value="${(market.metadata?.admin_odds && market.metadata.admin_odds[index] !== null && market.metadata.admin_odds[index] !== undefined && market.metadata.admin_odds[index] !== '' && market.metadata.admin_odds[index] !== 'null') ? market.metadata.admin_odds[index] : ''}">
              <span style="color: #9ca3af; font-size: 12px;">x</span>
            </div>
          </div>
        `).join('');
        
        return `
          <div class="admin-card">
            <div class="market-title">${escapeHtml(market.title || 'Untitled Market')}</div>
            <div class="market-meta" style="margin: 8px 0;">
              <div class="badge">${escapeHtml(market.category || 'Other')}</div>
              <div style="color: #9ca3af; font-size: 12px;">
                Creator: ${market.creator_address.slice(0, 8)}...
              </div>
            </div>
            <div class="options-preview" style="margin: 12px 0;">${optionsHtml}</div>
            
            <div class="admin-odds-section">
              <h4 style="color: #f59e0b; font-size: 14px; margin-bottom: 12px;">Set Odds & Returns</h4>
              ${oddsSection}
              <button onclick="updateMarketOdds(${market.id})" class="btn-secondary" style="margin-top: 8px; font-size: 12px;">Update Odds</button>
            </div>
            
            <div style="font-size: 12px; color: #9ca3af; margin: 12px 0;">
              Created: ${new Date(market.created_at).toLocaleString()}
              ${market.end_date ? ` | Ends: ${new Date(market.end_date).toLocaleString()}` : ''}
            </div>
            <div class="admin-actions">
              <button onclick="approveMarket(${market.id})" class="btn">Approve Market</button>
              <button onclick="rejectMarket(${market.id})" class="btn-danger">Reject Market</button>
              <button onclick="deleteMarket(${market.id})" class="btn-danger">Delete Market</button>
            </div>
          </div>
        `;
      }).join('');
    }

    // Missing function: Update market odds
   async function updateMarketOdds(marketId) {
  if (!isAdmin) return;
  try {
    const response = await apiRequest(`/admin/pending-markets?address=${wallet.toString()}`);
    const pendingMarkets = response.markets || [];
    const market = pendingMarkets.find(m => m.id === marketId);
    
    if (!market) {
      toast('Market not found');
      return;
    }
    
    // Collect odds from input fields
    const odds = [];
    const optionCount = market.options ? market.options.length : 0;
    
    for (let i = 0; i < optionCount; i++) {
      const oddsInput = document.getElementById(`odds-${marketId}-${i}`);
      
      if (!oddsInput) {
        toast(`Input field missing for option ${i + 1}`);
        return;
      }
      
      const inputValue = oddsInput.value.trim();
      
      // Check if empty
      if (inputValue === '' || inputValue === null || inputValue === undefined) {
        toast(`Please enter odds for option ${i + 1} (minimum 1.1)`);
        return;
      }
      
      const oddsValue = parseFloat(inputValue);
      
      if (isNaN(oddsValue)) {
        toast(`Invalid number for option ${i + 1}`);
        return;
      }
      
      if (oddsValue < 1.1) {
        toast(`Odds for option ${i + 1} must be at least 1.1`);
        return;
      }
      
      odds.push(oddsValue);
    }
    
    if (odds.length !== optionCount) {
      toast('Please enter odds for all options');
      return;
    }
    
    console.log('Sending odds update:', { marketId, odds });
    
    await apiRequest(`/admin/update-odds/${marketId}?address=${wallet.toString()}`, {
      method: 'POST',
      body: JSON.stringify({ odds: odds })
    });
    
    toast('Odds updated successfully');
    
    await loadPendingMarkets();
    await loadMarkets();
  } catch (error) {
    console.error('Failed to update odds:', error);
    toast('Failed to update odds: ' + error.message);
  }
}

       async function approveMarket(marketId) {
      if (!isAdmin) return;
      try {
        await apiRequest(`/admin/approve-market/${marketId}?address=${wallet.toString()}`, {
          method: 'POST'
        });
        toast('Market approved successfully');
        loadPendingMarkets();
      } catch (error) {
        console.error('Failed to approve market:', error);
        toast('Failed to approve market: ' + error.message);
      }
    }

    async function rejectMarket(marketId) {
      if (!isAdmin) return;
      const reason = prompt('Rejection reason (optional):');
      try {
        await apiRequest(`/admin/reject-market/${marketId}?address=${wallet.toString()}`, {
          method: 'POST',
          body: JSON.stringify({ reason: reason || 'Violated platform guidelines' })
        });
        toast('Market rejected successfully');
        loadPendingMarkets();
      } catch (error) {
        console.error('Failed to reject market:', error);
        toast('Failed to reject market: ' + error.message);
      }
    }

    async function loadMyBets() {
      const container = document.getElementById('betsContainer');
      
      if (!wallet) {
        container.innerHTML = `
          <div class="empty-state">
            <h3>Connect Wallet</h3>
            <p>Connect your wallet to view your betting history.</p>
          </div>
        `;
        return;
      }
      
      try {
        const response = await apiRequest(`/bets?address=${wallet.toString()}`);
        const bets = response.bets || [];
        if (bets.length === 0) {
          container.innerHTML = `
            <div class="empty-state">
              <h3>No Bets Yet</h3>
              <p>Your betting history will appear here once you place your first bet.</p>
            </div>
          `;
        } else {
          // For each bet, fetch the market to get options and odds
          const betCards = await Promise.all(bets.map(async bet => {
            let optionName = '';
            let optionImage = '';
            let odds = 2.0;
            if (bet.option_id !== undefined && bet.market_id) {
              try {
                const res = await apiRequest(`/markets/${bet.market_id}`);
                if (res.market && res.market.options && res.market.options[bet.option_id]) {
                  optionName = res.market.options[bet.option_id].name || '';
                  optionImage = res.market.options[bet.option_id].image || '';
                  // Try to get odds from metadata
                  if (res.market.metadata && res.market.metadata.admin_odds && res.market.metadata.admin_odds[bet.option_id] !== null && res.market.metadata.admin_odds[bet.option_id] !== undefined && res.market.metadata.admin_odds[bet.option_id] !== '' && res.market.metadata.admin_odds[bet.option_id] !== 'null') {
                    odds = parseFloat(res.market.metadata.admin_odds[bet.option_id]);
                  }
                }
              } catch (error) {
                console.warn('Failed to load market data for bet:', error);
              }
            }
            const potentialReturn = (parseFloat(bet.amount || 0) * odds).toFixed(3);
            return `
              <div class="admin-card">
                <div class="market-title">${escapeHtml(bet.market_title || 'Unknown Market')}</div>
                <div style="display:flex;align-items:center;gap:12px;margin:8px 0;">
                  <span style="color: #10b981; font-weight: 700;">Amount: ${parseFloat(bet.amount || 0).toFixed(3)} BNB</span>
                  ${optionImage ? `<img src='${optionImage}' alt='' style='width:22px;height:22px;border-radius:50%;background:#181e29;margin-left:8px;'>` : ''}
                  <span style="font-weight:600;color:#9aff00;">${escapeHtml(optionName)}</span>
                </div>
                <div style="color:#f59e0b;font-weight:700;margin-bottom:4px;">Potential Return: ${potentialReturn} BNB</div>
                <div style="color: #9ca3af; font-size: 12px;">
                  ${new Date(bet.created_at).toLocaleDateString()}
                  ${bet.transaction_signature ? ` | <a href=\"https://bscscan.com/tx/${bet.transaction_signature}\" target=\"_blank\" style=\"color: #10b981;\">View TX</a>` : ''}
                </div>
              </div>
            `;
          }));
          container.innerHTML = betCards.join('');
        }
      } catch (error) {
        console.error('Failed to load bets:', error);
        container.innerHTML = `
          <div class="empty-state">
            <h3>Error Loading Bets</h3>
            <p>${error.message}</p>
          </div>
        `;
      }
    }

    async function loadClaimableWinnings() {
      const container = document.getElementById('claimContainer');
      
      if (!wallet) {
        container.innerHTML = `
          <div class="empty-state">
            <h3>Connect Wallet</h3>
            <p>Connect your wallet to view and claim your winnings.</p>
          </div>
        `;
        return;
      }
      
      try {
        const response = await apiRequest(`/claimable/${wallet.toString()}`);
        const claimableBets = response.claimable_bets || [];
        const totalClaimable = response.total_claimable || 0;
        
        if (claimableBets.length === 0) {
          container.innerHTML = `
            <div class="empty-state">
              <h3>No Winnings to Claim</h3>
              <p>You don't have any unclaimed winnings from resolved markets.</p>
            </div>
          `;
        } else {
          // Show total claimable amount at the top
          let html = `
            <div class="admin-card" style="margin-bottom: 24px; background: linear-gradient(135deg, #059669, #047857);">
              <h3 style="color: #f0fdf4; margin-bottom: 12px; font-size: 18px;">Total Claimable Winnings</h3>
              <div style="font-size: 36px; font-weight: 700; color: #ffffff; margin-bottom: 16px;">
                ${totalClaimable.toFixed(4)} BNB
              </div>
              <div style="color: #d1fae5; font-size: 14px;">
                ${claimableBets.length} winning bet${claimableBets.length !== 1 ? 's' : ''} available to claim
              </div>
            </div>
            <div class="grid" style="grid-template-columns: repeat(auto-fill, minmax(400px, 1fr)); gap: 20px;">
          `;
          
          claimableBets.forEach(bet => {
            const options = bet.options || [];
            const optionName = options[bet.option_id]?.name || `Option ${bet.option_id}`;
            const payoutAmount = bet.calculated_payout || 0;
            const betAmount = parseFloat(bet.amount || 0);
            const profit = payoutAmount - betAmount;
            
            html += `
              <div class="market-card">
                <div class="market-header">
                  <h3 class="market-title">${bet.market_title}</h3>
                  <div class="market-category" style="background: #059669;">${bet.category}</div>
                </div>
                
                <div style="margin: 16px 0;">
                  <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <span style="color: #9ca3af;">Your Bet:</span>
                    <span style="color: #f9fafb; font-weight: 600;">${optionName}</span>
                  </div>
                  <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <span style="color: #9ca3af;">Amount Bet:</span>
                    <span style="color: #f9fafb;">${betAmount.toFixed(4)} BNB</span>
                  </div>
                  <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <span style="color: #9ca3af;">Payout:</span>
                    <span style="color: #10b981; font-weight: 600;">${payoutAmount.toFixed(4)} BNB</span>
                  </div>
                  <div style="display: flex; justify-content: space-between; margin-bottom: 16px;">
                    <span style="color: #9ca3af;">Profit:</span>
                    <span style="color: #10b981; font-weight: 700; font-size: 16px;">+${profit.toFixed(4)} BNB</span>
                  </div>
                </div>
                
                <button class="btn btn-primary" onclick="claimWinnings(${bet.id}, ${payoutAmount})" style="width: 100%; background: linear-gradient(135deg, #10b981, #059669);">
                  Claim ${payoutAmount.toFixed(4)} BNB
                </button>
              </div>
            `;
          });
          
          html += '</div>';
          container.innerHTML = html;
        }
      } catch (error) {
        console.error('Failed to load claimable winnings:', error);
        container.innerHTML = `
          <div class="empty-state">
            <h3>Error Loading Winnings</h3>
            <p>${error.message}</p>
          </div>
        `;
      }
    }

    async function loadTreasuryStats() {
      try {
        // Get treasury data from API
        const treasuryResponse = await apiRequest('/treasury');
        
        // Display treasury balance from API calculation
        document.getElementById('treasuryBalance').textContent = `${parseFloat(treasuryResponse.treasury || 0).toFixed(4)} BNB`;
        document.getElementById('creationFees').textContent = `${parseFloat(treasuryResponse.creation_fees || 0).toFixed(6)} BNB`;
        
        // Get market stats
        const statsResponse = await apiRequest('/stats');
        document.getElementById('marketCount').textContent = statsResponse.totalMarkets || 0;
        document.getElementById('totalVolume').textContent = `${parseFloat(statsResponse.totalVolume || 0).toFixed(3)} BNB`;
        
      } catch (error) {
        console.error('Failed to load treasury stats:', error);
        document.getElementById('treasuryBalance').textContent = 'Error';
        document.getElementById('marketCount').textContent = 'Error';
        document.getElementById('totalVolume').textContent = 'Error';
        document.getElementById('creationFees').textContent = 'Error';
      }
    }

    // Event listeners
    document.addEventListener('DOMContentLoaded', async () => {
      console.log('DOM Loaded - Page ready');

      // Initialize Reactive Odds Engine
      if (typeof OddsEngine !== 'undefined') {
        window.oddsEngine = new OddsEngine();
        console.log('🎯 Reactive Odds Engine initialized successfully');
      } else {
        console.warn('OddsEngine not available - odds-engine.js may not be loaded');
      }

      // Test if buttons exist
      const walletBtn = document.getElementById('walletBtn');
      const createBtn = document.getElementById('createMarketBtn');
      console.log('Wallet button:', walletBtn ? 'FOUND' : 'MISSING');
      console.log('Create button:', createBtn ? 'FOUND' : 'MISSING');

      // Test button clicks
      if (walletBtn) {
        walletBtn.onclick = function() {
          console.log('Wallet button clicked!');
          if (wallet) {
            disconnectWallet();
          } else {
            connectWallet();
          }
        };
      }

      // Test API connection
      fetch(window.location.origin + '/api/health')
        .then(r => r.json())
        .then(d => console.log('API Health:', d))
        .catch(e => console.error('API Error:', e));

      // Initialize odds engine
      if (typeof OddsEngine !== 'undefined') {
        oddsEngine = new OddsEngine();
        oddsVisualizer = new OddsVisualizer(oddsEngine);
        console.log('Odds engine initialized successfully');

        // Initialize demo system
        if (typeof ReactiveOddsDemo !== 'undefined') {
          window.reactiveOddsDemo = new ReactiveOddsDemo(oddsEngine);
          console.log('✅ Reactive Odds Demo system ready');

          // Add demo button to header
          addDemoButton();
        }
      } else {
        console.warn('OddsEngine not available - odds-engine.js may not be loaded');
      }

      // Function to add demo button
      function addDemoButton() {
        const headerInner = document.querySelector('.header-inner');
        if (headerInner) {
          const demoButton = document.createElement('button');
          demoButton.innerHTML = '🎮 Demo Reactive Odds';
          demoButton.style.cssText = `
            background: linear-gradient(135deg, #9aff00, #7acc00);
            color: #0b0b0f;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
          `;

          demoButton.addEventListener('mouseover', () => {
            demoButton.style.transform = 'scale(1.05)';
            demoButton.style.boxShadow = '0 4px 12px rgba(154, 255, 0, 0.3)';
          });

          demoButton.addEventListener('mouseout', () => {
            demoButton.style.transform = 'scale(1)';
            demoButton.style.boxShadow = 'none';
          });

          demoButton.addEventListener('click', () => {
            if (window.reactiveOddsDemo) {
              window.reactiveOddsDemo.startDemo();
            }
          });

          // Insert before wallet button
          const walletBtn = document.getElementById('walletBtn');
          if (walletBtn) {
            headerInner.insertBefore(demoButton, walletBtn);
          } else {
            headerInner.appendChild(demoButton);
          }
        }
      }

      // MetaMask event listeners for better connection stability
      if (window.ethereum) {
        // Listen for account changes
        window.ethereum.on('accountsChanged', (accounts) => {
          if (accounts.length === 0) {
            disconnectWallet();
          } else {
            wallet = accounts[0];
            isAdmin = wallet.toString() === ADMIN_WALLET;
            updateWalletUI();
          }
        });
        
        window.ethereum.on('chainChanged', () => {
          location.reload();
        });
      }
      
      // Initialize
      const web3Ready = await initializeWeb3();
      if (!web3Ready) {
        console.log('Web3 initialization failed or MetaMask not available');
      }
      
      // Navigation
      document.querySelectorAll('.nav-link').forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          showSection(link.dataset.section);
        });
      });
      
      // Wallet
      document.getElementById('walletBtn').addEventListener('click', () => {
        if (wallet) {
          disconnectWallet();
        } else {
          connectWallet();
        }
      });
      
      // Create market modal
      document.getElementById('createMarketBtn').addEventListener('click', openCreateMarketModal);

      document.getElementById('cancelCreateBtn').addEventListener('click', closeCreateMarketModal);
      document.getElementById('submitCreateBtn').addEventListener('click', createMarket);
      document.getElementById('addOptionBtn').addEventListener('click', addOption);
      
      // Admin
      document.getElementById('refreshPendingBtn').addEventListener('click', loadPendingMarkets);
      
      // Modal backdrop clicks
      document.getElementById('createMarketModal').addEventListener('click', (e) => {
        if (e.target.id === 'createMarketModal') {
          closeCreateMarketModal();
        }
      });
      
      document.getElementById('marketDetailModal').addEventListener('click', (e) => {
        if (e.target.id === 'marketDetailModal') {
          closeMarketDetailModal();
        }
      });
      
      // Betting interface events
      document.getElementById('betAmount').addEventListener('input', calculatePotentialReturn);
      document.getElementById('placeBetBtn').addEventListener('click', placeBet);
      
      // Check backend connectivity and load initial data
      try {
        await loadMarkets();
        console.log('Backend connected successfully');
      } catch (error) {
        console.warn('Backend connection failed on startup:', error.message);
        updateStatus(false);
      }
      
      console.log('Solymarket initialized successfully');
    });

    // Make functions global for HTML onclick handlers
    window.connectWallet = connectWallet;
    window.disconnectWallet = disconnectWallet;
    window.showSection = showSection;
    window.closeModal = closeModal;
    window.toast = toast;
    window.showMarketDetail = showMarketDetail;
    window.openCreateMarketModal = openCreateMarketModal;
    window.closeMarketDetailModal = closeMarketDetailModal;
    window.selectBettingOption = selectBettingOption;
    window.addOption = addOption;
    window.removeOption = removeOption;
    window.updateOptionName = updateOptionName;
    window.handleOptionImage = handleOptionImage;
    window.updateMarketOdds = updateMarketOdds;
    window.approveMarket = approveMarket;
    window.rejectMarket = rejectMarket;
    window.deleteMarket = deleteMarket;
    window.loadMarkets = loadMarkets;
    window.loadPendingMarkets = loadPendingMarkets;
    window.placeBet = placeBet;
    window.createMarket = createMarket;

    // Admin: Delete market function
    async function deleteMarket(marketId) {
      if (!isAdmin) return;
      if (!confirm('Are you sure you want to permanently delete this market? This cannot be undone.')) return;
      try {
        await apiRequest(`/admin/delete-market/${marketId}?address=${wallet.toString()}`, {
          method: 'POST'
        });
        toast('Market deleted successfully');
        loadPendingMarkets();
      } catch (error) {
        console.error('Failed to delete market:', error);
        toast('Failed to delete market: ' + error.message);
      }
    }
  </script>
  <!-- Ensure handleMarketImageChange is always globally available for HTML input onchange -->
  <script>
  function handleMarketImageChange(e) {
    const file = e.target.files[0];
    const preview = document.getElementById('marketImagePreview');
    const placeholder = document.getElementById('marketImagePlaceholder');
    const labelText = document.getElementById('marketImageLabelText');
    if (file) {
      const reader = new FileReader();
      reader.onload = function(ev) {
        preview.src = ev.target.result;
        preview.style.display = 'block';
        placeholder.style.display = 'none';
      };
      reader.readAsDataURL(file);
      labelText.textContent = file.name;
    } else {
      preview.src = '';
      preview.style.display = 'none';
      placeholder.style.display = 'block';
      labelText.textContent = 'Choose image';
    }
  }
  window.handleMarketImageChange = handleMarketImageChange;
  </script>
  <!-- Market Detail Modal -->
<div id="marketDetailModal" class="modal">
  <div class="modal-content">
    <h3 id="marketDetailTitle" class="modal-title">Market Details</h3>
    <div id="marketDetailContent">
      <!-- Market details will be populated by JavaScript -->
    </div>
    
    <div id="bettingOptions" class="betting-options">
      <!-- Betting options will be populated -->
    </div>
    
    <div class="betting-form">
      <div id="bettingWarning" class="betting-warning" style="display: none;">
        Connect your wallet to place bets
      </div>
      
      <div class="form-group">
        <label class="form-label" for="betAmount">Bet Amount (BNB)</label>
        <input type="number" id="betAmount" class="form-input" min="0" step="0.001" placeholder="0.000">
      </div>
      
      <div style="background: rgba(154, 255, 0, 0.08); padding: 16px; border-radius: 8px; text-align: center; margin-bottom: 16px;">
        <div style="color: #9ca3af; font-size: 14px;">Potential Return</div>
        <div id="potentialReturn" style="font-size: 20px; font-weight: 700; color: #9aff00;">0.00 BNB</div>
      </div>
      
      <button id="placeBetBtn" class="btn" style="width: 100%;">Place Bet</button>
    </div>
    
    <div style="text-align: center; margin-top: 20px;">
      <button onclick="closeMarketDetailModal()" class="btn-secondary">Close</button>
    </div>
  </div>
</div>

<script src="odds-engine.js"></script>
</body>
</html>
