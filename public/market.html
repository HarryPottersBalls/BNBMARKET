<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>陰陽市場 - Market</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inter:400,600,700&display=swap">
  <style>
    body {
      font-family: 'Inter', Arial, sans-serif;
      background: linear-gradient(135deg, #111827 0%, #374151 50%, #111827 100%) !important;
      color: #e5e7eb !important;
      margin: 0;
      padding: 0;
      min-height: 100vh;
    }
    .primary {
      color: #6b7280 !important;
    }
    .accent {
      color: #9ca3af !important;
    }
    .danger {
      color: #9ca3af;
    }
    .surface {
      background: linear-gradient(135deg, #374151, #1f2937) !important;
    }
    .btn {
      background: linear-gradient(135deg, #374151 0%, #4b5563 100%) !important;
      color: white !important;
      border: 2px solid #6b7280 !important;
      padding: 10px 16px;
      border-radius: 8px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      box-shadow: 0 4px 14px rgba(107,114,128,0.3) !important;
      transition: background 0.2s, color 0.2s, transform 0.2s, box-shadow 0.2s;
    }
    .btn:hover {
      background: linear-gradient(135deg, #4b5563 0%, #6b7280 100%) !important;
      color: white !important;
      box-shadow: 0 6px 20px rgba(107,114,128,0.4) !important;
      transform: translateY(-1px) scale(1.03);
    }
    .btn.secondary {
      background: rgba(55,65,81,0.3) !important;
      color: #9ca3af !important;
      border: 1.5px solid #374151 !important;
    }
    .btn.danger, .btn.danger:hover {
      background: linear-gradient(135deg, #374151 0%, #4b5563 100%) !important;
      color: #fff !important;
      border: 2px solid #6b7280 !important;
      box-shadow: 0 4px 14px rgba(107,114,128,0.3) !important;
    }
    .badge-success {
      background: rgba(107,114,128,0.2) !important;
      color: #6b7280 !important;
      border-radius: 6px;
      padding: 2px 10px;
      font-size: 0.95em;
      font-weight: 600;
      display: inline-block;
    }
    .badge-pending {
      background: rgba(156,163,175,0.2) !important;
      color: #9ca3af !important;
      border-radius: 6px;
      padding: 2px 10px;
      font-size: 0.95em;
      font-weight: 600;
      display: inline-block;
    }
    .border-accent {
      border: 1.5px solid #6b7280 !important;
    }
    .border-subtle {
      border: 1.5px solid rgba(55,65,81,0.3) !important;
    }
    .text-secondary {
      color: #9ca3af !important;
    }
    .text-warning {
      color: #9ca3af !important;
    }
    .text-error {
      color: #9ca3af;
    }
    .text-title {
      color: #e5e7eb !important;
    }
    
    /* Header Styles */
    .header {
      background: linear-gradient(135deg, #374151 0%, #111827 50%, #374151 100%) !important;
      backdrop-filter: blur(8px);
      border-bottom: 2px solid #4b5563 !important;
      padding: 16px 20px;
      position: sticky;
      top: 0;
      z-index: 40;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    
    .header-inner {
      max-width: 1200px;
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 20px;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 700;
      color: #e5e7eb !important;
      font-size: 20px;
      text-decoration: none;
    }

    .brand .logo {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: linear-gradient(45deg, #e5e7eb 50%, #111827 50%);
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .brand .logo::before {
      content: '';
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #111827;
      position: absolute;
      top: 5px;
    }

    .brand .logo::after {
      content: '';
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #e5e7eb;
      position: absolute;
      bottom: 5px;
    }

    .nav {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .nav a {
      padding: 10px 16px;
      border-radius: 8px;
      color: #d1d5db;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      text-decoration: none;
      transition: all 0.2s;
    }

    .nav a.active, .nav a:hover {
      color: #e5e7eb;
      background: rgba(156, 163, 175, 0.1);
    }

    .nav a.admin {
      background: rgba(156, 163, 175, 0.1);
      color: #9ca3af;
      border: 1px solid rgba(156, 163, 175, 0.2);
    }

    .wallet-group {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .balance {
      background: rgba(55, 65, 81, 0.3);
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid rgba(75, 85, 99, 0.4);
      font-size: 13px;
      font-weight: 600;
      color: #e5e7eb;
    }

    .wallet-btn {
      background: linear-gradient(135deg, #374151 0%, #4b5563 100%);
      color: #e5e7eb;
      border: none;
      padding: 10px 16px;
      border-radius: 8px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .wallet-btn:hover {
      transform: translateY(-1px);
      background: linear-gradient(135deg, #4b5563 0%, #6b7280 100%);
    }

    .wallet-btn.connected {
      background: transparent;
      border: 1px solid #9ca3af;
      color: #9ca3af;
    }

    /* Language Switcher Styles */
    .language-switcher {
      position: relative;
      display: inline-block;
    }

    .lang-btn:hover {
      background: rgba(156, 163, 175, 0.1);
      border-color: rgba(156, 163, 175, 0.3);
    }

    .lang-dropdown {
      min-width: 120px;
    }

    .lang-option:hover {
      background: rgba(156, 163, 175, 0.1);
      color: #9ca3af;
    }

    /* Chart Tab Styles */
    .chart-tab {
      background: transparent;
      border: none;
      color: #9ca3af;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .chart-tab:hover {
      color: #d1d5db;
      background: rgba(156, 163, 175, 0.1);
    }
    
    .chart-tab.active {
      color: #e5e7eb;
      background: rgba(156, 163, 175, 0.2);
      border: 1px solid rgba(156, 163, 175, 0.3);
    }

    /* Yin Yang Option Buttons - Contrasting Binary Choices */
    .option-tab.yang {
      background: linear-gradient(135deg, #f8fafc, #e2e8f0) !important;
      color: #1e293b !important;
      border: 2px solid #cbd5e1 !important;
      box-shadow: 0 4px 12px rgba(248, 250, 252, 0.2) !important;
    }
    
    .option-tab.yang:hover {
      background: linear-gradient(135deg, #e2e8f0, #cbd5e1) !important;
      color: #0f172a !important;
      border: 2px solid #94a3b8 !important;
      box-shadow: 0 6px 16px rgba(248, 250, 252, 0.3) !important;
      transform: translateY(-1px) scale(1.02);
    }
    
    .option-tab.yang.active {
      background: linear-gradient(135deg, #ffffff, #f1f5f9) !important;
      color: #0f172a !important;
      border: 2px solid #06b6d4 !important;
      box-shadow: 0 0 0 3px rgba(6, 182, 212, 0.2), 0 6px 20px rgba(6, 182, 212, 0.1) !important;
    }
    
    .option-tab.yin {
      background: linear-gradient(135deg, #1e293b, #334155) !important;
      color: #e2e8f0 !important;
      border: 2px solid #475569 !important;
      box-shadow: 0 4px 12px rgba(30, 41, 59, 0.3) !important;
    }
    
    .option-tab.yin:hover {
      background: linear-gradient(135deg, #334155, #475569) !important;
      color: #f8fafc !important;
      border: 2px solid #64748b !important;
      box-shadow: 0 6px 16px rgba(30, 41, 59, 0.4) !important;
      transform: translateY(-1px) scale(1.02);
    }
    
    .option-tab.yin.active {
      background: linear-gradient(135deg, #0f172a, #1e293b) !important;
      color: #f8fafc !important;
      border: 2px solid #9ca3af !important;
      box-shadow: 0 0 0 3px rgba(156, 163, 175, 0.2), 0 6px 20px rgba(156, 163, 175, 0.1) !important;
    }

    /* Enhanced Trade Panel with Yang Light Accent */
    .trade-card.yang-enhanced {
      background: linear-gradient(135deg, #f8fafc, #e2e8f0, #1f2937) !important;
      border: 2px solid #cbd5e1 !important;
      box-shadow: 0 0 0 1px rgba(6, 182, 212, 0.1), 0 8px 32px rgba(248, 250, 252, 0.08) !important;
    }

    /* Alternating Market Cards for Flow */
    .market-section.yang-flow {
      background: linear-gradient(135deg, #f8fafc, #e2e8f0, #cbd5e1) !important;
      color: #0f172a !important;
      border: 1px solid #cbd5e1 !important;
    }
    
    .market-section.yin-flow {
      background: linear-gradient(135deg, #0f172a, #1e293b, #334155) !important;
      color: #e2e8f0 !important;
      border: 1px solid #475569 !important;
    }

    /* Purchase Button Yang Enhancement */
    .btn.yang-primary {
      background: linear-gradient(135deg, #06b6d4, #0891b2) !important;
      color: #ffffff !important;
      border: 2px solid #0891b2 !important;
      box-shadow: 0 0 0 3px rgba(6, 182, 212, 0.1), 0 6px 20px rgba(6, 182, 212, 0.2) !important;
    }
    
    .btn.yang-primary:hover {
      background: linear-gradient(135deg, #0891b2, #0e7490) !important;
      box-shadow: 0 0 0 3px rgba(6, 182, 212, 0.2), 0 8px 24px rgba(6, 182, 212, 0.3) !important;
      transform: translateY(-2px) scale(1.03);
    }
  </style>
</head>
<body>
  <header class="header">
    <div class="header-inner">
      <a href="index.html" class="brand">
        <div class="logo"></div>
        <div>
          <div>陰陽市場</div>
          <div style="font-size: 12px; color: #9ca3af; font-weight: 400;">Balance • Harmony • Truth</div>
        </div>
      </a>
      <nav class="nav">
        <a href="index.html" class="nav-link">Markets</a>
        <a href="index.html" class="nav-link" id="myBetsNavLink" data-i18n="myBets">My Bets</a>
        <a href="index.html" class="nav-link" data-i18n="treasury">Treasury</a>
        <a href="index.html" class="nav-link" data-i18n="howItWorks">How It Works</a>
        <a href="index.html" id="adminTab" class="nav-link admin" style="display:none" data-i18n="adminPanel">Admin Panel</a>
      </nav>
      <div class="wallet-group">
        <!-- Language Switcher -->
        <div class="language-switcher" style="margin-right:12px;">
          <button id="langBtn" class="lang-btn" style="background:rgba(55,65,81,0.3);border:1px solid rgba(75,85,99,0.4);color:#e5e7eb;padding:8px 12px;border-radius:6px;font-size:13px;cursor:pointer;transition:all 0.2s;">
            🌍 EN
          </button>
          <div id="langDropdown" class="lang-dropdown" style="display:none;position:absolute;top:100%;right:0;background:#374151;border:1px solid rgba(75,85,99,0.4);border-radius:8px;padding:4px;margin-top:4px;box-shadow:0 4px 12px rgba(0,0,0,0.3);z-index:1000;">
            <button class="lang-option" data-lang="en" style="display:block;width:100%;text-align:left;background:none;border:none;color:#e5e7eb;padding:8px 12px;border-radius:4px;cursor:pointer;font-size:13px;transition:background 0.2s;">🇺🇸 English</button>
            <button class="lang-option" data-lang="zh-CN" style="display:block;width:100%;text-align:left;background:none;border:none;color:#e5e7eb;padding:8px 12px;border-radius:4px;cursor:pointer;font-size:13px;transition:background 0.2s;">🇨🇳 中文</button>
          </div>
        </div>
        <div class="balance" id="balanceDisplay" style="display:none;">
          BNB: <span id="bnbBalance">0.000</span>
        </div>
        <button id="walletBtn" class="btn wallet-btn" data-i18n="connectWallet">Connect Wallet</button>
      </div>
    </div>
  </header>

  <main>
    <section id="marketSection" class="market-section yin-flow" style="max-width:1200px;margin:40px auto 0 auto;padding:40px 36px 48px 36px;background:linear-gradient(135deg, rgba(31,41,55,0.8), rgba(55,65,81,0.6));border-radius:22px;box-shadow:0 4px 40px rgba(0,0,0,0.3);border:1px solid #4b5563;position:relative;overflow:hidden;">
      <!-- Add subtle Yin Yang background pattern -->
      <div style="position:absolute;top:20px;right:30px;font-size:3rem;opacity:0.08;color:#9ca3af;pointer-events:none;">☯</div>
      <div style="position:absolute;bottom:20px;left:30px;font-size:2rem;opacity:0.05;color:#06b6d4;pointer-events:none;">☯</div>
      <div id="marketInfo">
        <h2 id="marketTitle" class="primary" style="margin-bottom:8px;font-size:2rem;font-weight:800;"></h2>
        <div id="marketMeta" style="color:#9ca3af;font-size:1rem;margin-bottom:8px;"></div>
        <div id="marketVolume" style="color:#06b6d4;font-size:1.08rem;font-weight:700;margin-bottom:8px;"></div>
        <div id="marketOptions" style="display:flex;gap:18px;margin-bottom:32px;"></div>
        <div id="totalBuys" style="color:#9ca3af;font-size:1.1rem;font-weight:600;margin-bottom:18px;"></div>
      </div>
      
      <div style="margin-bottom:32px;">
        <div style="display: flex; gap: 40px; align-items: flex-start; flex-wrap: wrap; width: 100%;">
          <div style="flex: 2.5; min-width: 420px; background: linear-gradient(135deg, #1f2937 0%, #374151 100%); border-radius: 18px; padding: 32px 24px 32px 24px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); border: 1px solid #4b5563; position: relative;">
            <!-- Subtle Yin Yang symbol in chart area -->
            <div style="position:absolute;top:15px;right:20px;font-size:1.5rem;opacity:0.1;color:#06b6d4;pointer-events:none;">☯</div>
            
            <!-- Chart Tabs -->
            <div style="display: flex; gap: 8px; margin-bottom: 20px; border-bottom: 1px solid #4b5563; padding-bottom: 12px;">
              <button id="probabilityTab" class="chart-tab active" onclick="switchChart('probability')" data-i18n="marketConfidenceOverTime">Market Confidence Over Time</button>
              <button id="distributionTab" class="chart-tab" onclick="switchChart('distribution')" data-i18n="currentMarketDistribution">Current Market Distribution</button>
            </div>
            
            <!-- Chart Containers -->
            <div id="probabilityChartContainer" style="height: 300px; position: relative;">
              <canvas id="probabilityChart"></canvas>
            </div>
            <div id="distributionChartContainer" style="height: 300px; position: relative; display: none;">
              <canvas id="distributionChart"></canvas>
            </div>
          </div>
          
          <div class="trade-card yang-enhanced" style="background:linear-gradient(135deg, #1f2937, #374151);border:1.5px solid #4b5563;border-radius:18px;box-shadow:0 4px 32px rgba(75,85,99,0.3);padding:36px 32px 28px 32px;max-width:440px;width:100%;min-width:340px;margin-top:0;">
            <div style="display:flex;align-items:center;gap:12px;margin-bottom:10px;">
              <div id="tradeOptionName" style="color:#9ca3af;font-weight:800;font-size:1.15rem;display:flex;align-items:center;gap:8px;"></div>
            </div>
            <div id="tradeOdds" style="color:#9ca3af;font-size:1.05rem;margin-bottom:10px;font-weight:600;"></div>
            <div style="display:flex;gap:8px;margin-bottom:12px;">
              <button class="btn quick-btn" type="button" data-amount="0.1" style="flex:1;min-width:0;background:#374151;color:#9ca3af;border:1.5px solid #6b7280;">0.1</button>
              <button class="btn quick-btn" type="button" data-amount="0.5" style="flex:1;min-width:0;background:#374151;color:#9ca3af;border:1.5px solid #6b7280;">0.5</button>
              <button class="btn quick-btn" type="button" data-amount="1" style="flex:1;min-width:0;background:#374151;color:#9ca3af;border:1.5px solid #6b7280;">1</button>
              <button class="btn quick-btn-max" type="button" style="flex:1;min-width:0;background:#374151;color:#9ca3af;border:1.5px solid #6b7280;" title="Max">Max</button>
            </div>
            <input id="tradeAmount" type="number" min="0.01" step="0.01" placeholder="Amount (BNB)" data-i18n-placeholder="amount" style="width:100%;padding:16px 14px;border-radius:10px;border:2px solid #6b7280;background:#1f2937;color:#e5e7eb;font-size:1.2rem;margin-bottom:10px;outline:none;box-shadow:none;">
            <div id="feeBreakdown" style="color:#9ca3af;font-size:0.95rem;margin-bottom:10px;font-weight:500;background:rgba(156,163,175,0.08);padding:6px 8px;border-radius:6px;display:none;">
              <span data-i18n="platformFee">Platform Fee</span> (1%): <span id="platformFeeAmount">0.000 BNB</span> | <span data-i18n="netInvestment">Net Investment</span>: <span id="netBetAmount">0.000 BNB</span>
            </div>
            <div id="profitCalc" style="color:#9ca3af;font-size:1.08rem;margin-bottom:14px;font-weight:600;background:rgba(156,163,175,0.07);padding:8px 10px;border-radius:8px;"></div>
            <div style="display:flex;gap:10px;margin-bottom:10px;align-items:flex-start;">
              <button id="buyBtn" class="btn yang-primary" style="flex:1;width:100%;font-size:1.08rem;padding:13px 0;box-shadow:0 2px 8px rgba(156,163,175,0.07);" data-i18n="purchaseShares">Purchase Shares</button>
            </div>
            <div style="display:flex;gap:10px;margin-bottom:10px;align-items:flex-start;">
              <button id="cancelBtn" class="btn" style="flex:1;width:100%;background:#ef4444;color:#fff;font-size:1.08rem;padding:13px 0;box-shadow:0 2px 8px rgba(239,68,68,0.13);border:1.5px solid #ef4444;" data-i18n="requestRefund">Request Refund</button>
            </div>
            <hr style="border:none;border-top:1px solid #4b5563;margin:12px 0 10px 0;">
            <div id="tradeMsg" style="margin-top:0;color:#9ca3af;font-size:1.05rem;min-height:22px;"></div>
          </div>
        </div>
        
        <!-- Enhanced Yin Yang Order Book -->
        <div id="yinYangOrderBook" style="margin-top:40px;background:linear-gradient(135deg, #0f172a, #1e293b);border-radius:18px;padding:32px 24px;box-shadow:0 4px 32px rgba(0,0,0,0.2);border:1px solid #334155;position:relative;">
          <!-- Yin Yang background symbol -->
          <div style="position:absolute;top:20px;right:30px;font-size:2rem;opacity:0.08;color:#06b6d4;pointer-events:none;">☯</div>
          
          <div style="margin-bottom:24px;">
            <div style="display:flex;align-items:center;gap:12px;margin-bottom:8px;">
              <div style="width:40px;height:40px;border-radius:50%;background:linear-gradient(45deg, #f8fafc, #9ca3af);"></div>
              <div>
                <h2 style="color:#f8fafc;font-size:1.5rem;font-weight:800;margin:0;">陰陽市場 Order Book</h2>
                <p style="color:#94a3b8;font-size:0.9rem;margin:0;">Balance • Harmony • Truth</p>
              </div>
            </div>
          </div>

          <!-- Market Info Header -->
          <div style="background:rgba(51,65,85,0.3);border:1px solid #475569;border-radius:12px;padding:24px;margin-bottom:24px;">
            <h3 style="color:#f8fafc;font-size:1.25rem;font-weight:700;margin-bottom:8px;">Market Outcome Ranges</h3>
            <p style="color:#94a3b8;font-size:0.9rem;margin-bottom:16px;">Select an outcome range to place your prediction</p>
            <div style="display:grid;grid-template-columns:2fr 1fr 2fr;gap:32px;font-size:0.85rem;color:#64748b;font-weight:600;">
              <span style="color:#06b6d4;">OUTCOME</span>
              <span style="text-align:center;color:#9ca3af;">% CHANCE</span>
              <span style="text-align:right;color:#9ca3af;">ACTIONS</span>
            </div>
          </div>

          <!-- Order Book Entries -->
          <div id="orderBookEntries" style="display:flex;flex-direction:column;gap:8px;">
            <!-- Will be populated by JavaScript -->
          </div>

          <!-- Selection Feedback -->
          <div id="selectionFeedback" style="margin-top:24px;background:rgba(51,65,85,0.3);border:1px solid #475569;border-radius:12px;padding:16px;display:none;">
            <div style="font-size:0.9rem;color:#94a3b8;">
              Last selection: <span id="selectedRange" style="color:#f8fafc;font-weight:700;"></span> • 
              <span id="selectedSide" style="color:#f8fafc;"></span> • 
              <span id="selectedPrice" style="color:#06b6d4;"></span>
            </div>
          </div>
        </div>
        
        <div id="orderBook" style="margin-top:32px;"></div>
      </div>
      
      <!-- Comment Section -->
      <section id="commentSection" style="margin-top:40px;background:linear-gradient(135deg, #0f172a, #1e293b);border-radius:16px;padding:28px 24px 18px 24px;box-shadow:0 2px 16px rgba(16,185,129,0.07);max-width:700px;margin-left:auto;margin-right:auto;border:1px solid #334155;position:relative;">
        <!-- Yin symbol for comments -->
        <div style="position:absolute;top:15px;right:20px;font-size:1.5rem;opacity:0.08;color:#9ca3af;pointer-events:none;">🌙</div>
        
        <h3 style="color:#9ca3af;margin-bottom:10px;font-size:1.25rem;font-weight:700;" data-i18n="comments">Comments</h3>
        <div id="commentsList" style="margin-bottom:18px;"></div>
        <div id="commentBoxContainer" style="display:none;">
          <textarea id="commentInput" rows="3" maxlength="300" placeholder="Write a comment..." data-i18n-placeholder="writeComment" style="width:100%;padding:12px 10px;border-radius:8px;border:1.5px solid #475569;background:#1e293b;color:#e6eef8;font-size:1.08rem;resize:vertical;margin-bottom:8px;"></textarea>
          <div style="display:flex;align-items:center;justify-content:space-between;">
            <span id="commentWarning" style="color:#fbbf24;font-size:0.98rem;" data-i18n="warningScammers">Do not click any links beware of scammers.</span>
            <button id="postCommentBtn" class="btn yang-primary" style="padding:8px 18px;font-size:1rem;" data-i18n="postComment">Post</button>
          </div>
          <div id="commentMsg" style="color:#ff6b6b;font-size:0.98rem;margin-top:6px;min-height:18px;"></div>
        </div>
        <div id="commentLoginMsg" style="color:#bcd3e6;font-size:1.05rem;margin-top:8px;"></div>
      </section>
    </section>

    <!-- My Bets Section -->
    <section id="mybetsSection" class="market-section yang-flow" style="display:none;max-width:900px;margin:40px auto 0 auto;padding:32px 24px 40px 24px;background:linear-gradient(180deg, rgba(248,250,252,0.1), rgba(226,232,240,0.08), rgba(31,41,55,0.6));border-radius:18px;box-shadow:0 4px 32px rgba(0,0,0,0.10);border:1px solid rgba(203,213,225,0.1);position:relative;">
      <!-- Subtle Yang background symbol -->
      <div style="position:absolute;top:25px;right:30px;font-size:2.5rem;opacity:0.06;color:#06b6d4;pointer-events:none;">☀️</div>>
      <div class="section-header" style="margin-bottom:24px;">
        <h2 class="section-title" style="color:#9ca3af;font-size:2rem;font-weight:800;margin-bottom:12px;" data-i18n="myBettingPortfolio">My Betting Portfolio</h2>
        <div id="portfolioSummary" style="display:flex;gap:20px;flex-wrap:wrap;margin-bottom:16px;">
          <!-- Portfolio summary will be populated by JavaScript -->
        </div>
      </div>
      <div id="betsContainer">
        <div class="empty-state">
          <h3 data-i18n="connectWalletToBets">Connect Wallet</h3>
          <p data-i18n="connectWalletToView">Connect your wallet to view your betting history.</p>
        </div>
      </div>
    </section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
  <script src="odds-engine.js" onerror="console.warn('Failed to load odds-engine.js')"></script>
  <!-- <script src="lmsr-charts.js" onerror="console.warn('Failed to load lmsr-charts.js - using fallback')"></script> -->
  <script>
    // ========================================
    // INTERNATIONALIZATION SYSTEM
    // ========================================
    
    /**
     * Translation data for BNBmarket
     * Supporting English (en) and Simplified Chinese (zh-CN)
     */
    const translations = {
      en: {
        // Navigation
        markets: "Markets",
        myBets: "My Bets",
        treasury: "Treasury",
        howItWorks: "How It Works",
        adminPanel: "Admin Panel",
        connectWallet: "Connect Wallet",
        disconnect: "Disconnect",
        
        // Market Info
        category: "Category",
        created: "Created",
        totalVolume: "Total Volume",
        totalBuys: "Total Buys",
        
        // Trading
        purchaseShares: "Purchase Shares",
        requestRefund: "Request Refund",
        amount: "Amount",
        platformFee: "Platform Fee",
        netInvestment: "Net Investment",
        shares: "Shares",
        maxReturn: "Max Return",
        expectedReturn: "Expected Return",
        currentConfidence: "Current Confidence",
        finalConfidence: "final confidence",
        priceImpact: "Price impact",
        largeTradeWarning: "Large trade",
        ifWins: "if wins",
        payoutFeeApplies: "payout fee applies",
        
        // Portfolio
        portfolioPosition: "Portfolio Position",
        myBettingPortfolio: "My Betting Portfolio",
        totalInvested: "Total Invested",
        currentValue: "Current Value",
        totalPnL: "Total P&L",
        portfolioStats: "Portfolio Stats",
        activeBets: "Active Bets",
        originalPurchase: "Original Purchase",
        marketConfidence: "Market Confidence",
        liveMarket: "Live Market",
        marketResolved: "Market Resolved",
        
        // Status Messages
        connectWalletFirst: "Please connect your wallet first",
        enterValidAmount: "Enter a valid amount",
        processingPurchase: "Processing purchase...",
        purchaseCompleted: "Purchase completed!",
        purchaseFailed: "Purchase failed",
        received: "Received",
        cancellationRequested: "Cancellation request sent. Refunds are processed within 24 hours.",
        cancellationFailed: "Cancellation failed",
        
        // My Bets Section
        connectWalletToBets: "Connect Wallet",
        connectWalletToView: "Connect your wallet to view your betting history.",
        noBetsYet: "No Bets Yet",
        noBetsDescription: "Your betting history will appear here once you place your first bet.",
        errorLoadingBets: "Error Loading Bets",
        picked: "Picked",
        viewTx: "View TX",
        
        // Chart Labels
        marketConfidenceOverTime: "Market Confidence Over Time",
        currentMarketDistribution: "Current Market Distribution",
        chartLoadingError: "Chart failed to load",
        chartTempUnavailable: "Charts temporarily unavailable",
        currentMarketDataLoading: "Current market data loading...",
        unableToCalculatePnL: "Unable to calculate current P&L",
        
        // Comments
        comments: "Comments",
        writeComment: "Write a comment...",
        postComment: "Post",
        noCommentsYet: "No comments yet. Be the first to comment!",
        warningScammers: "Do not click any links beware of scammers.",
        commentEmpty: "Comment cannot be empty.",
        posting: "Posting...",
        commentPosted: "Comment posted!",
        failedToPost: "Failed to post comment.",
        mustPlaceBet: "You must place a bet on this market to comment.",
        
        // Errors and Warnings
        invalidMarketId: "Invalid market ID.",
        failedToFetchMarket: "Failed to fetch market",
        failedToFetchBets: "Failed to fetch bets",
        metamaskNotFound: "MetaMask wallet not found! Please install MetaMask.",
        metamaskNotConnected: "MetaMask not connected. Please reconnect.",
        disconnectConfirm: "Disconnect wallet?",
        
        // Time and Dates
        today: "Today",
        yesterday: "Yesterday",
        daysAgo: "days ago",
        
        // LMSR Messages
        lmsrCalculation: "LMSR Calculation",
        currentShares: "Current shares",
        currentProbability: "Current probability",
        sharesToBuy: "Shares to buy",
        newProbability: "New probability",
        fallbackCalculation: "Using fallback calculation (no LMSR data available)",
        tradeExecution: "LMSR Trade Execution",
        purchaseAmount: "Purchase amount",
        netAmount: "Net amount",
        sharesReceived: "Shares received",
        avgExecutionPrice: "Avg execution price",
        fallbackExecution: "Using fallback execution calculation"
      },
      
      'zh-CN': {
        // Navigation
        markets: "市场",
        myBets: "我的投注",
        treasury: "资金库",
        howItWorks: "工作原理",
        adminPanel: "管理面板",
        connectWallet: "连接钱包",
        disconnect: "断开连接",
        
        // Market Info  
        category: "类别",
        created: "创建时间",
        totalVolume: "总交易量",
        totalBuys: "总购买数",
        
        // Trading
        purchaseShares: "购买份额",
        requestRefund: "申请退款",
        amount: "金额",
        platformFee: "平台费用",
        netInvestment: "净投资",
        shares: "份额",
        maxReturn: "最大回报",
        expectedReturn: "预期回报",
        currentConfidence: "当前置信度",
        finalConfidence: "最终置信度",
        priceImpact: "价格影响",
        largeTradeWarning: "大额交易",
        ifWins: "如果获胜",
        payoutFeeApplies: "支付费用适用",
        
        // Portfolio
        portfolioPosition: "投资组合仓位",
        myBettingPortfolio: "我的投注组合",
        totalInvested: "总投资",
        currentValue: "当前价值",
        totalPnL: "总盈亏",
        portfolioStats: "组合统计",
        activeBets: "活跃投注",
        originalPurchase: "原始购买",
        marketConfidence: "市场置信度",
        liveMarket: "实时市场",
        marketResolved: "市场已结算",
        
        // Status Messages
        connectWalletFirst: "请先连接您的钱包",
        enterValidAmount: "请输入有效金额",
        processingPurchase: "处理购买中...",
        purchaseCompleted: "购买完成！",
        purchaseFailed: "购买失败",
        received: "已收到",
        cancellationRequested: "取消请求已发送。退款将在24小时内处理。",
        cancellationFailed: "取消失败",
        
        // My Bets Section
        connectWalletToBets: "连接钱包",
        connectWalletToView: "连接您的钱包以查看投注历史。",
        noBetsYet: "暂无投注",
        noBetsDescription: "您的投注历史将在您下第一笔投注后显示在这里。",
        errorLoadingBets: "加载投注错误",
        picked: "已选择",
        viewTx: "查看交易",
        
        // Chart Labels
        marketConfidenceOverTime: "市场置信度随时间变化",
        currentMarketDistribution: "当前市场分布",
        chartLoadingError: "图表加载失败",
        chartTempUnavailable: "图表暂时不可用",
        currentMarketDataLoading: "当前市场数据加载中...",
        unableToCalculatePnL: "无法计算当前盈亏",
        
        // Comments
        comments: "评论",
        writeComment: "写评论...",
        postComment: "发布",
        noCommentsYet: "暂无评论。成为第一个评论的人！",
        warningScammers: "请勿点击任何链接，谨防诈骗。",
        commentEmpty: "评论不能为空。",
        posting: "发布中...",
        commentPosted: "评论已发布！",
        failedToPost: "发布评论失败。",
        mustPlaceBet: "您必须在此市场下注才能评论。",
        
        // Errors and Warnings
        invalidMarketId: "无效的市场ID。",
        failedToFetchMarket: "获取市场失败",
        failedToFetchBets: "获取投注失败",
        metamaskNotFound: "未找到MetaMask钱包！请安装MetaMask。",
        metamaskNotConnected: "MetaMask未连接。请重新连接。",
        disconnectConfirm: "断开钱包连接？",
        
        // Time and Dates
        today: "今天",
        yesterday: "昨天", 
        daysAgo: "天前",
        
        // LMSR Messages
        lmsrCalculation: "LMSR计算",
        currentShares: "当前份额",
        currentProbability: "当前概率",
        sharesToBuy: "购买份额",
        newProbability: "新概率", 
        fallbackCalculation: "使用后备计算（无LMSR数据可用）",
        tradeExecution: "LMSR交易执行",
        purchaseAmount: "购买金额",
        netAmount: "净金额",
        sharesReceived: "收到份额",
        avgExecutionPrice: "平均执行价格",
        fallbackExecution: "使用后备执行计算"
      }
    };

    /**
     * Internationalization Manager
     */
    class I18nManager {
      constructor() {
        this.translations = translations;
        this.currentLanguage = this.detectLanguage();
        console.log(`🌍 I18n initialized with language: ${this.currentLanguage}`);
      }
      
      /**
       * Auto-detect user's preferred language
       */
      detectLanguage() {
        // Check URL parameter first
        const urlParams = new URLSearchParams(window.location.search);
        const langParam = urlParams.get('lang');
        if (langParam && this.translations[langParam]) {
          return langParam;
        }
        
        // Check localStorage
        const savedLang = localStorage.getItem('bnbmarket_language');
        if (savedLang && this.translations[savedLang]) {
          return savedLang;
        }
        
        // Check browser language
        const browserLang = navigator.language || navigator.userLanguage;
        if (browserLang.startsWith('zh')) {
          return 'zh-CN';
        }
        
        return 'en'; // Default to English
      }
      
      /**
       * Get translation for a key
       */
      t(key) {
        const lang = this.translations[this.currentLanguage];
        return lang && lang[key] ? lang[key] : this.translations.en[key] || key;
      }
      
      /**
       * Switch language
       */
      switchLanguage(lang) {
        if (!this.translations[lang]) {
          console.warn(`Language ${lang} not supported`);
          return;
        }
        
        this.currentLanguage = lang;
        localStorage.setItem('bnbmarket_language', lang);
        this.updateAllTexts();
        console.log(`🌍 Language switched to: ${lang}`);
      }
      
      /**
       * Update all translatable texts in the DOM
       */
      updateAllTexts() {
        // Update navigation
        const myBetsLink = document.getElementById('myBetsNavLink');
        if (myBetsLink) myBetsLink.textContent = this.t('myBets');
        
        // Update wallet button
        const walletBtn = document.getElementById('walletBtn');
        if (walletBtn && !walletAddress) {
          walletBtn.textContent = this.t('connectWallet');
        }
        
        // Update other elements with data-i18n attribute
        document.querySelectorAll('[data-i18n]').forEach(element => {
          const key = element.getAttribute('data-i18n');
          element.textContent = this.t(key);
        });
        
        // Update placeholders
        document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
          const key = element.getAttribute('data-i18n-placeholder');
          element.placeholder = this.t(key);
        });
        
        // Refresh current page content
        if (window.currentMarket) {
          this.updateMarketTexts();
        }
      }
      
      /**
       * Update market-specific texts
       */
      updateMarketTexts() {
        // Update trade panel
        const buyBtn = document.getElementById('buyBtn');
        if (buyBtn) buyBtn.textContent = this.t('purchaseShares');
        
        const cancelBtn = document.getElementById('cancelBtn');
        if (cancelBtn) cancelBtn.textContent = this.t('requestRefund');
        
        // Update chart tabs
        const probabilityTab = document.getElementById('probabilityTab');
        if (probabilityTab) probabilityTab.textContent = this.t('marketConfidenceOverTime');
        
        const distributionTab = document.getElementById('distributionTab');
        if (distributionTab) distributionTab.textContent = this.t('currentMarketDistribution');
      }
      
      /**
       * Format number with localization
       */
      formatNumber(number, decimals = 3) {
        if (this.currentLanguage === 'zh-CN') {
          return number.toLocaleString('zh-CN', { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
        }
        return number.toLocaleString('en-US', { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
      }
      
      /**
       * Format currency
       */
      formatCurrency(amount, currency = 'BNB') {
        const formatted = this.formatNumber(amount, 3);
        return `${formatted} ${currency}`;
      }
    }

    // Initialize global i18n manager
    window.i18n = new I18nManager();

    // ========================================
    // LMSR IMPLEMENTATION (Digital Ronin's Mathematical Foundation)
    // ========================================
    
    /**
     * Professional LMSR (Logarithmic Market Scoring Rule) Implementation
     * Based on the mathematical foundation provided by Digital Ronin
     * 
     * Formula: C(q) = b * ln(Σ e^(q_j/b))
     * Price: p_i(q) = e^(q_i/b) / Σ e^(q_j/b)
     */
    class LMSREngine {
      constructor(liquidityParameter = 50) {
        this.b = liquidityParameter; // Larger b = deeper market, less price impact
        console.log(`🔮 LMSR Engine initialized with liquidity parameter b=${this.b}`);
      }
      
      /**
       * Calculate the cost function C(q) = b * ln(Σ e^(q_j/b))
       * @param {number[]} q - Array of outstanding shares for each outcome
       * @param {number} b - Liquidity parameter (optional, uses instance default)
       * @returns {number} - Cost function value
       */
      cost(q, b = this.b) {
        const exps = q.map(x => Math.exp(x / b));
        const sum = exps.reduce((acc, val) => acc + val, 0);
        return b * Math.log(sum);
      }
      
      /**
       * Calculate instantaneous prices (probabilities) for all outcomes
       * @param {number[]} q - Array of outstanding shares for each outcome
       * @param {number} b - Liquidity parameter (optional)
       * @returns {number[]} - Array of probabilities (sum = 1)
       */
      prices(q, b = this.b) {
        const exps = q.map(x => Math.exp(x / b));
        const sum = exps.reduce((acc, val) => acc + val, 0);
        return exps.map(exp => exp / sum);
      }
      
      /**
       * Calculate cost to buy a delta vector of shares
       * @param {number[]} q - Current outstanding shares
       * @param {number[]} delta - Shares to buy (same length as q)
       * @param {number} b - Liquidity parameter (optional)
       * @returns {number} - Cost in BNB
       */
      costToBuy(q, delta, b = this.b) {
        if (q.length !== delta.length) {
          throw new Error('Share arrays must have same length');
        }
        const qNext = q.map((val, i) => val + (delta[i] || 0));
        return this.cost(qNext, b) - this.cost(q, b);
      }
      
      /**
       * Calculate cost to buy shares of a specific outcome
       * @param {number[]} q - Current outstanding shares
       * @param {number} outcomeIndex - Index of outcome to buy
       * @param {number} shareAmount - Number of shares to buy
       * @param {number} b - Liquidity parameter (optional)
       * @returns {number} - Cost in BNB
       */
      costToBuyOutcome(q, outcomeIndex, shareAmount, b = this.b) {
        const delta = new Array(q.length).fill(0);
        delta[outcomeIndex] = shareAmount;
        return this.costToBuy(q, delta, b);
      }
      
      /**
       * Calculate shares you get for a given BNB amount (reverse calculation)
       * Uses binary search to find optimal share purchase
       * @param {number[]} q - Current outstanding shares
       * @param {number} outcomeIndex - Index of outcome to buy
       * @param {number} bnbAmount - BNB to spend
       * @param {number} b - Liquidity parameter (optional)
       * @returns {number} - Number of shares you can buy
       */
      sharesToBuy(q, outcomeIndex, bnbAmount, b = this.b) {
        let low = 0;
        let high = bnbAmount * 10; // Upper bound estimate
        let tolerance = 0.0001;
        
        for (let iterations = 0; iterations < 100; iterations++) {
          const mid = (low + high) / 2;
          const cost = this.costToBuyOutcome(q, outcomeIndex, mid, b);
          
          if (Math.abs(cost - bnbAmount) < tolerance) {
            return mid;
          }
          
          if (cost < bnbAmount) {
            low = mid;
          } else {
            high = mid;
          }
        }
        
        return (low + high) / 2;
      }
      
      /**
       * Check if market is in neutral 50/50 state (for binary markets)
       * or balanced state (for multi-outcome markets)
       * @param {number[]} q - Outstanding shares
       * @returns {boolean} - True if market is balanced
       */
      isBalanced(q) {
        const prices = this.prices(q);
        const expectedPrice = 1 / q.length; // Equal probability for all outcomes
        const tolerance = 0.01; // 1% tolerance
        
        return prices.every(price => Math.abs(price - expectedPrice) < tolerance);
      }
      
      /**
       * Get market status description
       * @param {number[]} q - Outstanding shares
       * @returns {object} - Market analysis
       */
      analyzeMarket(q) {
        const prices = this.prices(q);
        const maxPrice = Math.max(...prices);
        const maxIndex = prices.indexOf(maxPrice);
        const dominantOutcome = maxIndex;
        const confidence = maxPrice * 100;
        const isNeutral = this.isBalanced(q);
        
        return {
          prices: prices.map(p => Math.round(p * 100)), // Convert to percentages
          dominantOutcome,
          confidence: Math.round(confidence),
          isNeutral,
          liquidityDepth: this.b,
          totalShares: q.reduce((sum, shares) => sum + shares, 0)
        };
      }
    }

    // Initialize global LMSR engine
    window.lmsrEngine = new LMSREngine(50); // Liquidity parameter b = 50
    
    /**
     * Helper function to get LMSR probabilities for market (backward compatibility)
     * This maintains compatibility with your existing code
     */
    async function getLMSRProbabilities(marketId) {
      try {
        // Try to get data from server first
        const response = await fetch(`${API_BASE_URL}/markets/${marketId}/probabilities`);
        if (response.ok) {
          const data = await response.json();
          
          // If server provides shares data, use our LMSR engine for calculation
          if (data.shares && Array.isArray(data.shares)) {
            const analysis = window.lmsrEngine.analyzeMarket(data.shares);
            return {
              probabilities: analysis.prices,
              prices: window.lmsrEngine.prices(data.shares).map(p => p), // Price per share
              shares: data.shares,
              analysis: analysis
            };
          }
          
          return data; // Fallback to server-provided data
        }
      } catch (error) {
        console.warn('Failed to fetch LMSR probabilities from server, using simulation:', error);
      }
      
      // Fallback to enhanced simulation if server fails or no data
      if (window.currentMarket && window.currentMarket.options) {
        try {
          const simulatedData = window.yinYangSimulator.getCurrentProbabilities(marketId, window.currentMarket.options);
          return {
            probabilities: simulatedData.probabilities,
            prices: simulatedData.prices,
            volume: simulatedData.volume,
            isSimulated: true
          };
        } catch (simError) {
          console.warn('Simulation fallback failed:', simError);
        }
      }
      
      return null;
    }

    // ========================================
    // CHART ENGINE WITH LMSR INTEGRATION
    // ========================================
    // Enhanced Yin Yang Order Book System
    // ========================================
    
    class YinYangOrderBookSystem {
      constructor() {
        this.selectedOutcome = null;
        this.selectedSide = null;
        this.outcomes = [];
        this.isInitialized = false;
      }
      
      // Generate dynamic outcome ranges based on current market
      generateOutcomeRanges(market) {
        if (!market || !market.options) return [];
        
        const ranges = [];
        
        // If market has specific volume ranges, use those
        if (market.volumeRanges) {
          return market.volumeRanges;
        }
        
        // Generate ranges based on market options
        market.options.forEach((option, index) => {
          const volume = Math.random() * 500000 + 50000; // $50k - $550k
          const probability = Math.random() * 95 + 1; // 1-96%
          const change = (Math.random() - 0.5) * 40; // -20% to +20%
          const yesPrice = (probability / 100).toFixed(3);
          const noPrice = ((100 - probability) / 100).toFixed(3);
          
          ranges.push({
            range: option.name,
            volume: `$${(volume / 1000).toFixed(0)}k Vol.`,
            probability: Math.round(probability),
            change: Math.round(change),
            yesPrice: `${yesPrice}¢`,
            noPrice: `${noPrice}¢`,
            optionIndex: index,
            isYang: option.isYang || option.name.toLowerCase().includes('yes') || index === 0
          });
        });
        
        return ranges;
      }
      
      // Render the order book interface
      renderOrderBook(market) {
        if (!market) return;
        
        this.outcomes = this.generateOutcomeRanges(market);
        const container = document.getElementById('orderBookEntries');
        if (!container) return;
        
        container.innerHTML = '';
        
        this.outcomes.forEach((outcome, index) => {
          const entryDiv = document.createElement('div');
          entryDiv.className = 'order-book-entry';
          entryDiv.style.cssText = `
            background: rgba(51,65,85,0.2);
            border: 1px solid #475569;
            border-radius: 12px;
            padding: 16px;
            transition: all 0.3s ease;
            cursor: pointer;
          `;
          
          entryDiv.onmouseenter = () => {
            entryDiv.style.borderColor = '#64748b';
            entryDiv.style.background = 'rgba(51,65,85,0.4)';
          };
          
          entryDiv.onmouseleave = () => {
            entryDiv.style.borderColor = '#475569';
            entryDiv.style.background = 'rgba(51,65,85,0.2)';
          };
          
          entryDiv.innerHTML = `
            <div style="display:grid;grid-template-columns:2fr 1fr 2fr;gap:16px;align-items:center;">
              <!-- Left: Outcome Info -->
              <div>
                <div style="color:#f8fafc;font-weight:700;font-size:1.1rem;margin-bottom:4px;">${outcome.range}</div>
                <div style="color:#64748b;font-size:0.85rem;display:flex;align-items:center;gap:4px;">
                  ${outcome.volume}
                  <svg style="width:12px;height:12px;" fill="currentColor" viewBox="0 0 20 20">
                    <path d="M10 12a2 2 0 100-4 2 2 0 000 4z"/>
                    <path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd"/>
                  </svg>
                </div>
              </div>

              <!-- Middle: Probability -->
              <div style="text-align:center;">
                <div style="display:flex;align-items:center;justify-content:center;gap:8px;">
                  <span style="color:#f8fafc;font-weight:800;font-size:1.5rem;">${outcome.probability}%</span>
                  <span style="font-size:0.85rem;font-weight:700;color:${outcome.change > 0 ? '#10b981' : '#ef4444'};">
                    ${outcome.change > 0 ? '+' : ''}${outcome.change}%
                  </span>
                </div>
              </div>

              <!-- Right: Buy Buttons -->
              <div style="display:flex;gap:12px;">
                <!-- YES Button - Yang (Light) -->
                <button 
                  onclick="window.yinYangOrderBook.handleBuy(${index}, 'yes')"
                  style="flex:1;background:linear-gradient(135deg, #f1f5f9, #e2e8f0);color:#0f172a;font-weight:700;padding:12px 16px;border-radius:8px;border:2px solid #cbd5e1;transition:all 0.3s ease;box-shadow:0 2px 8px rgba(241,245,249,0.3);"
                  onmouseover="this.style.background='linear-gradient(135deg, #ffffff, #f1f5f9)';this.style.borderColor='#94a3b8';this.style.transform='translateY(-1px) scale(1.02)';"
                  onmouseout="this.style.background='linear-gradient(135deg, #f1f5f9, #e2e8f0)';this.style.borderColor='#cbd5e1';this.style.transform='none';"
                >
                  <div style="font-size:0.75rem;color:#475569;margin-bottom:2px;">陽 Buy Yes</div>
                  <div style="font-size:1.1rem;font-weight:800;">${outcome.yesPrice}</div>
                </button>

                <!-- NO Button - Yin (Dark) -->
                <button 
                  onclick="window.yinYangOrderBook.handleBuy(${index}, 'no')"
                  style="flex:1;background:linear-gradient(135deg, #1e293b, #0f172a);color:#f1f5f9;font-weight:700;padding:12px 16px;border-radius:8px;border:2px solid #475569;transition:all 0.3s ease;box-shadow:0 2px 8px rgba(30,41,59,0.5);"
                  onmouseover="this.style.background='linear-gradient(135deg, #334155, #1e293b)';this.style.borderColor='#64748b';this.style.transform='translateY(-1px) scale(1.02)';"
                  onmouseout="this.style.background='linear-gradient(135deg, #1e293b, #0f172a)';this.style.borderColor='#475569';this.style.transform='none';"
                >
                  <div style="font-size:0.75rem;color:#94a3b8;margin-bottom:2px;">陰 Buy No</div>
                  <div style="font-size:1.1rem;font-weight:800;">${outcome.noPrice}</div>
                </button>
              </div>
            </div>
          `;
          
          container.appendChild(entryDiv);
        });
        
        this.isInitialized = true;
      }
      
      // Handle buy button clicks
      handleBuy(outcomeIndex, side) {
        const outcome = this.outcomes[outcomeIndex];
        if (!outcome) return;
        
        this.selectedOutcome = outcome;
        this.selectedSide = side;
        
        // Update selection feedback
        this.updateSelectionFeedback();
        
        // Simulate the buy in our trading system
        this.executeBuy(outcome, side);
        
        console.log(`Buying ${side} for ${outcome.range} at ${side === 'yes' ? outcome.yesPrice : outcome.noPrice}`);
      }
      
      // Execute the buy and update charts
      async executeBuy(outcome, side) {
        if (!currentMarket) return;
        
        // Determine the option index
        const optionIndex = outcome.optionIndex !== undefined ? outcome.optionIndex : 0;
        
        // If side is 'no', we need to find the opposing option or create one
        let targetOptionIndex = optionIndex;
        if (side === 'no') {
          // For NO bets, either use a specific NO option or the opposing option
          const noOption = currentMarket.options.find(opt => 
            opt.name.toLowerCase().includes('no') || 
            opt.name.toLowerCase().includes('false') ||
            opt.name.toLowerCase().includes('反對')
          );
          if (noOption) {
            targetOptionIndex = currentMarket.options.indexOf(noOption);
          } else {
            // Use the next option as the opposing choice
            targetOptionIndex = (optionIndex + 1) % currentMarket.options.length;
          }
        }
        
        // Random amount between 0.1 and 2 BNB for simulation
        const amount = 0.1 + Math.random() * 1.9;
        
        try {
          // Execute the trade using our enhanced trading system
          const tradeResult = await window.enhancedTrading.executeTrade(
            currentMarket.id,
            targetOptionIndex,
            amount,
            walletAddress || 'simulation_user'
          );
          
          if (tradeResult.success) {
            // Update the outcome probability based on the trade
            const impact = Math.min(amount * 5, 15); // Limit impact to 15%
            
            if (side === 'yes') {
              outcome.probability = Math.min(95, outcome.probability + impact);
            } else {
              outcome.probability = Math.max(5, outcome.probability - impact);
            }
            
            // Update price based on new probability
            outcome.yesPrice = `${(outcome.probability / 100).toFixed(3)}¢`;
            outcome.noPrice = `${((100 - outcome.probability) / 100).toFixed(3)}¢`;
            
            // Re-render the order book with updated data
            this.renderOrderBook(currentMarket);
            
            // Force update charts
            this.refreshCharts();
            
            // Show success message
            this.showTradeMessage(`✅ Simulated ${side.toUpperCase()} trade for ${outcome.range}`, 'success');
          }
        } catch (error) {
          console.error('Order book trade error:', error);
          this.showTradeMessage(`❌ Trade failed: ${error.message}`, 'error');
        }
      }
      
      // Update selection feedback display
      updateSelectionFeedback() {
        const feedback = document.getElementById('selectionFeedback');
        const selectedRange = document.getElementById('selectedRange');
        const selectedSide = document.getElementById('selectedSide');
        const selectedPrice = document.getElementById('selectedPrice');
        
        if (feedback && this.selectedOutcome && this.selectedSide) {
          selectedRange.textContent = this.selectedOutcome.range;
          selectedSide.textContent = this.selectedSide === 'yes' ? '陽 YES' : '陰 NO';
          selectedPrice.textContent = this.selectedSide === 'yes' ? this.selectedOutcome.yesPrice : this.selectedOutcome.noPrice;
          feedback.style.display = 'block';
        }
      }
      
      // Refresh charts after trade
      refreshCharts() {
        if (currentMarket && window.lmsrChartEngine) {
          setTimeout(() => {
            // Refresh both charts
            window.lmsrChartEngine.createProbabilityChart('probabilityChartContainer', currentMarket.id);
            window.lmsrChartEngine.createCurrentDistributionChart('distributionChartContainer', currentMarket.id);
            
            // Update market info
            renderMarketInfo(currentMarket);
            updateTradePanel();
          }, 500);
        }
      }
      
      // Show trade message
      showTradeMessage(message, type) {
        const messageEl = document.getElementById('tradeMsg');
        if (messageEl) {
          messageEl.innerHTML = `<div style="color:${type === 'success' ? '#10b981' : '#ef4444'};font-weight:600;">${message}</div>`;
          setTimeout(() => {
            messageEl.innerHTML = '';
          }, 3000);
        }
      }
    }
    
    // Initialize the order book system
    window.yinYangOrderBook = new YinYangOrderBookSystem();

    // ========================================
    // Market Simulation and Enhanced Trading Logic
    // ========================================
    
    class YinYangMarketSimulator {
      constructor() {
        this.simulationData = new Map();
        this.isSimulating = false;
      }
      
      // Generate realistic market data with Yin Yang philosophy
      generateMarketSimulation(marketId, options) {
        const simulation = {
          timePoints: [],
          probabilities: [],
          volumes: [],
          trades: []
        };
        
        // Generate 24 hours of data points (every hour)
        const now = Date.now();
        const hourMs = 60 * 60 * 1000;
        
        for (let i = 23; i >= 0; i--) {
          const timestamp = now - (i * hourMs);
          simulation.timePoints.push(new Date(timestamp));
          
          // Generate probabilities that follow Yin Yang balance principles
          const optionProbs = options.map((option, index) => {
            const isYangOption = option.name.toLowerCase().includes('yes') || 
                               option.name.toLowerCase().includes('true') || 
                               option.name.toLowerCase().includes('支持') || 
                               index === 0;
            
            // Yang options tend to be more volatile (optimistic swings)
            // Yin options tend to be more stable (conservative)
            let baseProb = 100 / options.length; // Start balanced
            
            if (isYangOption) {
              // Yang: More dynamic, influenced by "positive energy"
              const yangVariation = 15 * Math.sin((i / 24) * Math.PI * 2) + 
                                   10 * Math.random() - 5;
              baseProb += yangVariation;
            } else {
              // Yin: More stable, gradual changes
              const yinVariation = 8 * Math.cos((i / 24) * Math.PI * 1.5) + 
                                  5 * Math.random() - 2.5;
              baseProb += yinVariation;
            }
            
            return Math.max(5, Math.min(95, baseProb)); // Keep within bounds
          });
          
          // Normalize probabilities to sum to 100%
          const sum = optionProbs.reduce((a, b) => a + b, 0);
          const normalizedProbs = optionProbs.map(p => (p / sum) * 100);
          
          simulation.probabilities.push(normalizedProbs);
          
          // Generate trading volume (higher volume during "market hours")
          const hourOfDay = new Date(timestamp).getHours();
          const isActiveHour = hourOfDay >= 9 && hourOfDay <= 21; // 9 AM to 9 PM
          const baseVolume = isActiveHour ? 0.5 + Math.random() * 2 : 0.1 + Math.random() * 0.3;
          simulation.volumes.push(baseVolume);
          
          // Generate individual trades
          const numTrades = Math.floor(Math.random() * 5) + 1;
          for (let t = 0; t < numTrades; t++) {
            const optionIndex = Math.floor(Math.random() * options.length);
            const amount = 0.01 + Math.random() * 0.5;
            simulation.trades.push({
              timestamp,
              optionIndex,
              amount,
              type: 'buy'
            });
          }
        }
        
        this.simulationData.set(marketId, simulation);
        return simulation;
      }
      
      // Get current simulated probabilities
      getCurrentProbabilities(marketId, options) {
        let simulation = this.simulationData.get(marketId);
        if (!simulation) {
          simulation = this.generateMarketSimulation(marketId, options);
        }
        
        const latest = simulation.probabilities[simulation.probabilities.length - 1];
        return {
          probabilities: latest,
          prices: latest.map(prob => prob / 100), // Convert to price per share
          volume: simulation.volumes[simulation.volumes.length - 1]
        };
      }
      
      // Simulate a new trade affecting market probabilities
      simulateTrade(marketId, optionIndex, amount, options) {
        let simulation = this.simulationData.get(marketId);
        if (!simulation) {
          simulation = this.generateMarketSimulation(marketId, options);
        }
        
        // Add trade to simulation
        simulation.trades.push({
          timestamp: Date.now(),
          optionIndex,
          amount,
          type: 'buy'
        });
        
        // Update probabilities based on trade (LMSR-like logic)
        const currentProbs = simulation.probabilities[simulation.probabilities.length - 1];
        const newProbs = [...currentProbs];
        
        // Increase probability of bought option, decrease others
        const impact = Math.min(amount * 10, 20); // Limit impact
        newProbs[optionIndex] += impact;
        
        // Redistribute from other options
        const reduction = impact / (options.length - 1);
        for (let i = 0; i < newProbs.length; i++) {
          if (i !== optionIndex) {
            newProbs[i] = Math.max(5, newProbs[i] - reduction);
          }
        }
        
        // Normalize
        const sum = newProbs.reduce((a, b) => a + b, 0);
        const normalizedProbs = newProbs.map(p => (p / sum) * 100);
        
        // Add new data point
        simulation.timePoints.push(new Date());
        simulation.probabilities.push(normalizedProbs);
        simulation.volumes.push(simulation.volumes[simulation.volumes.length - 1] + amount);
        
        return this.getCurrentProbabilities(marketId, options);
      }
    }
    
    // Initialize market simulator
    window.yinYangSimulator = new YinYangMarketSimulator();
    
    // ========================================
    // Enhanced Trading Logic with Multiple Options
    // ========================================
    
    class EnhancedTradingEngine {
      constructor() {
        this.marketOptions = new Map();
        this.userPositions = new Map();
      }
      
      // Create a market with up to 6 options following Yin Yang principles
      createMarket(marketData) {
        const options = marketData.options || [];
        
        // Ensure we have at least 2 options, max 6
        while (options.length < 2) {
          const count = options.length;
          options.push({
            name: count === 0 ? 'YES ☀️' : 'NO 🌙',
            image: null,
            isYang: count === 0
          });
        }
        
        // Limit to 6 options maximum for UI clarity
        if (options.length > 6) {
          options.splice(6);
        }
        
        // Auto-detect and tag Yin/Yang nature
        options.forEach((option, index) => {
          if (!option.hasOwnProperty('isYang')) {
            const isYangOption = option.name.toLowerCase().includes('yes') || 
                               option.name.toLowerCase().includes('true') || 
                               option.name.toLowerCase().includes('支持') || 
                               option.name.toLowerCase().includes('positive') ||
                               index === 0;
            option.isYang = isYangOption;
          }
        });
        
        this.marketOptions.set(marketData.id, options);
        return options;
      }
      
      // Calculate trading price with Yin Yang bonuses
      calculateTradePrice(marketId, optionIndex, amount, options) {
        const probabilities = window.yinYangSimulator.getCurrentProbabilities(marketId, options);
        const basePrice = probabilities.prices[optionIndex];
        
        // Apply Yin Yang philosophy bonuses
        const option = options[optionIndex];
        let bonus = 1.0;
        
        if (option.isYang) {
          // Yang options get slight discount for optimistic traders
          bonus = 0.98;
        } else {
          // Yin options get slight premium for contrarian traders
          bonus = 1.02;
        }
        
        // Volume impact
        const volumeImpact = Math.min(amount * 0.01, 0.05); // Max 5% impact
        const finalPrice = basePrice * bonus * (1 + volumeImpact);
        
        return {
          pricePerShare: finalPrice,
          totalCost: amount,
          sharesReceived: amount / finalPrice,
          platformFee: amount * 0.01, // 1% fee
          netAmount: amount * 0.99
        };
      }
      
      // Execute trade with enhanced logic
      async executeTrade(marketId, optionIndex, amount, userAddress) {
        const options = this.marketOptions.get(marketId) || currentMarket.options;
        const tradeDetails = this.calculateTradePrice(marketId, optionIndex, amount, options);
        
        // Update user positions
        const userKey = `${userAddress}-${marketId}`;
        if (!this.userPositions.has(userKey)) {
          this.userPositions.set(userKey, {});
        }
        
        const positions = this.userPositions.get(userKey);
        if (!positions[optionIndex]) {
          positions[optionIndex] = { shares: 0, invested: 0 };
        }
        
        positions[optionIndex].shares += tradeDetails.sharesReceived;
        positions[optionIndex].invested += tradeDetails.netAmount;
        
        // Update market simulation
        window.yinYangSimulator.simulateTrade(marketId, optionIndex, amount, options);
        
        return {
          success: true,
          tradeDetails,
          newPosition: positions[optionIndex],
          message: `Successfully purchased ${tradeDetails.sharesReceived.toFixed(3)} shares of ${options[optionIndex].name}`
        };
      }
      
      // Get user's portfolio for a market
      getUserPortfolio(marketId, userAddress) {
        const userKey = `${userAddress}-${marketId}`;
        return this.userPositions.get(userKey) || {};
      }
    }
    
    // Initialize trading engine
    window.enhancedTrading = new EnhancedTradingEngine();

    // ========================================
    // Define LMSRChartEngine fallback BEFORE any other code
    class LMSRChartEngineFallback {
      constructor() {
        console.log('Using fallback LMSRChartEngine - basic charts enabled');
        this.chartInstances = {}; // Track chart instances
      }
      
      destroyChart(chartId) {
        if (this.chartInstances[chartId]) {
          this.chartInstances[chartId].destroy();
          delete this.chartInstances[chartId];
        }
      }
      
      async createProbabilityChart(containerId, marketId) {
        console.log('Creating enhanced Yin Yang probability chart for market', marketId);
        const container = document.getElementById(containerId) || document.querySelector(`#${containerId}`);
        if (!container) return null;

        try {
          // Destroy existing chart if it exists
          this.destroyChart('probabilityChart');
          
          // Get market data and generate simulation
          const market = window.currentMarket;
          if (!market || !market.options) {
            throw new Error('No market data available');
          }
          
          // Initialize enhanced trading and get simulation data
          window.enhancedTrading.createMarket(market);
          const simulation = window.yinYangSimulator.generateMarketSimulation(marketId, market.options);

          // Create fresh canvas
          container.innerHTML = '';
          const canvas = document.createElement('canvas');
          canvas.id = 'probabilityChart';
          canvas.width = container.offsetWidth || 400;
          canvas.height = container.offsetHeight || 300;
          container.appendChild(canvas);

          if (typeof Chart !== 'undefined') {
            const ctx = canvas.getContext('2d');
            
            // Prepare time series data
            const timeLabels = simulation.timePoints.map(time => 
              time.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })
            );
            
            const chartInstance = new Chart(ctx, {
              type: 'line',
              data: {
                labels: timeLabels,
                datasets: market.options.map((option, index) => {
                  // Extract probability data for this option over time
                  const probData = simulation.probabilities.map(probArray => probArray[index]);
                  
                  // Determine Yin Yang colors
                  const isYangOption = option.name.toLowerCase().includes('yes') || 
                                     option.name.toLowerCase().includes('true') || 
                                     option.name.toLowerCase().includes('支持') || 
                                     index === 0;
                  const isYinOption = option.name.toLowerCase().includes('no') || 
                                    option.name.toLowerCase().includes('false') || 
                                    option.name.toLowerCase().includes('反對') || 
                                    index === 1;
                  
                  let borderColor, backgroundColor;
                  if (isYangOption) {
                    borderColor = '#06b6d4';
                    backgroundColor = 'rgba(6, 182, 212, 0.15)';
                  } else if (isYinOption) {
                    borderColor = '#9ca3af';
                    backgroundColor = 'rgba(156, 163, 175, 0.15)';
                  } else {
                    const yinYangColors = [
                      { border: '#0891b2', bg: 'rgba(8, 145, 178, 0.15)' },
                      { border: '#6b7280', bg: 'rgba(107, 114, 128, 0.15)' },
                      { border: '#0284c7', bg: 'rgba(2, 132, 199, 0.15)' },
                      { border: '#4b5563', bg: 'rgba(75, 85, 99, 0.15)' }
                    ];
                    const colorSet = yinYangColors[index % yinYangColors.length];
                    borderColor = colorSet.border;
                    backgroundColor = colorSet.bg;
                  }
                  
                  return {
                    label: `${isYangOption ? '☀️' : (isYinOption ? '🌙' : '⚡')} ${option.name}`,
                    data: probData,
                    borderColor: borderColor,
                    backgroundColor: backgroundColor,
                    tension: 0.3,
                    borderWidth: 3,
                    pointBackgroundColor: borderColor,
                    pointBorderColor: '#ffffff',
                    pointBorderWidth: 2,
                    pointRadius: 4,
                    pointHoverRadius: 8,
                    fill: true
                  };
                })
              },
              options: {
                responsive: true,
                plugins: {
                  legend: { 
                    labels: { 
                      color: '#ffffff',
                      font: { size: 14, weight: 'bold' },
                      padding: 15,
                      usePointStyle: true
                    } 
                  },
                  title: { 
                    display: true, 
                    text: '☯ Market Confidence Over Time', 
                    color: '#ffffff',
                    font: { size: 16, weight: 'bold' }
                  },
                  tooltip: {
                    callbacks: {
                      label: function(context) {
                        const label = context.dataset.label || '';
                        const value = context.parsed.y || 0;
                        return `${label}: ${value.toFixed(1)}% confidence`;
                      }
                    },
                    backgroundColor: 'rgba(15, 23, 42, 0.9)',
                    titleColor: '#06b6d4',
                    bodyColor: '#e2e8f0',
                    borderColor: '#334155',
                    borderWidth: 1
                  }
                },
                scales: {
                  y: { 
                    beginAtZero: true, 
                    max: 100,
                    ticks: { 
                      color: '#9ca3af',
                      callback: function(value) {
                        return value + '%';
                      }
                    },
                    title: { 
                      display: true, 
                      text: 'Market Confidence (%)', 
                      color: '#9ca3af',
                      font: { weight: 'bold' }
                    },
                    grid: {
                      color: 'rgba(156, 163, 175, 0.1)'
                    }
                  },
                  x: { 
                    ticks: { color: '#9ca3af' },
                    grid: {
                      color: 'rgba(156, 163, 175, 0.1)'
                    }
                  }
                },
                animation: {
                  duration: 1500,
                  easing: 'easeOutQuart'
                },
                interaction: {
                  intersect: false,
                  mode: 'index'
                }
              }
            });
            
            // Store chart instance for later cleanup
            this.chartInstances['probabilityChart'] = chartInstance;
          } else {
            container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#9ca3af;font-size:14px;">Chart.js not available</div>';
          }
        } catch (error) {
          console.error('Chart creation failed:', error);
          container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#ff6b6b;font-size:14px;">⚠️ Chart failed to load</div>';
        }
        return null;
      }
      
      async createCurrentDistributionChart(containerId, marketId) {
        console.log('Creating enhanced Yin Yang distribution chart for market', marketId);
        const container = document.getElementById(containerId) || document.querySelector(`#${containerId}`);
        if (!container) return null;

        try {
          // Destroy existing chart if it exists
          this.destroyChart('distributionChart');
          
          // Get current market data and simulation
          const market = window.currentMarket;
          if (!market || !market.options) {
            throw new Error('No market data available');
          }
          
          // Get current probabilities from simulation
          const currentData = window.yinYangSimulator.getCurrentProbabilities(marketId, market.options);

          // Create fresh canvas
          container.innerHTML = '';
          const canvas = document.createElement('canvas');
          canvas.id = 'distributionChart';
          canvas.width = container.offsetWidth || 400;
          canvas.height = container.offsetHeight || 300;
          container.appendChild(canvas);

          if (typeof Chart !== 'undefined') {
            const ctx = canvas.getContext('2d');
            
            const chartInstance = new Chart(ctx, {
              type: 'doughnut',
              data: {
                labels: market.options.map((option, index) => {
                  // Add Yin Yang symbols to labels
                  const isYangOption = option.name.toLowerCase().includes('yes') || 
                                     option.name.toLowerCase().includes('true') || 
                                     option.name.toLowerCase().includes('支持') || 
                                     index === 0;
                  const isYinOption = option.name.toLowerCase().includes('no') || 
                                    option.name.toLowerCase().includes('false') || 
                                    option.name.toLowerCase().includes('反對') || 
                                    index === 1;
                  
                  const symbol = isYangOption ? '☀️' : (isYinOption ? '🌙' : '⚡');
                  return `${symbol} ${option.name}`;
                }),
                datasets: [{
                  data: currentData.probabilities,
                  backgroundColor: currentData.probabilities.map((prob, index) => {
                    const option = market.options[index];
                    
                    // Determine Yin Yang colors based on option type
                    const isYangOption = option.name.toLowerCase().includes('yes') || 
                                       option.name.toLowerCase().includes('true') || 
                                       option.name.toLowerCase().includes('支持') || 
                                       index === 0;
                    const isYinOption = option.name.toLowerCase().includes('no') || 
                                      option.name.toLowerCase().includes('false') || 
                                      option.name.toLowerCase().includes('反對') || 
                                      index === 1;
                    
                    if (isYangOption) {
                      return '#06b6d4'; // Yang - Bright cyan
                    } else if (isYinOption) {
                      return '#9ca3af'; // Yin - Gray
                    } else {
                      // Alternate Yin Yang colors for additional options
                      const yinYangPalette = [
                        '#0891b2', // Light Yang
                        '#6b7280', // Deep Yin
                        '#0284c7', // Bright Yang
                        '#4b5563'  // Dark Yin
                      ];
                      return yinYangPalette[index % yinYangPalette.length];
                    }
                  }),
                  borderColor: '#1e293b',
                  borderWidth: 3,
                  hoverBorderColor: '#ffffff',
                  hoverBorderWidth: 4
                }]
              },
              options: {
                responsive: true,
                plugins: {
                  legend: { 
                    labels: { 
                      color: '#ffffff',
                      font: { size: 14, weight: 'bold' },
                      padding: 20,
                      usePointStyle: true,
                      pointStyle: 'circle'
                    },
                    position: 'bottom'
                  },
                  title: { 
                    display: true, 
                    text: '☯ Current Market Distribution', 
                    color: '#ffffff',
                    font: { size: 16, weight: 'bold' },
                    padding: { bottom: 20 }
                  },
                  tooltip: {
                    callbacks: {
                      label: function(context) {
                        const label = context.label || '';
                        const value = context.parsed || 0;
                        return `${label}: ${value.toFixed(1)}% confidence`;
                      }
                    },
                    backgroundColor: 'rgba(15, 23, 42, 0.9)',
                    titleColor: '#06b6d4',
                    bodyColor: '#e2e8f0',
                    borderColor: '#334155',
                    borderWidth: 1
                  }
                },
                animation: {
                  animateRotate: true,
                  animateScale: true,
                  duration: 1500,
                  easing: 'easeOutQuart'
                },
                elements: {
                  arc: {
                    borderJoinStyle: 'round'
                  }
                }
              }
            });
            
            // Store chart instance for later cleanup
            this.chartInstances['distributionChart'] = chartInstance;
          } else {
            container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#9ca3af;font-size:14px;">Chart.js not available</div>';
          }
        } catch (error) {
          console.error('Chart creation failed:', error);
          container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#ff6b6b;font-size:14px;">⚠️ Chart failed to load</div>';
        }
        return null;
      }
    }

    // Check if the real LMSRChartEngine loaded, if not use fallback
    if (typeof LMSRChartEngine === 'undefined') {
      console.warn('LMSRChartEngine not available, using fallback');
      window.LMSRChartEngine = LMSRChartEngineFallback;
    }

    // Initialize chart engine ALWAYS
    window.lmsrChartEngine = new (window.LMSRChartEngine || LMSRChartEngineFallback)();

    // Initialize Web3 and BSC connection
    let wallet = null;
    let bnbBalance = 0;
    let isAdmin = false;
    
    // BSC Configuration
    const TREASURY_WALLET = '0x7eCa382995Df91C250896c0EC73c9d2893F7800e';
    const BSC_MAINNET_CONFIG = {
      chainId: '0x38',
      chainName: 'Binance Smart Chain',
      nativeCurrency: { name: 'BNB', symbol: 'BNB', decimals: 18 },
      rpcUrls: ['https://bsc-dataseed1.binance.org/'],
      blockExplorerUrls: ['https://bscscan.com/'],
    };
  </script>
  
  <div id="loadingScreen" style="position:fixed;inset:0;background:linear-gradient(135deg, #111827 0%, #374151 50%, #111827 100%);display:flex;align-items:center;justify-content:center;z-index:9999;">
    <div style="text-align:center;color:#9ca3af;">
      <div style="width:50px;height:50px;border:4px solid rgba(156,163,175,0.3);border-top-color:#9ca3af;border-radius:50%;animation:spin 1s linear infinite;margin:0 auto 16px;"></div>
      <div style="font-size:18px;font-weight:700;">Loading 陰陽市場...</div>
    </div>
  </div>
  <style>@keyframes spin{0%{transform:rotate(0deg);}100%{transform:rotate(360deg);}}</style>
  <script>
    window.addEventListener('DOMContentLoaded', () => {
      setTimeout(() => {
        document.getElementById('loadingScreen').style.display = 'none';
      }, 1000);
    });
  </script>
  
  <script>
    // API BASE URL LOGIC
    const API_BASE_URL = (function() {
      const { hostname } = window.location;
      if (hostname === 'localhost' || hostname === '127.0.0.1') {
        return 'http://localhost:3001/api';
      }
      if (hostname.endsWith('onrender.com')) {
        return `https://${hostname}/api`;
      }
      if (hostname === 'www.bnbmarket.cc') {
        return 'https://www.bnbmarket.cc/api';
      }
      if (hostname === 'bnbmarket.cc') {
        return 'https://bnbmarket.cc/api';
      }
      return window.location.origin + '/api';
    })();

    // Helper function to get odds from metadata.admin_odds ONLY
    // Helper function to get LMSR probabilities for market
    async function getLMSRProbabilities(marketId) {
      try {
        const response = await fetch(`${API_BASE_URL}/markets/${marketId}/probabilities`);
        if (response.ok) {
          return await response.json();
        }
      } catch (error) {
        console.warn('Failed to fetch LMSR probabilities:', error);
      }
      return null;
    }

    // Helper function to calculate implied odds from probability
    function probabilityToOdds(probability) {
      if (!probability || probability <= 0) return null;
      return 1 / probability;
    }

    // Helper function to get LMSR price per share for an option
    async function getLMSRPrice(market, optionIndex) {
      const probData = await getLMSRProbabilities(market.id);
      if (!probData || !probData.prices || !probData.prices[optionIndex]) {
        console.warn(`LMSR prices not available for option ${optionIndex}`);
        return 0.5; // Default fallback price
      }
      
      return probData.prices[optionIndex];
    }

    // Globals
    let walletAddress = null;
    let web3 = null; // Move web3 declaration here
    window.bnbBalance = 0;
    let currentOrderBook = null;
    let currentMarket = null;
    let selectedOutcome = 0;
    window.currentOrderBook = currentOrderBook;
    window.currentMarket = currentMarket;
    window.selectedOutcome = selectedOutcome;

    // Web3 initialization
    async function initializeWeb3() {
      try {
        if (!window.ethereum) {
          console.log('MetaMask not detected');
          return false;
        }
        
        web3 = new Web3(window.ethereum);
        
        // Check if wallet was previously connected
        const accounts = await window.ethereum.request({ method: 'eth_accounts' });
        if (accounts.length > 0) {
          walletAddress = accounts[0];
          // Check if this wallet is admin
          const adminWallet = '0x7eCa382995Df91C250896c0EC73c9d2893F7800e';
          isAdmin = walletAddress.toLowerCase() === adminWallet.toLowerCase();
          await updateBalance();
        }
        
        console.log('Successfully initialized Web3 connection');
        return true;
      } catch (error) {
        console.error('Failed to initialize Web3:', error);
        return false;
      }
    }

    // Wallet functions
    async function updateBalance() {
      if (!walletAddress || !web3) {
        document.getElementById('balanceDisplay').style.display = 'none';
        return;
      }
      try {
        const balance = await web3.eth.getBalance(walletAddress);
        window.bnbBalance = parseFloat(web3.utils.fromWei(balance, 'ether'));
        document.getElementById('bnbBalance').textContent = window.bnbBalance.toFixed(3);
        document.getElementById('balanceDisplay').style.display = '';
      } catch (e) {
        console.error('Balance update failed:', e);
        document.getElementById('balanceDisplay').style.display = 'none';
      }
    }

    function setWalletBtnConnected(addr) {
      const btn = document.getElementById('walletBtn');
      btn.textContent = addr.slice(0, 4) + '...' + addr.slice(-4);
      btn.classList.add('connected');
    }
    
    function setWalletBtnDisconnected() {
      const btn = document.getElementById('walletBtn');
      btn.textContent = window.i18n.t('connectWallet');
      btn.classList.remove('connected');
    }

    async function connectWallet() {
      if (!window.ethereum) {
        alert(window.i18n.t('metamaskNotFound'));
        window.open('https://metamask.io/', '_blank');
        return;
      }
      try {
        // Request account access
        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
        
        if (accounts.length === 0) {
          alert('No accounts found');
          return;
        }

        walletAddress = accounts[0];
        
        // Switch to BSC network if needed
        try {
          await window.ethereum.request({
            method: 'wallet_switchEthereumChain',
            params: [{ chainId: '0x38' }], // BSC Mainnet
          });
        } catch (switchError) {
          if (switchError.code === 4902) {
            try {
              await window.ethereum.request({
                method: 'wallet_addEthereumChain',
                params: [BSC_MAINNET_CONFIG],
              });
            } catch (addError) {
              console.error('Failed to add BSC network:', addError);
            }
          }
        }
        
        setWalletBtnConnected(walletAddress);
        await updateBalance();
        updateAdminTabVisibility();
      } catch (e) {
        console.error('Wallet connection failed:', e);
        setWalletBtnDisconnected();
      }
    }

    function disconnectWallet() {
      walletAddress = null;
      setWalletBtnDisconnected();
      document.getElementById('balanceDisplay').style.display = 'none';
    }

    function updateAdminTabVisibility() {
      const adminTab = document.getElementById('adminTab');
      const ADMIN_WALLET = '0x7eCa382995Df91C250896c0EC73c9d2893F7800e';
      if (walletAddress && walletAddress.toLowerCase() === ADMIN_WALLET.toLowerCase()) {
        if (adminTab) adminTab.style.display = '';
      } else {
        if (adminTab) adminTab.style.display = 'none';
      }
    }

    // Utility
    function getMarketId() {
      // First try URL parameters (?id=123)
      const params = new URLSearchParams(window.location.search);
      const paramId = params.get('id');
      if (paramId) {
        return parseInt(paramId);
      }
      
      // Then try SEO-friendly URL path (/market/title-123 or /title-123)
      const path = window.location.pathname;
      let slug = '';
      
      if (path.startsWith('/market/')) {
        slug = path.replace('/market/', '');
      } else if (path !== '/' && path !== '/market.html') {
        slug = path.replace('/', '');
      }
      
      if (slug) {
        // Extract ID from slug (last number after hyphen)
        const matches = slug.match(/-(\d+)$/);
        if (matches) {
          return parseInt(matches[1]);
        }
      }
      
      return null;
    }

    // UI Rendering
    async function renderMarketInfo(market) {
      document.getElementById('marketTitle').textContent = market.title;
      document.getElementById('marketMeta').textContent = `Category: ${market.category} | Created: ${new Date(market.created_at).toLocaleString()}`;
      
      let totalVolume = 0;
      try {
        const res = await fetch(`${API_BASE_URL}/bets?marketId=${market.id}`);
        if (res.ok) {
          const data = await res.json();
          if (Array.isArray(data.bets)) {
            totalVolume = data.bets.reduce((sum, b) => sum + (parseFloat(b.amount) || 0), 0);
          }
        }
      } catch (e) {
        if (window.currentOrderBook && Array.isArray(window.currentOrderBook)) {
          totalVolume = window.currentOrderBook.reduce((sum, b) => sum + (parseFloat(b.amount) || 0), 0);
        }
      }
      
      document.getElementById('marketVolume').innerHTML = `Total Volume: <span style='color:#06b6d4;'>${totalVolume.toFixed(3)} BNB</span>`;
      
      const optionsDiv = document.getElementById('marketOptions');
      optionsDiv.innerHTML = '';
      
      // Get LMSR probabilities for the market
      const probData = await getLMSRProbabilities(market.id);
      
      (market.options || []).forEach(async (opt, i) => {
        const el = document.createElement('div');
        
        // Apply Yin Yang styling based on option type
        const isYangOption = opt.name && (opt.name.toLowerCase().includes('yes') || opt.name.toLowerCase().includes('true') || opt.name.toLowerCase().includes('支持') || i === 0);
        const isYinOption = opt.name && (opt.name.toLowerCase().includes('no') || opt.name.toLowerCase().includes('false') || opt.name.toLowerCase().includes('反對') || i === 1);
        
        let yinYangClass = '';
        if (isYangOption) {
          yinYangClass = ' yang';
        } else if (isYinOption) {
          yinYangClass = ' yin';
        } else {
          // Alternate for other options
          yinYangClass = i % 2 === 0 ? ' yang' : ' yin';
        }
        
        el.className = 'option-tab' + (i===selectedOutcome?' active':'') + yinYangClass;
        
        // Enhanced styling with better contrast and visual hierarchy
        const baseStyle = 'padding:12px 14px 8px 14px;border-radius:12px;min-width:90px;text-align:center;cursor:pointer;transition:all 0.3s ease;display:flex;flex-direction:column;align-items:center;justify-content:center;position:relative;overflow:hidden;';
        
        // Add subtle Yin Yang symbols as background elements
        const symbolStyle = isYangOption ? 
          'background-image: radial-gradient(circle at 20% 80%, rgba(6,182,212,0.08) 20%, transparent 20%);' :
          'background-image: radial-gradient(circle at 80% 20%, rgba(156,163,175,0.12) 20%, transparent 20%);';
        
        el.style = baseStyle + symbolStyle;
        
        let oddsDisplay = '';
        let probabilityDisplay = '';
        
        if (probData && probData.probabilities && probData.probabilities[i] !== undefined) {
          const probability = probData.probabilities[i];
          const textColor = isYangOption ? '#475569' : '#9ca3af';
          probabilityDisplay = `<div style='color:${textColor};font-size:0.9em;font-weight:600;margin-top:3px;'>${probability}% confidence</div>`;
          // Show price per share instead of odds
          if (probData.prices && probData.prices[i]) {
            const pricePerShare = probData.prices[i];
            oddsDisplay = `<div style='color:${textColor};font-size:0.85em;font-weight:500;'>${pricePerShare.toFixed(3)} BNB/share</div>`;
          }
        } else {
          const textColor = isYangOption ? '#64748b' : '#9ca3af';
          probabilityDisplay = `<div style='color:${textColor};font-size:0.85em;font-weight:600;margin-top:3px;'>Loading...</div>`;
        }
        
        // Add philosophical symbols for YES/NO
        const symbol = isYangOption ? '☀️' : (isYinOption ? '🌙' : '');
        const symbolDisplay = symbol ? `<span style='font-size:1.2em;margin-bottom:4px;'>${symbol}</span>` : '';
        
        const nameColor = isYangOption ? '#0f172a' : '#e2e8f0';
        
        el.innerHTML = `
          ${opt.image ? `<img src='${opt.image}' alt='' style='width:40px;height:40px;border-radius:50%;margin-bottom:6px;border:2px solid ${isYangOption ? '#cbd5e1' : '#475569'};'>` : ''}
          ${symbolDisplay}
          <div style="font-size:1.08rem;font-weight:700;color:${nameColor};margin-bottom:2px;">${opt.name || 'Option ' + (i+1)}</div>
          ${probabilityDisplay}
          ${oddsDisplay}
        `;
        
        el.onclick = ()=>{
          selectedOutcome = i;
          renderMarketInfo(market);
          renderChart(market, currentOrderBook);
          renderOrderBookPro(currentOrderBook, market, selectedOutcome);
          updateTradePanel();
          calculateProfit();
        };
        optionsDiv.appendChild(el);
      });
      
      if (currentOrderBook && market.options) {
        let html = '<span style="color:#9ca3af;">Total Buys:</span> ';
        const totals = Array(market.options.length).fill(0);
        currentOrderBook.forEach(b=>{ if(b.option_id!==undefined) totals[b.option_id]+=1; });
        html += market.options.map((opt,i)=>`${opt.name}: <span style='color:#9ca3af;'>${totals[i]}</span>`).join(' &nbsp; ');
        document.getElementById('totalBuys').innerHTML = html;
      }
      
      // Render the enhanced order book
      if (window.yinYangOrderBook) {
        window.yinYangOrderBook.renderOrderBook(market);
      }
    }

    function renderOrderBookPro(orderBook, market, selectedOutcome) {
      const obDiv = document.getElementById('orderBook');
      
      if (!orderBook || orderBook.length === 0) {
        obDiv.innerHTML = '<div style="color:#9ca3af;">No bets yet.</div>';
        return;
      }
      
      const filtered = orderBook.filter(b => b.option_id === selectedOutcome);
      const bids = filtered;
      bids.sort((a,b) => parseFloat(b.amount) - parseFloat(a.amount));
      const maxShares = Math.max(...bids.map(x => parseFloat(x.amount)), 1);
      
      let tabs = '';
      (market.options||[]).forEach((opt,i)=>{
        // Apply Yin Yang styling to order book tabs
        const isYangOption = opt.name && (opt.name.toLowerCase().includes('yes') || opt.name.toLowerCase().includes('true') || opt.name.toLowerCase().includes('支持') || i === 0);
        const isYinOption = opt.name && (opt.name.toLowerCase().includes('no') || opt.name.toLowerCase().includes('false') || opt.name.toLowerCase().includes('反對') || i === 1);
        
        let activeColors, inactiveColors;
        if (isYangOption) {
          activeColors = 'background:linear-gradient(135deg, #f8fafc, #e2e8f0);color:#0f172a;border:2px solid #06b6d4;box-shadow:0 0 0 2px rgba(6,182,212,0.1);';
          inactiveColors = 'background:linear-gradient(135deg, #e2e8f0, #cbd5e1);color:#334155;border:2px solid #94a3b8;';
        } else if (isYinOption) {
          activeColors = 'background:linear-gradient(135deg, #0f172a, #1e293b);color:#f8fafc;border:2px solid #9ca3af;box-shadow:0 0 0 2px rgba(156,163,175,0.1);';
          inactiveColors = 'background:linear-gradient(135deg, #1e293b, #334155);color:#e2e8f0;border:2px solid #475569;';
        } else {
          // Alternate for other options
          if (i % 2 === 0) {
            activeColors = 'background:linear-gradient(135deg, #f8fafc, #e2e8f0);color:#0f172a;border:2px solid #06b6d4;box-shadow:0 0 0 2px rgba(6,182,212,0.1);';
            inactiveColors = 'background:linear-gradient(135deg, #e2e8f0, #cbd5e1);color:#334155;border:2px solid #94a3b8;';
          } else {
            activeColors = 'background:linear-gradient(135deg, #0f172a, #1e293b);color:#f8fafc;border:2px solid #9ca3af;box-shadow:0 0 0 2px rgba(156,163,175,0.1);';
            inactiveColors = 'background:linear-gradient(135deg, #1e293b, #334155);color:#e2e8f0;border:2px solid #475569;';
          }
        }
        
        const colors = i===selectedOutcome ? activeColors : inactiveColors;
        tabs += `<button class="ob-tab${i===selectedOutcome?' active':''}" data-idx="${i}" style="${colors}padding:8px 16px;border-radius:8px;font-weight:600;cursor:pointer;transition:all 0.3s ease;margin-right:6px;">${opt.name}</button>`;
      });
      
      async function rowHtml(order) {
        const barW = Math.max(8, 180*(parseFloat(order.amount)/maxShares));
        
        // Get current LMSR probabilities for potential return calculation
        const probData = await getLMSRProbabilities(market.id);
        let sharesOwned = 0;
        let potentialReturn = 0;
        
        if (probData && probData.prices && probData.prices[selectedOutcome]) {
          // Calculate shares owned: amount / price per share at time of purchase
          const executionPrice = order.execution_odds || probData.prices[selectedOutcome];
          sharesOwned = parseFloat(order.amount) / executionPrice;
          
          // Potential return is shares * probability of winning (max 1 BNB per share if wins)
          const winProbability = probData.probabilities[selectedOutcome] / 100;
          potentialReturn = sharesOwned * winProbability;
        } else {
          // Fallback calculation
          potentialReturn = parseFloat(order.amount) * 1.5;
        }
        
        let buyerCell = '-';
        if (order.transaction_signature) {
          const shortTx = order.transaction_signature.slice(0,4) + '...' + order.transaction_signature.slice(-4);
          buyerCell = `<a href="https://bscscan.com/tx/${order.transaction_signature}" target="_blank" rel="noopener" style="color:#06b6d4;font-weight:700;text-decoration:none;">${shortTx}</a>`;
        }
        return `<tr style="background:rgba(16,185,129,0.08);">
          <td style="position:relative;">
            <div style="position:absolute;left:0;top:0;height:100%;width:${barW}px;background:rgba(16,185,129,0.13);"></div>
            <span style="position:relative;z-index:2;font-weight:600;color:#06b6d4;">${parseFloat(order.amount).toFixed(3)}</span>
          </td>
          <td style="position:relative;z-index:2;">${buyerCell}</td>
          <td style="position:relative;z-index:2;color:#f3f4f6;">${sharesOwned.toFixed(1)} shares (${potentialReturn.toFixed(3)} BNB)</td>
        </tr>`;
      }
      
      let html = `<div style="display:flex;align-items:center;gap:18px;margin-bottom:12px;flex-wrap:wrap;">
        <h3 style="color:#9ca3af;margin:0;font-size:1.3rem;">Order Book</h3>
        <div>${tabs}</div>
      </div>`;
      html += `<table style="width:100%;border-radius:10px;overflow:hidden;font-size:1rem;">
        <thead><tr style="background:#374151;color:#9ca3af;font-weight:700;"><th style="padding:8px;">Amount (BNB)</th><th>Buyer</th><th>Shares & Potential Return</th></tr></thead>
        <tbody id="orderBookRows">`;
      
      html += '</tbody></table>';
      obDiv.innerHTML = html;
      
      // Render rows asynchronously
      const rowsContainer = document.getElementById('orderBookRows');
      Promise.all(bids.map(order => rowHtml(order))).then(rows => {
        rowsContainer.innerHTML = rows.join('');
      });
      
      obDiv.querySelectorAll('.ob-tab').forEach(btn=>{
        btn.onclick = ()=>{
          selectedOutcome = parseInt(btn.dataset.idx);
          renderOrderBookPro(orderBook,market,selectedOutcome);
        };
      });
    }

    async function updateTradePanel() {
      if (!currentMarket || !currentMarket.options) return;
      const opt = currentMarket.options[selectedOutcome];
      
      // Determine if this is a Yang (YES/positive) or Yin (NO/negative) option
      const isYangOption = opt.name && (opt.name.toLowerCase().includes('yes') || opt.name.toLowerCase().includes('true') || opt.name.toLowerCase().includes('支持') || selectedOutcome === 0);
      const isYinOption = opt.name && (opt.name.toLowerCase().includes('no') || opt.name.toLowerCase().includes('false') || opt.name.toLowerCase().includes('反對') || selectedOutcome === 1);
      
      // Get LMSR probabilities
      const probData = await getLMSRProbabilities(currentMarket.id);
      let probabilityText = 'Loading market sentiment...';
      let pricePerShare = 0.5; // Default fallback price
      
      if (probData && probData.prices && probData.prices[selectedOutcome]) {
        const probability = probData.probabilities[selectedOutcome];
        pricePerShare = probData.prices[selectedOutcome];
        probabilityText = `${probability}% market confidence (based on community investments)`;
      }
      
      // Show price per share with dynamic Yin Yang coloring
      let priceDisplay = '';
      if (probData && probData.prices && probData.prices[selectedOutcome]) {
        const priceColor = isYangOption ? '#06b6d4' : '#9ca3af';
        priceDisplay = `<span style='color:${priceColor};font-size:1.08em;font-weight:700;margin-left:8px;'>${pricePerShare.toFixed(3)} BNB/share</span>`;
      } else {
        priceDisplay = `<span style='color:#9ca3af;font-size:0.95em;font-weight:700;margin-left:8px;'>Loading price...</span>`;
      }
      
      // Apply dynamic symbol and coloring for option name
      const symbol = isYangOption ? '☀️' : (isYinOption ? '🌙' : '');
      const nameColor = isYangOption ? '#06b6d4' : '#9ca3af';
      const symbolDisplay = symbol ? `<span style='font-size:1.2em;margin-right:6px;'>${symbol}</span>` : '';
      
      document.getElementById('tradeOptionName').innerHTML = `${symbolDisplay}<span style='color:${nameColor};'>${opt.name}</span> ${opt.image?`<img src='${opt.image}' style='width:28px;height:28px;border-radius:50%;vertical-align:middle;margin-left:6px;border:2px solid ${nameColor};'>`:''} ${priceDisplay}`;
      document.getElementById('tradeOdds').textContent = probabilityText;
      document.getElementById('tradeAmount').value = '';
      document.getElementById('tradeMsg').textContent = '';
      
      // Update buy button text based on Yin/Yang choice
      const buyBtn = document.getElementById('buyBtn');
      if (buyBtn) {
        const actionText = isYangOption ? '☀️ Support' : (isYinOption ? '🌙 Oppose' : 'Purchase');
        buyBtn.innerHTML = `${actionText} <span data-i18n="shares">Shares</span>`;
      }
      
      calculateProfit();
    }

    async function handleBuy() {
      const amt = parseFloat(document.getElementById('tradeAmount').value);
      if (!amt || amt<=0) {
        document.getElementById('tradeMsg').textContent = window.i18n.t('enterValidAmount');
        return;
      }
      if (!walletAddress || !web3) {
        document.getElementById('tradeMsg').textContent = window.i18n.t('connectWalletFirst');
        return;
      }
      
      if (!window.ethereum) {
        document.getElementById('tradeMsg').textContent = window.i18n.t('metamaskNotConnected');
        return;
      }
      
      try {
        document.getElementById('tradeMsg').textContent = 'Processing trade...';
        document.getElementById('buyBtn').disabled = true;
        
        // Use enhanced trading engine for better calculations
        const tradeResult = await window.enhancedTrading.executeTrade(
          currentMarket.id, 
          selectedOutcome, 
          amt, 
          walletAddress
        );
        
        if (tradeResult.success) {
          // Show success message with trade details
          const details = tradeResult.tradeDetails;
          document.getElementById('tradeMsg').innerHTML = `
            <div style="color:#06b6d4;font-weight:600;">✅ ${tradeResult.message}</div>
            <div style="color:#9ca3af;font-size:0.9em;margin-top:4px;">
              Shares: ${details.sharesReceived.toFixed(3)} | 
              Price: ${details.pricePerShare.toFixed(3)} BNB/share | 
              Fee: ${details.platformFee.toFixed(3)} BNB
            </div>
          `;
          
          // Update charts and market display
          setTimeout(() => {
            renderMarketInfo(currentMarket);
            renderChart(currentMarket, currentOrderBook);
            renderOrderBookPro(currentOrderBook, currentMarket, selectedOutcome);
            updateTradePanel();
            calculateProfit();
            
            // Force refresh charts with new data
            if (window.lmsrChartEngine) {
              window.lmsrChartEngine.createProbabilityChart('probabilityChartContainer', currentMarket.id);
              if (document.getElementById('distributionChartContainer').style.display !== 'none') {
                window.lmsrChartEngine.createCurrentDistributionChart('distributionChartContainer', currentMarket.id);
              }
            }
          }, 500);
          
          // Add to order book simulation
          if (!currentOrderBook) currentOrderBook = [];
          currentOrderBook.push({
            id: Date.now(),
            market_id: currentMarket.id,
            option_id: selectedOutcome,
            amount: details.netAmount.toString(),
            shares_purchased: details.sharesReceived.toString(),
            execution_odds: details.pricePerShare.toString(),
            wallet_address: walletAddress,
            created_at: new Date().toISOString(),
            status: 'completed'
          });
          
          // Clear form
          document.getElementById('tradeAmount').value = '';
          
        } else {
          document.getElementById('tradeMsg').textContent = tradeResult.message || 'Trade failed';
        }
        
      } catch (error) {
        console.error('Trade execution error:', error);
        document.getElementById('tradeMsg').textContent = `Error: ${error.message}`;
      } finally {
        document.getElementById('buyBtn').disabled = false;
      }
    }

    async function handleCancelPurchase() {
      if (!walletAddress) {
        document.getElementById('tradeMsg').textContent = 'Connect your wallet first.';
        return;
      }
      document.getElementById('tradeMsg').textContent = 'Requesting cancellation...';
      try {
        await fetch(`${API_BASE_URL}/cancel`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            marketId: currentMarket.id,
            optionId: selectedOutcome,
            bettorAddress: walletAddress.toString()
          })
        });
        document.getElementById('tradeMsg').textContent = 'Cancellation request sent. Refunds are processed within 24 hours.';
      } catch (e) {
        document.getElementById('tradeMsg').textContent = 'Cancellation failed: ' + (e.message || e);
      }
    }

    // Chart switching functionality
    function switchChart(chartType) {
      // Update tab states
      document.querySelectorAll('.chart-tab').forEach(tab => tab.classList.remove('active'));
      document.getElementById(chartType + 'Tab').classList.add('active');
      
      // Show/hide chart containers
      document.getElementById('probabilityChartContainer').style.display = chartType === 'probability' ? 'block' : 'none';
      document.getElementById('distributionChartContainer').style.display = chartType === 'distribution' ? 'block' : 'none';
      
      // Load chart if not already loaded and chart engine is available
      if (currentMarket && window.lmsrChartEngine) {
        try {
          // Add a small delay to ensure container is visible
          setTimeout(() => {
            if (chartType === 'probability') {
              window.lmsrChartEngine.createProbabilityChart('probabilityChartContainer', currentMarket.id);
            } else if (chartType === 'distribution') {
              window.lmsrChartEngine.createCurrentDistributionChart('distributionChartContainer', currentMarket.id);
            }
          }, 100);
        } catch (error) {
          console.error('Chart creation failed:', error);
          const container = document.getElementById(chartType + 'ChartContainer');
          if (container) {
            container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#ff6b6b;font-size:14px;">⚠️ Chart failed to load</div>';
          }
        }
      }
    }

    // Updated chart rendering function
    function renderChart(market, orderBook) {
      // Only initialize probability chart once, with a delay to ensure DOM is ready
      if (window.lmsrChartEngine && !window.lmsrChartEngine.chartInstances['probabilityChart']) {
        setTimeout(() => {
          try {
            window.lmsrChartEngine.createProbabilityChart('probabilityChartContainer', market.id);
          } catch (error) {
            console.error('Chart initialization failed:', error);
            const container = document.getElementById('probabilityChartContainer');
            if (container) {
              container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#ff6b6b;font-size:14px;">⚠️ Chart failed to load</div>';
            }
          }
        }, 200);
      } else if (!window.lmsrChartEngine) {
        console.warn('Chart engine not available');
        const container = document.getElementById('probabilityChartContainer');
        if (container) {
          container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#9ca3af;font-size:14px;">📊 Charts temporarily unavailable</div>';
        }
      }
    }

    // Create a demo market for testing
    function createDemoMarket() {
      return {
        id: 'demo-market-1',
        title: '2024 BNB Price Prediction - Will BNB reach $1000?',
        description: 'Predict whether BNB will reach $1000 by end of 2024',
        created_at: new Date().toISOString(),
        resolved: false,
        options: [
          {
            name: 'YES - BNB hits $1000 ☀️',
            image: null,
            isYang: true
          },
          {
            name: 'NO - BNB stays under $1000 🌙',
            image: null,
            isYang: false
          },
          {
            name: 'MAYBE - BNB hits $800-999',
            image: null,
            isYang: null
          },
          {
            name: 'UNLIKELY - BNB drops below $300',
            image: null,
            isYang: false
          }
        ],
        metadata: {
          admin_odds: [0.4, 0.3, 0.2, 0.1]
        }
      };
    }

    async function loadMarketPage() {
      const marketId = getMarketId();
      if (!marketId) {
        // Create a demo market for testing the enhanced order book
        currentMarket = createDemoMarket();
        currentOrderBook = [];
        renderMarketInfo(currentMarket);
        renderChart(currentMarket, currentOrderBook);
        updateTradePanel();
        return;
      }
      
      try {
        // Fetch both market and bets data (there's no separate orderbook endpoint)
        const marketResponse = await fetch(`${API_BASE_URL}/markets/${marketId}`);
        if (!marketResponse.ok) throw new Error('Failed to fetch market');
        const marketData = await marketResponse.json();
        
        const betsResponse = await fetch(`${API_BASE_URL}/bets?marketId=${marketId}`);
        if (!betsResponse.ok) throw new Error('Failed to fetch bets');
        const betsData = await betsResponse.json();
        
        const market = marketData.market;
        const orderBook = betsData.bets || [];
        
        // CRITICAL: Force parse metadata - this is where odds are stored
        if (typeof market.metadata === 'string') {
          console.log('⚠️ Metadata came as string, parsing...');
          try {
            market.metadata = JSON.parse(market.metadata);
          } catch (e) {
            console.error('Failed to parse metadata:', e);
            market.metadata = {};
          }
        }
        
        if (!market.metadata || typeof market.metadata !== 'object') {
          console.log('⚠️ Metadata missing, creating empty object');
          market.metadata = {};
        }
        
        // Ensure admin_odds array exists
        if (!Array.isArray(market.metadata.admin_odds)) {
          console.warn('⚠️ admin_odds not found or not an array, initializing empty');
          market.metadata.admin_odds = [];
        }
        
        // Debug output
        console.log('========================================');
        console.log('✓ MARKET LOADED');
        console.log('Market ID:', market.id);
        console.log('Market title:', market.title);
        console.log('Metadata type:', typeof market.metadata);
        console.log('Metadata:', market.metadata);
        console.log('Admin odds:', market.metadata.admin_odds);
        console.log('Admin odds is array?', Array.isArray(market.metadata.admin_odds));
        if (Array.isArray(market.metadata.admin_odds)) {
          market.metadata.admin_odds.forEach((odd, i) => {
            console.log(`  Option ${i}: odds = ${odd} (${typeof odd})`);
          });
        }
        console.log('========================================');
        
        // Set global variables
        currentMarket = market;
        currentOrderBook = orderBook;
        selectedOutcome = 0;
        window.currentMarket = currentMarket;
        window.currentOrderBook = currentOrderBook;
        window.selectedOutcome = selectedOutcome;
        
        // Render everything
        await renderMarketInfo(market);
        renderChart(market, orderBook);
        renderOrderBookPro(orderBook, market, 0);
        updateTradePanel();
        
        // Setup buttons
        document.getElementById('buyBtn').onclick = handleBuy;
        document.getElementById('cancelBtn').onclick = handleCancelPurchase;
        document.getElementById('tradeAmount').oninput = calculateProfit;
        
        // Load comments
        await loadCommentsForMarket(marketId);
        setupCommentBox(marketId);
        
      } catch (e) {
        console.error('Load market error:', e);
        document.getElementById('marketSection').innerHTML = `<div style='color:#ef4444;'>Error: ${e.message}</div>`;
      }
    }

    async function loadMyBets() {
      const container = document.getElementById('betsContainer');
      const portfolioSummaryContainer = document.getElementById('portfolioSummary');
      
      if (!walletAddress) {
        container.innerHTML = `<div class="empty-state"><h3>Connect Wallet</h3><p>Connect your wallet to view your betting history.</p></div>`;
        if (portfolioSummaryContainer) portfolioSummaryContainer.innerHTML = '';
        return;
      }
      
      try {
        const res = await fetch(`${API_BASE_URL}/bets?address=${walletAddress.toString()}`);
        const data = await res.json();
        const bets = data.bets || [];
        
        if (bets.length === 0) {
          container.innerHTML = `<div class="empty-state"><h3>No Bets Yet</h3><p>Your betting history will appear here once you place your first bet.</p></div>`;
          if (portfolioSummaryContainer) portfolioSummaryContainer.innerHTML = '';
        } else {
          // Portfolio summary variables
          let totalInvested = 0;
          let totalCurrentValue = 0;
          let totalShares = 0;
          let activeBets = 0;
          
          const betCards = await Promise.all(bets.map(async bet => {
            let optionName = '';
            let optionImage = '';
            let allOptions = [];
            let market = null;
            
            if (bet.optionId !== undefined && bet.market_id) {
              try {
                const res = await fetch(`${API_BASE_URL}/markets/${bet.market_id}`);
                if (res.ok) {
                  market = (await res.json()).market;
                  if (market && market.options) {
                    allOptions = market.options;
                    if (market.options[bet.optionId]) {
                      optionName = market.options[bet.optionId].name || '';
                      optionImage = market.options[bet.optionId].image || '';
                    }
                  }
                }
              } catch (error) {
                console.warn('Failed to load market option data:', error);
              }
            }

            // Calculate shares and PNL
            let sharesHtml = '';
            let pnlHtml = '';
            
            const originalAmount = parseFloat(bet.amount || 0);
            const platformFee = originalAmount * 0.01; // 1% platform fee
            const netInvestment = originalAmount - platformFee;
            const executionPrice = bet.execution_odds || 0.5; // Price per share at purchase
            const sharesOwned = executionPrice > 0 ? netInvestment / executionPrice : 0;
            
            // Update portfolio totals
            totalInvested += netInvestment;
            totalShares += sharesOwned;
            if (market && market.status !== 'resolved') activeBets++;
            
            if (sharesOwned > 0) {
              sharesHtml = `<div style="background:rgba(154,255,0,0.08);padding:8px 12px;border-radius:8px;margin:8px 0;">
                <div style="color:#9ca3af;font-weight:700;font-size:1.05rem;">Portfolio Position</div>
                <div style="color:#e6eef8;margin:4px 0;">
                  <span style="color:#9ca3af;font-weight:600;">${sharesOwned.toFixed(1)}</span> shares @ 
                  <span style="color:#06b6d4;">${executionPrice.toFixed(3)} BNB/share</span>
                </div>
                <div style="color:#9ca3af;font-size:0.9rem;">Net Investment: ${netInvestment.toFixed(3)} BNB (after 1% fee)</div>
              </div>`;
              
              // Get current market probabilities for PNL calculation
              try {
                const probData = await getLMSRProbabilities(bet.market_id);
                if (probData && probData.prices && probData.prices[bet.optionId] !== undefined) {
                  const currentPrice = probData.prices[bet.optionId];
                  const currentProbability = probData.probabilities[bet.optionId];
                  const currentValue = sharesOwned * currentPrice;
                  const unrealizedPnL = currentValue - netInvestment;
                  const pnlPercentage = ((unrealizedPnL / netInvestment) * 100).toFixed(1);
                  
                  // Update total current value
                  totalCurrentValue += currentValue;
                  
                  const pnlColor = unrealizedPnL >= 0 ? '#06b6d4' : '#9ca3af';
                  const pnlSign = unrealizedPnL >= 0 ? '+' : '';
                  
                  pnlHtml = `<div style="background:rgba(${unrealizedPnL >= 0 ? '16,185,129' : '255,107,107'},0.08);padding:8px 12px;border-radius:8px;margin:8px 0;">
                    <div style="color:${pnlColor};font-weight:700;font-size:1.05rem;">
                      ${unrealizedPnL >= 0 ? '📈' : '📉'} P&L: ${pnlSign}${unrealizedPnL.toFixed(3)} BNB (${pnlSign}${pnlPercentage}%)
                    </div>
                    <div style="color:#e6eef8;margin:4px 0;">
                      Current Value: <span style="color:#06b6d4;">${currentValue.toFixed(3)} BNB</span> 
                      (${currentPrice.toFixed(3)} BNB/share)
                    </div>
                    <div style="color:#9ca3af;font-size:0.9rem;">
                      Market Confidence: ${currentProbability}% | 
                      ${market?.status === 'resolved' ? 'Market Resolved' : 'Live Market'}
                    </div>
                  </div>`;
                } else {
                  // Use fallback current value if no price data
                  totalCurrentValue += netInvestment; // Conservative estimate
                  pnlHtml = `<div style="background:rgba(156,163,175,0.08);padding:8px 12px;border-radius:8px;margin:8px 0;">
                    <div style="color:#9ca3af;font-size:0.95rem;">📊 Current market data loading...</div>
                  </div>`;
                }
              } catch (error) {
                console.warn('Failed to calculate PNL for bet:', error);
                totalCurrentValue += netInvestment; // Conservative estimate
                pnlHtml = `<div style="background:rgba(156,163,175,0.08);padding:8px 12px;border-radius:8px;margin:8px 0;">
                  <div style="color:#9ca3af;font-size:0.95rem;">⚠️ Unable to calculate current P&L</div>
                </div>`;
              }
            }
            
            let optionsHtml = '';
            if (allOptions.length > 0) {
              optionsHtml = `<div style="display:flex;gap:12px;margin-top:8px;">` +
                allOptions.map((opt, idx) => {
                  const picked = idx === bet.optionId;
                  return `<div style="display:flex;flex-direction:column;align-items:center;justify-content:center;padding:6px 10px;border-radius:10px;min-width:70px;background:${picked ? '#9ca3af' : '#374151'};color:${picked ? '#111827' : '#e5e7eb'};border:2px solid ${picked ? '#9ca3af' : '#374151'};font-weight:${picked ? '800' : '600'};box-shadow:${picked ? '0 2px 8px rgba(156,163,175,0.13)' : 'none'};transition:all 0.2s;">
                    ${opt.image ? `<img src='${opt.image}' alt='' style='width:22px;height:22px;border-radius:50%;background:#1f2937;margin-bottom:4px;'>` : ''}
                    <span style="font-size:1.01rem;">${opt.name || 'Option ' + (idx+1)}</span>
                    ${picked ? '<span style=\'margin-top:3px;font-size:0.92em;font-weight:700;color:#6b7280;\'>&#10003; Picked</span>' : ''}
                  </div>`;
                }).join('') + `</div>`;
            } else if (optionName) {
              optionsHtml = `<span style='display:flex;align-items:center;gap:6px;background:#374151;padding:4px 10px;border-radius:8px;border:1.5px solid #9ca3af;font-weight:700;color:#9ca3af;'>${optionImage ? `<img src='${optionImage}' alt='' style='width:22px;height:22px;border-radius:50%;background:#1f2937;'>` : ''}<span>${optionName}</span></span>`;
            }
            
            return `<div class="admin-card" style="background:linear-gradient(135deg, #1f2937, #374151);border:1px solid #4b5563;margin-bottom:18px;padding:18px 16px;border-radius:12px;box-shadow:0 4px 14px rgba(75,85,99,0.2);">
              <div class="market-title" style="font-weight:700;font-size:1.1rem;color:#9ca3af;">${bet.market_title || 'Unknown Market'}</div>
              <div style="display:flex;align-items:center;gap:10px;margin:8px 0;"><span style="color: #9ca3af; font-weight: 700;">Original Purchase: ${originalAmount.toFixed(3)} BNB</span></div>
              ${optionsHtml}
              ${sharesHtml}
              ${pnlHtml}
              <div style="color: #9ca3af; font-size: 12px;margin-top:6px;">${new Date(bet.created_at).toLocaleDateString()}${bet.transaction_signature ? ` | <a href="https://bscscan.com/tx/${bet.transaction_signature}" target="_blank" style="color: #9ca3af;">View TX</a>` : ''}</div>
            </div>`;
          }));
          
          // Display portfolio summary
          const totalPnL = totalCurrentValue - totalInvested;
          const pnlPercentage = totalInvested > 0 ? ((totalPnL / totalInvested) * 100).toFixed(1) : '0.0';
          const pnlColor = totalPnL >= 0 ? '#06b6d4' : '#9ca3af';
          const pnlSign = totalPnL >= 0 ? '+' : '';
          
          if (portfolioSummaryContainer) {
            portfolioSummaryContainer.innerHTML = `
              <div style="background:#374151;padding:16px 20px;border-radius:12px;border:1.5px solid rgba(156,163,175,0.3);min-width:180px;">
                <div style="color:#9ca3af;font-weight:700;font-size:0.9rem;margin-bottom:6px;">${window.i18n.t('totalInvested')}</div>
                <div style="color:#e5e7eb;font-size:1.4rem;font-weight:800;">${window.i18n.formatCurrency(totalInvested)}</div>
              </div>
              <div style="background:#374151;padding:16px 20px;border-radius:12px;border:1.5px solid rgba(6,182,212,0.3);min-width:180px;">
                <div style="color:#06b6d4;font-weight:700;font-size:0.9rem;margin-bottom:6px;">${window.i18n.t('currentValue')}</div>
                <div style="color:#e5e7eb;font-size:1.4rem;font-weight:800;">${window.i18n.formatCurrency(totalCurrentValue)}</div>
              </div>
              <div style="background:#374151;padding:16px 20px;border-radius:12px;border:1.5px solid ${totalPnL >= 0 ? 'rgba(6,182,212,0.3)' : 'rgba(156,163,175,0.3)'};min-width:180px;">
                <div style="color:${pnlColor};font-weight:700;font-size:0.9rem;margin-bottom:6px;">${window.i18n.t('totalPnL')}</div>
                <div style="color:${pnlColor};font-size:1.4rem;font-weight:800;">${pnlSign}${window.i18n.formatCurrency(totalPnL)}</div>
                <div style="color:${pnlColor};font-size:0.9rem;font-weight:600;">(${pnlSign}${pnlPercentage}%)</div>
              </div>
              <div style="background:#374151;padding:16px 20px;border-radius:12px;border:1.5px solid rgba(156,163,175,0.3);min-width:160px;">
                <div style="color:#9ca3af;font-weight:700;font-size:0.9rem;margin-bottom:6px;">${window.i18n.t('portfolioStats')}</div>
                <div style="color:#e6eef8;font-size:1.1rem;font-weight:600;">${totalShares.toFixed(0)} ${window.i18n.t('shares')}</div>
                <div style="color:#e6eef8;font-size:1.1rem;font-weight:600;">${activeBets} ${window.i18n.t('activeBets')}</div>
              </div>
            `;
          }
          
          container.innerHTML = betCards.join('');
        }
      } catch (error) {
        container.innerHTML = `<div class="empty-state"><h3>Error Loading Bets</h3><p>${error.message}</p></div>`;
        if (portfolioSummaryContainer) portfolioSummaryContainer.innerHTML = '';
      }
    }

    async function loadCommentsForMarket(marketId) {
      let bets = [];
      try {
        const res = await fetch(`${API_BASE_URL}/bets?market_id=${marketId}`);
        if (res.ok) {
          const data = await res.json();
          bets = data.bets || [];
        }
      } catch (error) {
        console.warn('Failed to load user bets:', error);
      }
      
      let allComments = [];
      for (const bet of bets) {
        try {
          const res = await fetch(`${API_BASE_URL}/bets/${bet.id}/comments`);
          if (res.ok) {
            const data = await res.json();
            if (Array.isArray(data.comments)) {
              data.comments.forEach(c => c.bet = bet);
              allComments = allComments.concat(data.comments);
            }
          }
        } catch (error) {
        console.warn('Failed to load user bets:', error);
      }
      }
      
      allComments.sort((a,b) => new Date(a.created_at) - new Date(b.created_at));
      renderCommentsList(allComments);
    }

    function renderCommentsList(comments) {
      const listDiv = document.getElementById('commentsList');
      if (!comments || comments.length === 0) {
        listDiv.innerHTML = `<div style='color:#bcd3e6;'>No comments yet. Be the first to comment!</div>`;
        return;
      }
      listDiv.innerHTML = comments.map(c => {
        const shortAddr = c.user_address.slice(0,4) + '...' + c.user_address.slice(-4);
        const pfp = `<span style="display:inline-block;width:32px;height:32px;border-radius:50%;background:#374151;margin-right:10px;text-align:center;line-height:32px;font-weight:700;font-size:1.1rem;color:#9ca3af;">${c.user_address[0]}</span>`;
        const cleanText = removeLinks(escapeHtml(c.comment_text));
        return `<div style="display:flex;align-items:flex-start;gap:10px;margin-bottom:14px;">
          ${pfp}
          <div style="flex:1;">
            <a href="https://solscan.io/address/${c.user_address}" target="_blank" rel="noopener" style="font-weight:700;color:#06b6d4;font-size:1.01rem;text-decoration:none;cursor:pointer;">${shortAddr}</a>
            <div style="color:#e6eef8;font-size:1.07rem;margin:2px 0 2px 0;white-space:pre-line;">${cleanText}</div>
            <div style="color:#bcd3e6;font-size:0.97rem;">${new Date(c.created_at).toLocaleString()}</div>
          </div>
        </div>`;
      }).join('');
    }

    function escapeHtml(text) {
      return text.replace(/[&<>"']/g, function(m) {
        return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'})[m];
      });
    }

    function removeLinks(text) {
      let cleaned = text.replace(/https?:\/\/\S+/gi, '').replace(/www\.[^\s]+/gi, '');
      cleaned = cleaned.replace(/\b[a-zA-Z0-9.-]+\.(com|net|org|io|xyz|app|link|to|me|co|site|info|gov|edu)\b/gi, '');
      return cleaned;
    }

    function setupCommentBox(marketId) {
      const commentBox = document.getElementById('commentBoxContainer');
      const loginMsg = document.getElementById('commentLoginMsg');
      const postBtn = document.getElementById('postCommentBtn');
      const commentInput = document.getElementById('commentInput');
      const commentMsg = document.getElementById('commentMsg');
      
      commentBox.style.display = 'none';
      loginMsg.textContent = '';
      
      if (!walletAddress || !walletAddress.toString) {
        loginMsg.textContent = 'Connect your wallet and place a bet to comment.';
        return;
      }
      
      fetch(`${API_BASE_URL}/bets?address=${walletAddress.toString()}&market_id=${marketId}`)
        .then(res => res.json())
        .then(data => {
          if (data.bets && data.bets.length > 0) {
            commentBox.style.display = '';
            loginMsg.textContent = '';
            postBtn.onclick = async () => {
              let text = commentInput.value.trim();
              if (!text) {
                commentMsg.textContent = 'Comment cannot be empty.';
                return;
              }
              text = removeLinks(text);
              const betId = data.bets[0].id;
              postBtn.disabled = true;
              commentMsg.textContent = 'Posting...';
              try {
                const res = await fetch(`${API_BASE_URL}/bets/${betId}/comments`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ user_address: walletAddress.toString(), comment_text: text })
                });
                const resp = await res.json();
                if (res.ok && resp.comment) {
                  commentInput.value = '';
                  commentMsg.textContent = 'Comment posted!';
                  await loadCommentsForMarket(marketId);
                } else {
                  commentMsg.textContent = resp.error || 'Failed to post comment.';
                }
              } catch (e) {
                commentMsg.textContent = 'Failed to post comment.';
              }
              postBtn.disabled = false;
            };
          } else {
            loginMsg.textContent = 'You must place a bet on this market to comment.';
          }
        });
    }

    async function calculateProfit() {
      const amt = parseFloat(document.getElementById('tradeAmount').value);
      
      const feeBreakdownEl = document.getElementById('feeBreakdown');
      const platformFeeEl = document.getElementById('platformFeeAmount');
      const netBetEl = document.getElementById('netBetAmount');
      
      if (!amt || amt <= 0) {
        document.getElementById('profitCalc').textContent = `${window.i18n.t('expectedReturn')}: 0.000 BNB`;
        if (feeBreakdownEl) feeBreakdownEl.style.display = 'none';
        return;
      }
      
      // Calculate 1% platform fee on purchase
      const platformFee = amt * 0.01;
      const netPurchaseAmount = amt - platformFee;
      
      // Show fee breakdown
      if (platformFeeEl) platformFeeEl.textContent = `${platformFee.toFixed(6)} BNB`;
      if (netBetEl) netBetEl.textContent = `${netPurchaseAmount.toFixed(3)} BNB`;
      if (feeBreakdownEl) feeBreakdownEl.style.display = 'block';
      
      // Get LMSR data for proper calculation
      const probData = await getLMSRProbabilities(currentMarket.id);
      let probability = 50; // Fallback probability
      let sharesReceived = 0;
      let priceImpact = 0;
      let newProbability = probability;
      
      // Use proper LMSR mathematics if we have share data
      if (probData && probData.shares && window.lmsrEngine && selectedOutcome !== null && selectedOutcome !== undefined) {
        try {
          // Current market state
          const currentShares = probData.shares;
          const currentPrices = window.lmsrEngine.prices(currentShares);
          probability = Math.round(currentPrices[selectedOutcome] * 100);
          
          // Calculate exact shares using LMSR engine
          sharesReceived = window.lmsrEngine.sharesToBuy(currentShares, selectedOutcome, netPurchaseAmount);
          
          // Calculate price impact (new probability after purchase)
          const newShares = [...currentShares];
          newShares[selectedOutcome] += sharesReceived;
          const newPrices = window.lmsrEngine.prices(newShares);
          newProbability = Math.round(newPrices[selectedOutcome] * 100);
          priceImpact = newProbability - probability;
          
          console.log(`📊 ${window.i18n.t('lmsrCalculation')}:
            ${window.i18n.t('currentShares')}: [${currentShares.join(', ')}]
            ${window.i18n.t('currentProbability')}: ${probability}%
            ${window.i18n.t('sharesToBuy')}: ${sharesReceived.toFixed(3)}
            ${window.i18n.t('newProbability')}: ${newProbability}%
            ${window.i18n.t('priceImpact')}: +${priceImpact}%`);
          
        } catch (error) {
          console.warn('LMSR calculation failed, using fallback:', error);
          // Fallback to simple calculation
          const fallbackPrice = probData.prices?.[selectedOutcome] || 0.5;
          sharesReceived = netPurchaseAmount / fallbackPrice;
          probability = probData.probabilities?.[selectedOutcome] || 50;
        }
      } else {
        // Fallback calculation for backward compatibility
        const fallbackPrice = probData?.prices?.[selectedOutcome] || 0.5;
        sharesReceived = netPurchaseAmount / fallbackPrice;
        probability = probData?.probabilities?.[selectedOutcome] || 50;
        console.log(`📊 ${window.i18n.t('fallbackCalculation')}`);
      }
      
      // Calculate returns
      const maxReturn = sharesReceived * 1.0; // Max 1 BNB per share if wins
      const expectedReturn = sharesReceived * (newProbability / 100); // Expected value based on new market sentiment
      const avgCostPerShare = netPurchaseAmount / sharesReceived;
      
      // Price impact warning
      let priceImpactWarning = '';
      if (priceImpact > 5) {
        priceImpactWarning = `<div style="color:#ff6b6b;font-size:0.9rem;margin-top:4px;background:rgba(255,107,107,0.1);padding:4px 8px;border-radius:4px;">⚠️ ${window.i18n.t('largeTradeWarning')}: +${priceImpact}% ${window.i18n.t('priceImpact')}</div>`;
      } else if (priceImpact > 0) {
        priceImpactWarning = `<div style="color:#f59e0b;font-size:0.9rem;margin-top:4px;">📈 ${window.i18n.t('priceImpact')}: +${priceImpact}%</div>`;
      }
      
      document.getElementById('profitCalc').innerHTML = `
        <div>${window.i18n.t('shares')}: <span style="color:#9aff00;">${sharesReceived.toFixed(3)}</span> @ ${window.i18n.formatCurrency(avgCostPerShare)}/share</div>
        <div>${window.i18n.t('currentConfidence')}: <span style="color:#f59e0b;">${probability}%</span> → <span style="color:#10b981;">${newProbability}%</span></div>
        <div>${window.i18n.t('maxReturn')}: <span style="color:#10b981;">${window.i18n.formatCurrency(maxReturn)}</span> ${window.i18n.t('ifWins')} (1% ${window.i18n.t('payoutFeeApplies')})</div>
        <div>${window.i18n.t('expectedReturn')}: <span style="color:#f59e0b;">${window.i18n.formatCurrency(expectedReturn)}</span> (${newProbability}% ${window.i18n.t('finalConfidence')})</div>
        ${priceImpactWarning}
      `;
    }

    // Event listeners
    window.addEventListener('DOMContentLoaded', () => {
      const btn = document.getElementById('walletBtn');
      btn.onclick = () => {
        if (walletAddress) {
          if (confirm(window.i18n.t('disconnectConfirm'))) disconnectWallet();
        } else {
          connectWallet();
        }
      };

      // Language switcher functionality
      const langBtn = document.getElementById('langBtn');
      const langDropdown = document.getElementById('langDropdown');
      
      // Update language button display
      function updateLangBtn() {
        if (!window.i18n || !window.i18n.currentLanguage) {
          console.warn('I18n not initialized yet');
          return;
        }
        const currentLang = window.i18n.currentLanguage;
        const flag = currentLang === 'zh-CN' ? '🇨🇳' : '🇺🇸';
        const code = currentLang === 'zh-CN' ? 'CN' : 'EN';
        langBtn.textContent = `${flag} ${code}`;
      }
      
      // Toggle language dropdown
      langBtn.onclick = (e) => {
        e.stopPropagation();
        langDropdown.style.display = langDropdown.style.display === 'none' ? 'block' : 'none';
      };
      
      // Hide dropdown when clicking outside
      document.addEventListener('click', () => {
        langDropdown.style.display = 'none';
      });
      
      // Language option handlers
      document.querySelectorAll('.lang-option').forEach(option => {
        option.onclick = () => {
          const lang = option.dataset.lang;
          window.i18n.switchLanguage(lang);
          updateLangBtn();
          langDropdown.style.display = 'none';
          
          // Update URL parameter
          const url = new URL(window.location);
          url.searchParams.set('lang', lang);
          window.history.replaceState({}, '', url);
        };
      });
      
      // Initialize language display
      if (window.i18n && window.i18n.currentLanguage) {
        updateLangBtn();
        window.i18n.updateAllTexts();
      } else {
        console.warn('I18n not ready during initialization');
      }

      // Navigation logic for My Bets
      const myBetsNavLink = document.getElementById('myBetsNavLink');
      if (myBetsNavLink) {
        myBetsNavLink.onclick = (e) => {
          e.preventDefault();
          showMyBetsSection();
        };
      }

      // Quick bet amount buttons
      document.querySelectorAll('.quick-btn').forEach(btn => {
        btn.addEventListener('click', function() {
          const amount = this.dataset.amount;
          if (amount) {
            document.getElementById('tradeAmount').value = amount;
            calculateProfit();
          }
        });
      });

      // Max button
      const maxBtn = document.querySelector('.quick-btn-max');
      if (maxBtn) {
        maxBtn.addEventListener('click', function() {
          if (window.bnbBalance) {
            document.getElementById('tradeAmount').value = window.bnbBalance.toFixed(2);
            calculateProfit();
          }
        });
      }

      // Initialize Web3 and MetaMask
      initializeWeb3();

      document.getElementById('tradeAmount').oninput = calculateProfit;
      loadMarketPage();
    });

    // Function to show My Bets section
    function showMyBetsSection() {
      // Hide market section
      const marketSection = document.getElementById('marketSection');
      if (marketSection) marketSection.style.display = 'none';
      
      // Show My Bets section
      const mybetsSection = document.getElementById('mybetsSection');
      if (mybetsSection) {
        mybetsSection.style.display = 'block';
        loadMyBets(); // Load the user's bets with shares and PNL
      }
      
      // Update navigation highlight
      document.querySelectorAll('.nav-link').forEach(link => link.classList.remove('active'));
      const myBetsNavLink = document.getElementById('myBetsNavLink');
      if (myBetsNavLink) myBetsNavLink.classList.add('active');
    }

    // Function to show market section (for returning from My Bets)
    function showMarketSection() {
      // Show market section
      const marketSection = document.getElementById('marketSection');
      if (marketSection) marketSection.style.display = 'block';
      
      // Hide My Bets section
      const mybetsSection = document.getElementById('mybetsSection');
      if (mybetsSection) mybetsSection.style.display = 'none';
      
      // Update navigation highlight
      document.querySelectorAll('.nav-link').forEach(link => link.classList.remove('active'));
    }

    // Make functions available globally
    window.calculateProfit = calculateProfit;
    window.switchChart = switchChart;
  </script>

  <footer style="text-align:center; margin: 32px 0 16px 0;">
    <a href="https://x.com/BNBmarketCC" target="_blank" rel="noopener" class="primary" style="text-decoration:none;font-weight:600;font-size:16px;">
      Follow us on Twitter/X &rarr; @BNBmarketCC
    </a>
  </footer>
</body>
</html>
