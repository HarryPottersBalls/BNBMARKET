<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BNBmarket - Market</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inter:400,600,700&display=swap">
  <style>
    body {
      font-family: 'Inter', Arial, sans-serif;
      background: linear-gradient(135deg, #0b0b0f 0%, #111217 100%);
      color: #e6eef8;
      margin: 0;
      padding: 0;
    }
    .primary {
      color: #9aff00;
    }
    .accent {
      color: #7acc00;
    }
    .danger {
      color: #ff6b6b;
    }
    .surface {
      background: linear-gradient(180deg, rgba(55,65,81,0.4), rgba(31,41,55,0.6));
    }
    .btn {
      background: linear-gradient(90deg, #9aff00, #7acc00);
      color: #041;
      border: none;
      padding: 10px 16px;
      border-radius: 8px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(154,255,0,0.07);
      transition: background 0.2s, color 0.2s, transform 0.2s, box-shadow 0.2s;
    }
    .btn:hover {
      background: linear-gradient(90deg, #baff33, #9aff00);
      color: #041;
      box-shadow: 0 0 12px 0 rgba(154,255,0,0.18);
      transform: translateY(-1px) scale(1.03);
    }
    .btn.secondary {
      background: rgba(255,255,255,0.05);
      color: #bcd3e6;
      border: 1.5px solid rgba(255,255,255,0.07);
    }
    .btn.danger, .btn.danger:hover {
      background: linear-gradient(90deg, #ff6b6b, #dc2626);
      color: #fff;
      border: none;
      box-shadow: 0 2px 8px rgba(255,107,107,0.13);
    }
    .badge-success {
      background: rgba(154,255,0,0.08);
      color: #9aff00;
      border-radius: 6px;
      padding: 2px 10px;
      font-size: 0.95em;
      font-weight: 600;
      display: inline-block;
    }
    .badge-pending {
      background: rgba(245,158,11,0.1);
      color: #f59e0b;
      border-radius: 6px;
      padding: 2px 10px;
      font-size: 0.95em;
      font-weight: 600;
      display: inline-block;
    }
    .border-accent {
      border: 1.5px solid #9aff00;
    }
    .border-subtle {
      border: 1.5px solid rgba(255,255,255,0.07);
    }
    .text-secondary {
      color: #bcd3e6;
    }
    .text-warning {
      color: #f59e0b;
    }
    .text-error {
      color: #ff6b6b;
    }
    .text-title {
      color: #f9fafb;
    }
    
    /* Header Styles */
    .header {
      background: rgba(6, 6, 8, 0.55);
      backdrop-filter: blur(8px);
      border-bottom: 1px solid rgba(154, 255, 0, 0.06);
      padding: 16px 20px;
      position: sticky;
      top: 0;
      z-index: 40;
    }
    
    .header-inner {
      max-width: 1200px;
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 20px;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 700;
      color: #9aff00;
      font-size: 20px;
      text-decoration: none;
    }

    .brand .logo {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      background: linear-gradient(135deg, #9aff00, #7acc00);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #041;
      font-weight: 900;
    }

    .nav {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .nav a {
      padding: 10px 16px;
      border-radius: 8px;
      color: #d1d5db;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      text-decoration: none;
      transition: all 0.2s;
    }

    .nav a.active, .nav a:hover {
      color: #9aff00;
      background: rgba(154, 255, 0, 0.04);
    }

    .nav a.admin {
      background: rgba(255, 107, 107, 0.1);
      color: #ff6b6b;
      border: 1px solid rgba(255, 107, 107, 0.2);
    }

    .wallet-group {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .balance {
      background: rgba(255, 255, 255, 0.03);
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.04);
      font-size: 13px;
      font-weight: 600;
      color: #cfeccf;
    }

    .wallet-btn {
      background: linear-gradient(90deg, #9aff00, #7acc00);
      color: #041;
      border: none;
      padding: 10px 16px;
      border-radius: 8px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .wallet-btn:hover {
      transform: translateY(-1px);
    }

    .wallet-btn.connected {
      background: transparent;
      border: 1px solid #9aff00;
      color: #9aff00;
    }

    /* Language Switcher Styles */
    .language-switcher {
      position: relative;
      display: inline-block;
    }

    .lang-btn:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(154, 255, 0, 0.3);
    }

    .lang-dropdown {
      min-width: 120px;
    }

    .lang-option:hover {
      background: rgba(154, 255, 0, 0.1);
      color: #9aff00;
    }

    /* Chart Tab Styles */
    .chart-tab {
      background: transparent;
      border: none;
      color: #9ca3af;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .chart-tab:hover {
      color: #d1d5db;
      background: rgba(255, 255, 255, 0.05);
    }
    
    .chart-tab.active {
      color: #9aff00;
      background: rgba(154, 255, 0, 0.1);
      border: 1px solid rgba(154, 255, 0, 0.3);
    }
  </style>
</head>
<body>
  <header class="header">
    <div class="header-inner">
      <a href="index.html" class="brand">
        <div class="logo">S</div>
        <span>Solymarket</span>
      </a>
      <nav class="nav">
        <a href="index.html" class="nav-link">Markets</a>
        <a href="index.html" class="nav-link" id="myBetsNavLink" data-i18n="myBets">My Bets</a>
        <a href="index.html" class="nav-link" data-i18n="treasury">Treasury</a>
        <a href="index.html" class="nav-link" data-i18n="howItWorks">How It Works</a>
        <a href="index.html" id="adminTab" class="nav-link admin" style="display:none" data-i18n="adminPanel">Admin Panel</a>
      </nav>
      <div class="wallet-group">
        <!-- Language Switcher -->
        <div class="language-switcher" style="margin-right:12px;">
          <button id="langBtn" class="lang-btn" style="background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);color:#e6eef8;padding:8px 12px;border-radius:6px;font-size:13px;cursor:pointer;transition:all 0.2s;">
            üåç EN
          </button>
          <div id="langDropdown" class="lang-dropdown" style="display:none;position:absolute;top:100%;right:0;background:#23263a;border:1px solid rgba(255,255,255,0.1);border-radius:8px;padding:4px;margin-top:4px;box-shadow:0 4px 12px rgba(0,0,0,0.3);z-index:1000;">
            <button class="lang-option" data-lang="en" style="display:block;width:100%;text-align:left;background:none;border:none;color:#e6eef8;padding:8px 12px;border-radius:4px;cursor:pointer;font-size:13px;transition:background 0.2s;">üá∫üá∏ English</button>
            <button class="lang-option" data-lang="zh-CN" style="display:block;width:100%;text-align:left;background:none;border:none;color:#e6eef8;padding:8px 12px;border-radius:4px;cursor:pointer;font-size:13px;transition:background 0.2s;">üá®üá≥ ‰∏≠Êñá</button>
          </div>
        </div>
        <div class="balance" id="balanceDisplay" style="display:none;">
          BNB: <span id="bnbBalance">0.000</span>
        </div>
        <button id="walletBtn" class="btn wallet-btn" data-i18n="connectWallet">Connect Wallet</button>
      </div>
    </div>
  </header>

  <main>
    <section id="marketSection" style="max-width:1200px;margin:40px auto 0 auto;padding:40px 36px 48px 36px;background:linear-gradient(180deg, rgba(55,65,81,0.4), rgba(31,41,55,0.6));border-radius:22px;box-shadow:0 4px 40px rgba(0,0,0,0.13);">
      <div id="marketInfo">
        <h2 id="marketTitle" class="primary" style="margin-bottom:8px;font-size:2rem;font-weight:800;"></h2>
        <div id="marketMeta" style="color:#9ca3af;font-size:1rem;margin-bottom:8px;"></div>
        <div id="marketVolume" style="color:#f59e0b;font-size:1.08rem;font-weight:700;margin-bottom:8px;"></div>
        <div id="marketOptions" style="display:flex;gap:18px;margin-bottom:32px;"></div>
        <div id="totalBuys" style="color:#10b981;font-size:1.1rem;font-weight:600;margin-bottom:18px;"></div>
      </div>
      
      <div style="margin-bottom:32px;">
        <div style="display: flex; gap: 40px; align-items: flex-start; flex-wrap: wrap; width: 100%;">
          <div style="flex: 2.5; min-width: 420px; background: #181e29; border-radius: 18px; padding: 32px 24px 32px 24px; box-shadow: 0 2px 24px rgba(16,185,129,0.09);">
            <!-- Chart Tabs -->
            <div style="display: flex; gap: 8px; margin-bottom: 20px; border-bottom: 1px solid #23263a; padding-bottom: 12px;">
              <button id="probabilityTab" class="chart-tab active" onclick="switchChart('probability')" data-i18n="marketConfidenceOverTime">Market Confidence Over Time</button>
              <button id="distributionTab" class="chart-tab" onclick="switchChart('distribution')" data-i18n="currentMarketDistribution">Current Market Distribution</button>
            </div>
            
            <!-- Chart Containers -->
            <div id="probabilityChartContainer" style="height: 300px; position: relative;">
              <canvas id="probabilityChart"></canvas>
            </div>
            <div id="distributionChartContainer" style="height: 300px; position: relative; display: none;">
              <canvas id="distributionChart"></canvas>
            </div>
          </div>
          
          <div class="trade-card" style="background:#151926;border:1.5px solid #23263a;border-radius:18px;box-shadow:0 4px 32px rgba(16,185,129,0.09);padding:36px 32px 28px 32px;max-width:440px;width:100%;min-width:340px;margin-top:0;">
            <div style="display:flex;align-items:center;gap:12px;margin-bottom:10px;">
              <div id="tradeOptionName" style="color:#9aff00;font-weight:800;font-size:1.15rem;display:flex;align-items:center;gap:8px;"></div>
            </div>
            <div id="tradeOdds" style="color:#f59e0b;font-size:1.05rem;margin-bottom:10px;font-weight:600;"></div>
            <div style="display:flex;gap:8px;margin-bottom:12px;">
              <button class="btn quick-btn" type="button" data-amount="0.1" style="flex:1;min-width:0;background:#23263a;color:#9aff00;border:1.5px solid #9aff00;">0.1</button>
              <button class="btn quick-btn" type="button" data-amount="0.5" style="flex:1;min-width:0;background:#23263a;color:#9aff00;border:1.5px solid #9aff00;">0.5</button>
              <button class="btn quick-btn" type="button" data-amount="1" style="flex:1;min-width:0;background:#23263a;color:#9aff00;border:1.5px solid #9aff00;">1</button>
              <button class="btn quick-btn-max" type="button" style="flex:1;min-width:0;background:#23263a;color:#7acc00;border:1.5px solid #7acc00;" title="Max">Max</button>
            </div>
            <input id="tradeAmount" type="number" min="0.01" step="0.01" placeholder="Amount (BNB)" data-i18n-placeholder="amount" style="width:100%;padding:16px 14px;border-radius:10px;border:2px solid #7acc00;background:#181e29;color:#f3f4f6;font-size:1.2rem;margin-bottom:10px;outline:none;box-shadow:none;">
            <div id="feeBreakdown" style="color:#f59e0b;font-size:0.95rem;margin-bottom:10px;font-weight:500;background:rgba(245,158,11,0.08);padding:6px 8px;border-radius:6px;display:none;">
              <span data-i18n="platformFee">Platform Fee</span> (1%): <span id="platformFeeAmount">0.000 BNB</span> | <span data-i18n="netInvestment">Net Investment</span>: <span id="netBetAmount">0.000 BNB</span>
            </div>
            <div id="profitCalc" style="color:#10b981;font-size:1.08rem;margin-bottom:14px;font-weight:600;background:rgba(16,185,129,0.07);padding:8px 10px;border-radius:8px;"></div>
            <div style="display:flex;gap:10px;margin-bottom:10px;align-items:flex-start;">
              <button id="buyBtn" class="btn" style="flex:1;width:100%;font-size:1.08rem;padding:13px 0;box-shadow:0 2px 8px rgba(154,255,0,0.07);" data-i18n="purchaseShares">Purchase Shares</button>
            </div>
            <div style="display:flex;gap:10px;margin-bottom:10px;align-items:flex-start;">
              <button id="cancelBtn" class="btn" style="flex:1;width:100%;background:#ef4444;color:#fff;font-size:1.08rem;padding:13px 0;box-shadow:0 2px 8px rgba(239,68,68,0.13);border:1.5px solid #ef4444;" data-i18n="requestRefund">Request Refund</button>
            </div>
            <hr style="border:none;border-top:1px solid #23263a;margin:12px 0 10px 0;">
            <div id="tradeMsg" style="margin-top:0;color:#10b981;font-size:1.05rem;min-height:22px;"></div>
          </div>
        </div>
        <div id="orderBook" style="margin-top:32px;"></div>
      </div>
      
      <!-- Comment Section -->
      <section id="commentSection" style="margin-top:40px;background:#181e29;border-radius:16px;padding:28px 24px 18px 24px;box-shadow:0 2px 16px rgba(16,185,129,0.07);max-width:700px;margin-left:auto;margin-right:auto;">
        <h3 style="color:#9aff00;margin-bottom:10px;font-size:1.25rem;font-weight:700;" data-i18n="comments">Comments</h3>
        <div id="commentsList" style="margin-bottom:18px;"></div>
        <div id="commentBoxContainer" style="display:none;">
          <textarea id="commentInput" rows="3" maxlength="300" placeholder="Write a comment..." data-i18n-placeholder="writeComment" style="width:100%;padding:12px 10px;border-radius:8px;border:1.5px solid #7acc00;background:#151926;color:#e6eef8;font-size:1.08rem;resize:vertical;margin-bottom:8px;"></textarea>
          <div style="display:flex;align-items:center;justify-content:space-between;">
            <span id="commentWarning" style="color:#f59e0b;font-size:0.98rem;" data-i18n="warningScammers">Do not click any links beware of scammers.</span>
            <button id="postCommentBtn" class="btn" style="padding:8px 18px;font-size:1rem;" data-i18n="postComment">Post</button>
          </div>
          <div id="commentMsg" style="color:#ff6b6b;font-size:0.98rem;margin-top:6px;min-height:18px;"></div>
        </div>
        <div id="commentLoginMsg" style="color:#bcd3e6;font-size:1.05rem;margin-top:8px;"></div>
      </section>
    </section>

    <!-- My Bets Section -->
    <section id="mybetsSection" style="display:none;max-width:900px;margin:40px auto 0 auto;padding:32px 24px 40px 24px;background:linear-gradient(180deg, rgba(55,65,81,0.4), rgba(31,41,55,0.6));border-radius:18px;box-shadow:0 4px 32px rgba(0,0,0,0.10);">
      <div class="section-header" style="margin-bottom:24px;">
        <h2 class="section-title" style="color:#9aff00;font-size:2rem;font-weight:800;margin-bottom:12px;" data-i18n="myBettingPortfolio">My Betting Portfolio</h2>
        <div id="portfolioSummary" style="display:flex;gap:20px;flex-wrap:wrap;margin-bottom:16px;">
          <!-- Portfolio summary will be populated by JavaScript -->
        </div>
      </div>
      <div id="betsContainer">
        <div class="empty-state">
          <h3 data-i18n="connectWalletToBets">Connect Wallet</h3>
          <p data-i18n="connectWalletToView">Connect your wallet to view your betting history.</p>
        </div>
      </div>
    </section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
  <script src="odds-engine.js" onerror="console.warn('Failed to load odds-engine.js')"></script>
  <!-- <script src="lmsr-charts.js" onerror="console.warn('Failed to load lmsr-charts.js - using fallback')"></script> -->
  <script>
    // ========================================
    // INTERNATIONALIZATION SYSTEM
    // ========================================
    
    /**
     * Translation data for BNBmarket
     * Supporting English (en) and Simplified Chinese (zh-CN)
     */
    const translations = {
      en: {
        // Navigation
        markets: "Markets",
        myBets: "My Bets",
        treasury: "Treasury",
        howItWorks: "How It Works",
        adminPanel: "Admin Panel",
        connectWallet: "Connect Wallet",
        disconnect: "Disconnect",
        
        // Market Info
        category: "Category",
        created: "Created",
        totalVolume: "Total Volume",
        totalBuys: "Total Buys",
        
        // Trading
        purchaseShares: "Purchase Shares",
        requestRefund: "Request Refund",
        amount: "Amount",
        platformFee: "Platform Fee",
        netInvestment: "Net Investment",
        shares: "Shares",
        maxReturn: "Max Return",
        expectedReturn: "Expected Return",
        currentConfidence: "Current Confidence",
        finalConfidence: "final confidence",
        priceImpact: "Price impact",
        largeTradeWarning: "Large trade",
        ifWins: "if wins",
        payoutFeeApplies: "payout fee applies",
        
        // Portfolio
        portfolioPosition: "Portfolio Position",
        myBettingPortfolio: "My Betting Portfolio",
        totalInvested: "Total Invested",
        currentValue: "Current Value",
        totalPnL: "Total P&L",
        portfolioStats: "Portfolio Stats",
        activeBets: "Active Bets",
        originalPurchase: "Original Purchase",
        marketConfidence: "Market Confidence",
        liveMarket: "Live Market",
        marketResolved: "Market Resolved",
        
        // Status Messages
        connectWalletFirst: "Please connect your wallet first",
        enterValidAmount: "Enter a valid amount",
        processingPurchase: "Processing purchase...",
        purchaseCompleted: "Purchase completed!",
        purchaseFailed: "Purchase failed",
        received: "Received",
        cancellationRequested: "Cancellation request sent. Refunds are processed within 24 hours.",
        cancellationFailed: "Cancellation failed",
        
        // My Bets Section
        connectWalletToBets: "Connect Wallet",
        connectWalletToView: "Connect your wallet to view your betting history.",
        noBetsYet: "No Bets Yet",
        noBetsDescription: "Your betting history will appear here once you place your first bet.",
        errorLoadingBets: "Error Loading Bets",
        picked: "Picked",
        viewTx: "View TX",
        
        // Chart Labels
        marketConfidenceOverTime: "Market Confidence Over Time",
        currentMarketDistribution: "Current Market Distribution",
        chartLoadingError: "Chart failed to load",
        chartTempUnavailable: "Charts temporarily unavailable",
        currentMarketDataLoading: "Current market data loading...",
        unableToCalculatePnL: "Unable to calculate current P&L",
        
        // Comments
        comments: "Comments",
        writeComment: "Write a comment...",
        postComment: "Post",
        noCommentsYet: "No comments yet. Be the first to comment!",
        warningScammers: "Do not click any links beware of scammers.",
        commentEmpty: "Comment cannot be empty.",
        posting: "Posting...",
        commentPosted: "Comment posted!",
        failedToPost: "Failed to post comment.",
        mustPlaceBet: "You must place a bet on this market to comment.",
        
        // Errors and Warnings
        invalidMarketId: "Invalid market ID.",
        failedToFetchMarket: "Failed to fetch market",
        failedToFetchBets: "Failed to fetch bets",
        metamaskNotFound: "MetaMask wallet not found! Please install MetaMask.",
        metamaskNotConnected: "MetaMask not connected. Please reconnect.",
        disconnectConfirm: "Disconnect wallet?",
        
        // Time and Dates
        today: "Today",
        yesterday: "Yesterday",
        daysAgo: "days ago",
        
        // LMSR Messages
        lmsrCalculation: "LMSR Calculation",
        currentShares: "Current shares",
        currentProbability: "Current probability",
        sharesToBuy: "Shares to buy",
        newProbability: "New probability",
        fallbackCalculation: "Using fallback calculation (no LMSR data available)",
        tradeExecution: "LMSR Trade Execution",
        purchaseAmount: "Purchase amount",
        netAmount: "Net amount",
        sharesReceived: "Shares received",
        avgExecutionPrice: "Avg execution price",
        fallbackExecution: "Using fallback execution calculation"
      },
      
      'zh-CN': {
        // Navigation
        markets: "Â∏ÇÂú∫",
        myBets: "ÊàëÁöÑÊäïÊ≥®",
        treasury: "ËµÑÈáëÂ∫ì",
        howItWorks: "Â∑•‰ΩúÂéüÁêÜ",
        adminPanel: "ÁÆ°ÁêÜÈù¢Êùø",
        connectWallet: "ËøûÊé•Èí±ÂåÖ",
        disconnect: "Êñ≠ÂºÄËøûÊé•",
        
        // Market Info  
        category: "Á±ªÂà´",
        created: "ÂàõÂª∫Êó∂Èó¥",
        totalVolume: "ÊÄª‰∫§ÊòìÈáè",
        totalBuys: "ÊÄªË¥≠‰π∞Êï∞",
        
        // Trading
        purchaseShares: "Ë¥≠‰π∞‰ªΩÈ¢ù",
        requestRefund: "Áî≥ËØ∑ÈÄÄÊ¨æ",
        amount: "ÈáëÈ¢ù",
        platformFee: "Âπ≥Âè∞Ë¥πÁî®",
        netInvestment: "ÂáÄÊäïËµÑ",
        shares: "‰ªΩÈ¢ù",
        maxReturn: "ÊúÄÂ§ßÂõûÊä•",
        expectedReturn: "È¢ÑÊúüÂõûÊä•",
        currentConfidence: "ÂΩìÂâçÁΩÆ‰ø°Â∫¶",
        finalConfidence: "ÊúÄÁªàÁΩÆ‰ø°Â∫¶",
        priceImpact: "‰ª∑Ê†ºÂΩ±Âìç",
        largeTradeWarning: "Â§ßÈ¢ù‰∫§Êòì",
        ifWins: "Â¶ÇÊûúËé∑ËÉú",
        payoutFeeApplies: "ÊîØ‰ªòË¥πÁî®ÈÄÇÁî®",
        
        // Portfolio
        portfolioPosition: "ÊäïËµÑÁªÑÂêà‰ªì‰Ωç",
        myBettingPortfolio: "ÊàëÁöÑÊäïÊ≥®ÁªÑÂêà",
        totalInvested: "ÊÄªÊäïËµÑ",
        currentValue: "ÂΩìÂâç‰ª∑ÂÄº",
        totalPnL: "ÊÄªÁõà‰∫è",
        portfolioStats: "ÁªÑÂêàÁªüËÆ°",
        activeBets: "Ê¥ªË∑ÉÊäïÊ≥®",
        originalPurchase: "ÂéüÂßãË¥≠‰π∞",
        marketConfidence: "Â∏ÇÂú∫ÁΩÆ‰ø°Â∫¶",
        liveMarket: "ÂÆûÊó∂Â∏ÇÂú∫",
        marketResolved: "Â∏ÇÂú∫Â∑≤ÁªìÁÆó",
        
        // Status Messages
        connectWalletFirst: "ËØ∑ÂÖàËøûÊé•ÊÇ®ÁöÑÈí±ÂåÖ",
        enterValidAmount: "ËØ∑ËæìÂÖ•ÊúâÊïàÈáëÈ¢ù",
        processingPurchase: "Â§ÑÁêÜË¥≠‰π∞‰∏≠...",
        purchaseCompleted: "Ë¥≠‰π∞ÂÆåÊàêÔºÅ",
        purchaseFailed: "Ë¥≠‰π∞Â§±Ë¥•",
        received: "Â∑≤Êî∂Âà∞",
        cancellationRequested: "ÂèñÊ∂àËØ∑Ê±ÇÂ∑≤ÂèëÈÄÅ„ÄÇÈÄÄÊ¨æÂ∞ÜÂú®24Â∞èÊó∂ÂÜÖÂ§ÑÁêÜ„ÄÇ",
        cancellationFailed: "ÂèñÊ∂àÂ§±Ë¥•",
        
        // My Bets Section
        connectWalletToBets: "ËøûÊé•Èí±ÂåÖ",
        connectWalletToView: "ËøûÊé•ÊÇ®ÁöÑÈí±ÂåÖ‰ª•Êü•ÁúãÊäïÊ≥®ÂéÜÂè≤„ÄÇ",
        noBetsYet: "ÊöÇÊó†ÊäïÊ≥®",
        noBetsDescription: "ÊÇ®ÁöÑÊäïÊ≥®ÂéÜÂè≤Â∞ÜÂú®ÊÇ®‰∏ãÁ¨¨‰∏ÄÁ¨îÊäïÊ≥®ÂêéÊòæÁ§∫Âú®ËøôÈáå„ÄÇ",
        errorLoadingBets: "Âä†ËΩΩÊäïÊ≥®ÈîôËØØ",
        picked: "Â∑≤ÈÄâÊã©",
        viewTx: "Êü•Áúã‰∫§Êòì",
        
        // Chart Labels
        marketConfidenceOverTime: "Â∏ÇÂú∫ÁΩÆ‰ø°Â∫¶ÈöèÊó∂Èó¥ÂèòÂåñ",
        currentMarketDistribution: "ÂΩìÂâçÂ∏ÇÂú∫ÂàÜÂ∏É",
        chartLoadingError: "ÂõæË°®Âä†ËΩΩÂ§±Ë¥•",
        chartTempUnavailable: "ÂõæË°®ÊöÇÊó∂‰∏çÂèØÁî®",
        currentMarketDataLoading: "ÂΩìÂâçÂ∏ÇÂú∫Êï∞ÊçÆÂä†ËΩΩ‰∏≠...",
        unableToCalculatePnL: "Êó†Ê≥ïËÆ°ÁÆóÂΩìÂâçÁõà‰∫è",
        
        // Comments
        comments: "ËØÑËÆ∫",
        writeComment: "ÂÜôËØÑËÆ∫...",
        postComment: "ÂèëÂ∏É",
        noCommentsYet: "ÊöÇÊó†ËØÑËÆ∫„ÄÇÊàê‰∏∫Á¨¨‰∏Ä‰∏™ËØÑËÆ∫ÁöÑ‰∫∫ÔºÅ",
        warningScammers: "ËØ∑ÂãøÁÇπÂáª‰ªª‰ΩïÈìæÊé•ÔºåË∞®Èò≤ËØàÈ™ó„ÄÇ",
        commentEmpty: "ËØÑËÆ∫‰∏çËÉΩ‰∏∫Á©∫„ÄÇ",
        posting: "ÂèëÂ∏É‰∏≠...",
        commentPosted: "ËØÑËÆ∫Â∑≤ÂèëÂ∏ÉÔºÅ",
        failedToPost: "ÂèëÂ∏ÉËØÑËÆ∫Â§±Ë¥•„ÄÇ",
        mustPlaceBet: "ÊÇ®ÂøÖÈ°ªÂú®Ê≠§Â∏ÇÂú∫‰∏ãÊ≥®ÊâçËÉΩËØÑËÆ∫„ÄÇ",
        
        // Errors and Warnings
        invalidMarketId: "Êó†ÊïàÁöÑÂ∏ÇÂú∫ID„ÄÇ",
        failedToFetchMarket: "Ëé∑ÂèñÂ∏ÇÂú∫Â§±Ë¥•",
        failedToFetchBets: "Ëé∑ÂèñÊäïÊ≥®Â§±Ë¥•",
        metamaskNotFound: "Êú™ÊâæÂà∞MetaMaskÈí±ÂåÖÔºÅËØ∑ÂÆâË£ÖMetaMask„ÄÇ",
        metamaskNotConnected: "MetaMaskÊú™ËøûÊé•„ÄÇËØ∑ÈáçÊñ∞ËøûÊé•„ÄÇ",
        disconnectConfirm: "Êñ≠ÂºÄÈí±ÂåÖËøûÊé•Ôºü",
        
        // Time and Dates
        today: "‰ªäÂ§©",
        yesterday: "Êò®Â§©", 
        daysAgo: "Â§©Ââç",
        
        // LMSR Messages
        lmsrCalculation: "LMSRËÆ°ÁÆó",
        currentShares: "ÂΩìÂâç‰ªΩÈ¢ù",
        currentProbability: "ÂΩìÂâçÊ¶ÇÁéá",
        sharesToBuy: "Ë¥≠‰π∞‰ªΩÈ¢ù",
        newProbability: "Êñ∞Ê¶ÇÁéá", 
        fallbackCalculation: "‰ΩøÁî®ÂêéÂ§áËÆ°ÁÆóÔºàÊó†LMSRÊï∞ÊçÆÂèØÁî®Ôºâ",
        tradeExecution: "LMSR‰∫§ÊòìÊâßË°å",
        purchaseAmount: "Ë¥≠‰π∞ÈáëÈ¢ù",
        netAmount: "ÂáÄÈáëÈ¢ù",
        sharesReceived: "Êî∂Âà∞‰ªΩÈ¢ù",
        avgExecutionPrice: "Âπ≥ÂùáÊâßË°å‰ª∑Ê†º",
        fallbackExecution: "‰ΩøÁî®ÂêéÂ§áÊâßË°åËÆ°ÁÆó"
      }
    };

    /**
     * Internationalization Manager
     */
    class I18nManager {
      constructor() {
        this.translations = translations;
        this.currentLanguage = this.detectLanguage();
        console.log(`üåç I18n initialized with language: ${this.currentLanguage}`);
      }
      
      /**
       * Auto-detect user's preferred language
       */
      detectLanguage() {
        // Check URL parameter first
        const urlParams = new URLSearchParams(window.location.search);
        const langParam = urlParams.get('lang');
        if (langParam && this.translations[langParam]) {
          return langParam;
        }
        
        // Check localStorage
        const savedLang = localStorage.getItem('bnbmarket_language');
        if (savedLang && this.translations[savedLang]) {
          return savedLang;
        }
        
        // Check browser language
        const browserLang = navigator.language || navigator.userLanguage;
        if (browserLang.startsWith('zh')) {
          return 'zh-CN';
        }
        
        return 'en'; // Default to English
      }
      
      /**
       * Get translation for a key
       */
      t(key) {
        const lang = this.translations[this.currentLanguage];
        return lang && lang[key] ? lang[key] : this.translations.en[key] || key;
      }
      
      /**
       * Switch language
       */
      switchLanguage(lang) {
        if (!this.translations[lang]) {
          console.warn(`Language ${lang} not supported`);
          return;
        }
        
        this.currentLanguage = lang;
        localStorage.setItem('bnbmarket_language', lang);
        this.updateAllTexts();
        console.log(`üåç Language switched to: ${lang}`);
      }
      
      /**
       * Update all translatable texts in the DOM
       */
      updateAllTexts() {
        // Update navigation
        const myBetsLink = document.getElementById('myBetsNavLink');
        if (myBetsLink) myBetsLink.textContent = this.t('myBets');
        
        // Update wallet button
        const walletBtn = document.getElementById('walletBtn');
        if (walletBtn && !walletAddress) {
          walletBtn.textContent = this.t('connectWallet');
        }
        
        // Update other elements with data-i18n attribute
        document.querySelectorAll('[data-i18n]').forEach(element => {
          const key = element.getAttribute('data-i18n');
          element.textContent = this.t(key);
        });
        
        // Update placeholders
        document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
          const key = element.getAttribute('data-i18n-placeholder');
          element.placeholder = this.t(key);
        });
        
        // Refresh current page content
        if (window.currentMarket) {
          this.updateMarketTexts();
        }
      }
      
      /**
       * Update market-specific texts
       */
      updateMarketTexts() {
        // Update trade panel
        const buyBtn = document.getElementById('buyBtn');
        if (buyBtn) buyBtn.textContent = this.t('purchaseShares');
        
        const cancelBtn = document.getElementById('cancelBtn');
        if (cancelBtn) cancelBtn.textContent = this.t('requestRefund');
        
        // Update chart tabs
        const probabilityTab = document.getElementById('probabilityTab');
        if (probabilityTab) probabilityTab.textContent = this.t('marketConfidenceOverTime');
        
        const distributionTab = document.getElementById('distributionTab');
        if (distributionTab) distributionTab.textContent = this.t('currentMarketDistribution');
      }
      
      /**
       * Format number with localization
       */
      formatNumber(number, decimals = 3) {
        if (this.currentLanguage === 'zh-CN') {
          return number.toLocaleString('zh-CN', { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
        }
        return number.toLocaleString('en-US', { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
      }
      
      /**
       * Format currency
       */
      formatCurrency(amount, currency = 'BNB') {
        const formatted = this.formatNumber(amount, 3);
        return `${formatted} ${currency}`;
      }
    }

    // Initialize global i18n manager
    window.i18n = new I18nManager();

    // ========================================
    // LMSR IMPLEMENTATION (Digital Ronin's Mathematical Foundation)
    // ========================================
    
    /**
     * Professional LMSR (Logarithmic Market Scoring Rule) Implementation
     * Based on the mathematical foundation provided by Digital Ronin
     * 
     * Formula: C(q) = b * ln(Œ£ e^(q_j/b))
     * Price: p_i(q) = e^(q_i/b) / Œ£ e^(q_j/b)
     */
    class LMSREngine {
      constructor(liquidityParameter = 50) {
        this.b = liquidityParameter; // Larger b = deeper market, less price impact
        console.log(`üîÆ LMSR Engine initialized with liquidity parameter b=${this.b}`);
      }
      
      /**
       * Calculate the cost function C(q) = b * ln(Œ£ e^(q_j/b))
       * @param {number[]} q - Array of outstanding shares for each outcome
       * @param {number} b - Liquidity parameter (optional, uses instance default)
       * @returns {number} - Cost function value
       */
      cost(q, b = this.b) {
        const exps = q.map(x => Math.exp(x / b));
        const sum = exps.reduce((acc, val) => acc + val, 0);
        return b * Math.log(sum);
      }
      
      /**
       * Calculate instantaneous prices (probabilities) for all outcomes
       * @param {number[]} q - Array of outstanding shares for each outcome
       * @param {number} b - Liquidity parameter (optional)
       * @returns {number[]} - Array of probabilities (sum = 1)
       */
      prices(q, b = this.b) {
        const exps = q.map(x => Math.exp(x / b));
        const sum = exps.reduce((acc, val) => acc + val, 0);
        return exps.map(exp => exp / sum);
      }
      
      /**
       * Calculate cost to buy a delta vector of shares
       * @param {number[]} q - Current outstanding shares
       * @param {number[]} delta - Shares to buy (same length as q)
       * @param {number} b - Liquidity parameter (optional)
       * @returns {number} - Cost in BNB
       */
      costToBuy(q, delta, b = this.b) {
        if (q.length !== delta.length) {
          throw new Error('Share arrays must have same length');
        }
        const qNext = q.map((val, i) => val + (delta[i] || 0));
        return this.cost(qNext, b) - this.cost(q, b);
      }
      
      /**
       * Calculate cost to buy shares of a specific outcome
       * @param {number[]} q - Current outstanding shares
       * @param {number} outcomeIndex - Index of outcome to buy
       * @param {number} shareAmount - Number of shares to buy
       * @param {number} b - Liquidity parameter (optional)
       * @returns {number} - Cost in BNB
       */
      costToBuyOutcome(q, outcomeIndex, shareAmount, b = this.b) {
        const delta = new Array(q.length).fill(0);
        delta[outcomeIndex] = shareAmount;
        return this.costToBuy(q, delta, b);
      }
      
      /**
       * Calculate shares you get for a given BNB amount (reverse calculation)
       * Uses binary search to find optimal share purchase
       * @param {number[]} q - Current outstanding shares
       * @param {number} outcomeIndex - Index of outcome to buy
       * @param {number} bnbAmount - BNB to spend
       * @param {number} b - Liquidity parameter (optional)
       * @returns {number} - Number of shares you can buy
       */
      sharesToBuy(q, outcomeIndex, bnbAmount, b = this.b) {
        let low = 0;
        let high = bnbAmount * 10; // Upper bound estimate
        let tolerance = 0.0001;
        
        for (let iterations = 0; iterations < 100; iterations++) {
          const mid = (low + high) / 2;
          const cost = this.costToBuyOutcome(q, outcomeIndex, mid, b);
          
          if (Math.abs(cost - bnbAmount) < tolerance) {
            return mid;
          }
          
          if (cost < bnbAmount) {
            low = mid;
          } else {
            high = mid;
          }
        }
        
        return (low + high) / 2;
      }
      
      /**
       * Check if market is in neutral 50/50 state (for binary markets)
       * or balanced state (for multi-outcome markets)
       * @param {number[]} q - Outstanding shares
       * @returns {boolean} - True if market is balanced
       */
      isBalanced(q) {
        const prices = this.prices(q);
        const expectedPrice = 1 / q.length; // Equal probability for all outcomes
        const tolerance = 0.01; // 1% tolerance
        
        return prices.every(price => Math.abs(price - expectedPrice) < tolerance);
      }
      
      /**
       * Get market status description
       * @param {number[]} q - Outstanding shares
       * @returns {object} - Market analysis
       */
      analyzeMarket(q) {
        const prices = this.prices(q);
        const maxPrice = Math.max(...prices);
        const maxIndex = prices.indexOf(maxPrice);
        const dominantOutcome = maxIndex;
        const confidence = maxPrice * 100;
        const isNeutral = this.isBalanced(q);
        
        return {
          prices: prices.map(p => Math.round(p * 100)), // Convert to percentages
          dominantOutcome,
          confidence: Math.round(confidence),
          isNeutral,
          liquidityDepth: this.b,
          totalShares: q.reduce((sum, shares) => sum + shares, 0)
        };
      }
    }

    // Initialize global LMSR engine
    window.lmsrEngine = new LMSREngine(50); // Liquidity parameter b = 50
    
    /**
     * Helper function to get LMSR probabilities for market (backward compatibility)
     * This maintains compatibility with your existing code
     */
    async function getLMSRProbabilities(marketId) {
      try {
        const response = await fetch(`${API_BASE_URL}/markets/${marketId}/probabilities`);
        if (response.ok) {
          const data = await response.json();
          
          // If server provides shares data, use our LMSR engine for calculation
          if (data.shares && Array.isArray(data.shares)) {
            const analysis = window.lmsrEngine.analyzeMarket(data.shares);
            return {
              probabilities: analysis.prices,
              prices: window.lmsrEngine.prices(data.shares).map(p => p), // Price per share
              shares: data.shares,
              analysis: analysis
            };
          }
          
          return data; // Fallback to server-provided data
        }
      } catch (error) {
        console.warn('Failed to fetch LMSR probabilities:', error);
      }
      return null;
    }

    // ========================================
    // CHART ENGINE WITH LMSR INTEGRATION
    // ========================================
    // Define LMSRChartEngine fallback BEFORE any other code
    class LMSRChartEngineFallback {
      constructor() {
        console.log('Using fallback LMSRChartEngine - basic charts enabled');
        this.chartInstances = {}; // Track chart instances
      }
      
      destroyChart(chartId) {
        if (this.chartInstances[chartId]) {
          this.chartInstances[chartId].destroy();
          delete this.chartInstances[chartId];
        }
      }
      
      async createProbabilityChart(containerId, marketId) {
        console.log('Creating basic probability chart for market', marketId);
        const container = document.getElementById(containerId) || document.querySelector(`#${containerId}`);
        if (!container) return null;

        try {
          // Destroy existing chart if it exists
          this.destroyChart('probabilityChart');
          
          // Get market probabilities
          const response = await fetch(`${window.API_BASE_URL || '/api'}/markets/${marketId}/probabilities`);
          if (!response.ok) throw new Error('Failed to fetch probabilities');
          
          const data = await response.json();
          if (!data.probabilities || !data.prices) {
            throw new Error('No probability data available');
          }

          // Create fresh canvas
          container.innerHTML = '';
          const canvas = document.createElement('canvas');
          canvas.id = 'probabilityChart';
          canvas.width = container.offsetWidth || 400;
          canvas.height = container.offsetHeight || 300;
          container.appendChild(canvas);

          if (typeof Chart !== 'undefined') {
            const ctx = canvas.getContext('2d');
            
            // Get current market data
            const market = window.currentMarket;
            const labels = market?.options?.map(opt => opt.name) || ['Option 1', 'Option 2'];
            
            const chartInstance = new Chart(ctx, {
              type: 'line',
              data: {
                labels: ['Initial', 'Current'],
                datasets: data.probabilities.map((prob, index) => ({
                  label: labels[index] || `Option ${index + 1}`,
                  data: [50, prob], // Simple before/after
                  borderColor: ['#9aff00', '#ff6b6b', '#4ecdc4', '#45b7d1'][index] || '#9aff00',
                  backgroundColor: ['rgba(154,255,0,0.1)', 'rgba(255,107,107,0.1)', 'rgba(78,205,196,0.1)', 'rgba(69,183,209,0.1)'][index] || 'rgba(154,255,0,0.1)',
                  tension: 0.4
                }))
              },
              options: {
                responsive: true,
                plugins: {
                  legend: { labels: { color: '#ffffff' } },
                  title: { display: true, text: 'Market Confidence Over Time', color: '#ffffff' }
                },
                scales: {
                  y: { 
                    beginAtZero: true, 
                    max: 100,
                    ticks: { color: '#9ca3af' },
                    title: { display: true, text: 'Market Confidence (%)', color: '#9ca3af' }
                  },
                  x: { 
                    ticks: { color: '#9ca3af' } 
                  }
                }
              }
            });
            
            // Store chart instance for later cleanup
            this.chartInstances['probabilityChart'] = chartInstance;
          } else {
            container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#9ca3af;font-size:14px;">Chart.js not available</div>';
          }
        } catch (error) {
          console.error('Chart creation failed:', error);
          container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#ff6b6b;font-size:14px;">‚ö†Ô∏è Chart failed to load</div>';
        }
        return null;
      }
      
      async createCurrentDistributionChart(containerId, marketId) {
        console.log('Creating basic distribution chart for market', marketId);
        const container = document.getElementById(containerId) || document.querySelector(`#${containerId}`);
        if (!container) return null;

        try {
          // Destroy existing chart if it exists
          this.destroyChart('distributionChart');
          
          // Get market probabilities
          const response = await fetch(`${window.API_BASE_URL || '/api'}/markets/${marketId}/probabilities`);
          if (!response.ok) throw new Error('Failed to fetch probabilities');
          
          const data = await response.json();
          if (!data.probabilities || !data.prices) {
            throw new Error('No probability data available');
          }

          // Create fresh canvas
          container.innerHTML = '';
          const canvas = document.createElement('canvas');
          canvas.id = 'distributionChart';
          canvas.width = container.offsetWidth || 400;
          canvas.height = container.offsetHeight || 300;
          container.appendChild(canvas);

          if (typeof Chart !== 'undefined') {
            const ctx = canvas.getContext('2d');
            
            // Get current market data
            const market = window.currentMarket;
            const labels = market?.options?.map(opt => opt.name) || ['Option 1', 'Option 2'];
            
            const chartInstance = new Chart(ctx, {
              type: 'doughnut',
              data: {
                labels: labels,
                datasets: [{
                  data: data.probabilities,
                  backgroundColor: ['#9aff00', '#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b'],
                  borderColor: '#1a1a2e',
                  borderWidth: 2
                }]
              },
              options: {
                responsive: true,
                plugins: {
                  legend: { labels: { color: '#ffffff' } },
                  title: { display: true, text: 'Current Market Distribution', color: '#ffffff' }
                }
              }
            });
            
            // Store chart instance for later cleanup
            this.chartInstances['distributionChart'] = chartInstance;
          } else {
            container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#9ca3af;font-size:14px;">Chart.js not available</div>';
          }
        } catch (error) {
          console.error('Chart creation failed:', error);
          container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#ff6b6b;font-size:14px;">‚ö†Ô∏è Chart failed to load</div>';
        }
        return null;
      }
    }

    // Check if the real LMSRChartEngine loaded, if not use fallback
    if (typeof LMSRChartEngine === 'undefined') {
      console.warn('LMSRChartEngine not available, using fallback');
      window.LMSRChartEngine = LMSRChartEngineFallback;
    }

    // Initialize chart engine ALWAYS
    window.lmsrChartEngine = new (window.LMSRChartEngine || LMSRChartEngineFallback)();

    // Initialize Web3 and BSC connection
    let wallet = null;
    let bnbBalance = 0;
    let isAdmin = false;
    
    // BSC Configuration
    const TREASURY_WALLET = '0x7eCa382995Df91C250896c0EC73c9d2893F7800e';
    const BSC_MAINNET_CONFIG = {
      chainId: '0x38',
      chainName: 'Binance Smart Chain',
      nativeCurrency: { name: 'BNB', symbol: 'BNB', decimals: 18 },
      rpcUrls: ['https://bsc-dataseed1.binance.org/'],
      blockExplorerUrls: ['https://bscscan.com/'],
    };
  </script>
  
  <div id="loadingScreen" style="position:fixed;inset:0;background:#0b0b0f;display:flex;align-items:center;justify-content:center;z-index:9999;">
    <div style="text-align:center;color:#9aff00;">
      <div style="width:50px;height:50px;border:4px solid rgba(154,255,0,0.3);border-top-color:#9aff00;border-radius:50%;animation:spin 1s linear infinite;margin:0 auto 16px;"></div>
      <div style="font-size:18px;font-weight:700;">Loading BNBmarket...</div>
    </div>
  </div>
  <style>@keyframes spin{0%{transform:rotate(0deg);}100%{transform:rotate(360deg);}}</style>
  <script>
    window.addEventListener('DOMContentLoaded', () => {
      setTimeout(() => {
        document.getElementById('loadingScreen').style.display = 'none';
      }, 1000);
    });
  </script>
  
  <script>
    // API BASE URL LOGIC
    const API_BASE_URL = (function() {
      const { hostname } = window.location;
      if (hostname === 'localhost' || hostname === '127.0.0.1') {
        return 'http://localhost:3001/api';
      }
      if (hostname.endsWith('onrender.com')) {
        return `https://${hostname}/api`;
      }
      if (hostname === 'www.bnbmarket.cc') {
        return 'https://www.bnbmarket.cc/api';
      }
      if (hostname === 'bnbmarket.cc') {
        return 'https://bnbmarket.cc/api';
      }
      return window.location.origin + '/api';
    })();

    // Helper function to get odds from metadata.admin_odds ONLY
    // Helper function to get LMSR probabilities for market
    async function getLMSRProbabilities(marketId) {
      try {
        const response = await fetch(`${API_BASE_URL}/markets/${marketId}/probabilities`);
        if (response.ok) {
          return await response.json();
        }
      } catch (error) {
        console.warn('Failed to fetch LMSR probabilities:', error);
      }
      return null;
    }

    // Helper function to calculate implied odds from probability
    function probabilityToOdds(probability) {
      if (!probability || probability <= 0) return null;
      return 1 / probability;
    }

    // Helper function to get LMSR price per share for an option
    async function getLMSRPrice(market, optionIndex) {
      const probData = await getLMSRProbabilities(market.id);
      if (!probData || !probData.prices || !probData.prices[optionIndex]) {
        console.warn(`LMSR prices not available for option ${optionIndex}`);
        return 0.5; // Default fallback price
      }
      
      return probData.prices[optionIndex];
    }

    // Globals
    let walletAddress = null;
    let web3 = null; // Move web3 declaration here
    window.bnbBalance = 0;
    let currentOrderBook = null;
    let currentMarket = null;
    let selectedOutcome = 0;
    window.currentOrderBook = currentOrderBook;
    window.currentMarket = currentMarket;
    window.selectedOutcome = selectedOutcome;

    // Web3 initialization
    async function initializeWeb3() {
      try {
        if (!window.ethereum) {
          console.log('MetaMask not detected');
          return false;
        }
        
        web3 = new Web3(window.ethereum);
        
        // Check if wallet was previously connected
        const accounts = await window.ethereum.request({ method: 'eth_accounts' });
        if (accounts.length > 0) {
          walletAddress = accounts[0];
          // Check if this wallet is admin
          const adminWallet = '0x7eCa382995Df91C250896c0EC73c9d2893F7800e';
          isAdmin = walletAddress.toLowerCase() === adminWallet.toLowerCase();
          await updateBalance();
        }
        
        console.log('Successfully initialized Web3 connection');
        return true;
      } catch (error) {
        console.error('Failed to initialize Web3:', error);
        return false;
      }
    }

    // Wallet functions
    async function updateBalance() {
      if (!walletAddress || !web3) {
        document.getElementById('balanceDisplay').style.display = 'none';
        return;
      }
      try {
        const balance = await web3.eth.getBalance(walletAddress);
        window.bnbBalance = parseFloat(web3.utils.fromWei(balance, 'ether'));
        document.getElementById('bnbBalance').textContent = window.bnbBalance.toFixed(3);
        document.getElementById('balanceDisplay').style.display = '';
      } catch (e) {
        console.error('Balance update failed:', e);
        document.getElementById('balanceDisplay').style.display = 'none';
      }
    }

    function setWalletBtnConnected(addr) {
      const btn = document.getElementById('walletBtn');
      btn.textContent = addr.slice(0, 4) + '...' + addr.slice(-4);
      btn.classList.add('connected');
    }
    
    function setWalletBtnDisconnected() {
      const btn = document.getElementById('walletBtn');
      btn.textContent = window.i18n.t('connectWallet');
      btn.classList.remove('connected');
    }

    async function connectWallet() {
      if (!window.ethereum) {
        alert(window.i18n.t('metamaskNotFound'));
        window.open('https://metamask.io/', '_blank');
        return;
      }
      try {
        // Request account access
        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
        
        if (accounts.length === 0) {
          alert('No accounts found');
          return;
        }

        walletAddress = accounts[0];
        
        // Switch to BSC network if needed
        try {
          await window.ethereum.request({
            method: 'wallet_switchEthereumChain',
            params: [{ chainId: '0x38' }], // BSC Mainnet
          });
        } catch (switchError) {
          if (switchError.code === 4902) {
            try {
              await window.ethereum.request({
                method: 'wallet_addEthereumChain',
                params: [BSC_MAINNET_CONFIG],
              });
            } catch (addError) {
              console.error('Failed to add BSC network:', addError);
            }
          }
        }
        
        setWalletBtnConnected(walletAddress);
        await updateBalance();
        updateAdminTabVisibility();
      } catch (e) {
        console.error('Wallet connection failed:', e);
        setWalletBtnDisconnected();
      }
    }

    function disconnectWallet() {
      walletAddress = null;
      setWalletBtnDisconnected();
      document.getElementById('balanceDisplay').style.display = 'none';
    }

    function updateAdminTabVisibility() {
      const adminTab = document.getElementById('adminTab');
      const ADMIN_WALLET = '0x7eCa382995Df91C250896c0EC73c9d2893F7800e';
      if (walletAddress && walletAddress.toLowerCase() === ADMIN_WALLET.toLowerCase()) {
        if (adminTab) adminTab.style.display = '';
      } else {
        if (adminTab) adminTab.style.display = 'none';
      }
    }

    // Utility
    function getMarketId() {
      const params = new URLSearchParams(window.location.search);
      const id = params.get('id');
      return id ? parseInt(id) : null;
    }

    // UI Rendering
    async function renderMarketInfo(market) {
      document.getElementById('marketTitle').textContent = market.title;
      document.getElementById('marketMeta').textContent = `Category: ${market.category} | Created: ${new Date(market.created_at).toLocaleString()}`;
      
      let totalVolume = 0;
      try {
        const res = await fetch(`${API_BASE_URL}/bets?marketId=${market.id}`);
        if (res.ok) {
          const data = await res.json();
          if (Array.isArray(data.bets)) {
            totalVolume = data.bets.reduce((sum, b) => sum + (parseFloat(b.amount) || 0), 0);
          }
        }
      } catch (e) {
        if (window.currentOrderBook && Array.isArray(window.currentOrderBook)) {
          totalVolume = window.currentOrderBook.reduce((sum, b) => sum + (parseFloat(b.amount) || 0), 0);
        }
      }
      
      document.getElementById('marketVolume').innerHTML = `Total Volume: <span style='color:#10b981;'>${totalVolume.toFixed(3)} BNB</span>`;
      
      const optionsDiv = document.getElementById('marketOptions');
      optionsDiv.innerHTML = '';
      
      // Get LMSR probabilities for the market
      const probData = await getLMSRProbabilities(market.id);
      
      (market.options || []).forEach(async (opt, i) => {
        const el = document.createElement('div');
        el.className = 'option-tab' + (i===selectedOutcome?' active':'');
        el.style = 'background:#23263a;padding:10px 10px 4px 10px;border-radius:10px;min-width:80px;text-align:center;cursor:pointer;border:2px solid '+(i===selectedOutcome?'#9aff00':'#23263a')+';transition:border 0.2s;display:flex;flex-direction:column;align-items:center;justify-content:center;';
        
        let oddsDisplay = '';
        let probabilityDisplay = '';
        
        if (probData && probData.probabilities && probData.probabilities[i] !== undefined) {
          const probability = probData.probabilities[i];
          probabilityDisplay = `<div style='color:#10b981;font-size:0.9em;font-weight:600;margin-top:2px;'>${probability}% market confidence</div>`;
          // Show price per share instead of odds
          if (probData.prices && probData.prices[i]) {
            const pricePerShare = probData.prices[i];
            oddsDisplay = `<div style='color:#f59e0b;font-size:0.85em;font-weight:500;'>${pricePerShare.toFixed(3)} BNB/share</div>`;
          }
        } else {
          probabilityDisplay = `<div style='color:#9ca3af;font-size:0.85em;font-weight:600;margin-top:2px;'>Loading market data...</div>`;
        }
        
        el.innerHTML = `
          ${opt.image ? `<img src='${opt.image}' alt='' style='width:38px;height:38px;border-radius:50%;margin-bottom:6px;'>` : ''}
          <div style="font-size:1.05rem;font-weight:700;color:#9aff00;">${opt.name || 'Option ' + (i+1)}</div>
          ${probabilityDisplay}
          ${oddsDisplay}
        `;
        
        el.onclick = ()=>{
          selectedOutcome = i;
          renderMarketInfo(market);
          renderChart(market, currentOrderBook);
          renderOrderBookPro(currentOrderBook, market, selectedOutcome);
          updateTradePanel();
          calculateProfit();
        };
        optionsDiv.appendChild(el);
      });
      
      if (currentOrderBook && market.options) {
        let html = '<span style="color:#9ca3af;">Total Buys:</span> ';
        const totals = Array(market.options.length).fill(0);
        currentOrderBook.forEach(b=>{ if(b.option_id!==undefined) totals[b.option_id]+=1; });
        html += market.options.map((opt,i)=>`${opt.name}: <span style='color:#10b981;'>${totals[i]}</span>`).join(' &nbsp; ');
        document.getElementById('totalBuys').innerHTML = html;
      }
    }

    function renderOrderBookPro(orderBook, market, selectedOutcome) {
      const obDiv = document.getElementById('orderBook');
      
      if (!orderBook || orderBook.length === 0) {
        obDiv.innerHTML = '<div style="color:#9ca3af;">No bets yet.</div>';
        return;
      }
      
      const filtered = orderBook.filter(b => b.option_id === selectedOutcome);
      const bids = filtered;
      bids.sort((a,b) => parseFloat(b.amount) - parseFloat(a.amount));
      const maxShares = Math.max(...bids.map(x => parseFloat(x.amount)), 1);
      
      let tabs = '';
      (market.options||[]).forEach((opt,i)=>{
        tabs += `<button class="ob-tab${i===selectedOutcome?' active':''}" data-idx="${i}" style="background:${i===selectedOutcome?'#10b981':'#23263a'};color:${i===selectedOutcome?'#041':'#f3f4f6'};border:2px solid ${i===selectedOutcome?'#10b981':'#374151'};padding:8px 16px;border-radius:8px;font-weight:600;cursor:pointer;transition:all 0.2s;margin-right:6px;">${opt.name}</button>`;
      });
      
      async function rowHtml(order) {
        const barW = Math.max(8, 180*(parseFloat(order.amount)/maxShares));
        
        // Get current LMSR probabilities for potential return calculation
        const probData = await getLMSRProbabilities(market.id);
        let sharesOwned = 0;
        let potentialReturn = 0;
        
        if (probData && probData.prices && probData.prices[selectedOutcome]) {
          // Calculate shares owned: amount / price per share at time of purchase
          const executionPrice = order.execution_odds || probData.prices[selectedOutcome];
          sharesOwned = parseFloat(order.amount) / executionPrice;
          
          // Potential return is shares * probability of winning (max 1 BNB per share if wins)
          const winProbability = probData.probabilities[selectedOutcome] / 100;
          potentialReturn = sharesOwned * winProbability;
        } else {
          // Fallback calculation
          potentialReturn = parseFloat(order.amount) * 1.5;
        }
        
        let buyerCell = '-';
        if (order.transaction_signature) {
          const shortTx = order.transaction_signature.slice(0,4) + '...' + order.transaction_signature.slice(-4);
          buyerCell = `<a href="https://bscscan.com/tx/${order.transaction_signature}" target="_blank" rel="noopener" style="color:#10b981;font-weight:700;text-decoration:none;">${shortTx}</a>`;
        }
        return `<tr style="background:rgba(16,185,129,0.08);">
          <td style="position:relative;">
            <div style="position:absolute;left:0;top:0;height:100%;width:${barW}px;background:rgba(16,185,129,0.13);"></div>
            <span style="position:relative;z-index:2;font-weight:600;color:#10b981;">${parseFloat(order.amount).toFixed(3)}</span>
          </td>
          <td style="position:relative;z-index:2;">${buyerCell}</td>
          <td style="position:relative;z-index:2;color:#f3f4f6;">${sharesOwned.toFixed(1)} shares (${potentialReturn.toFixed(3)} BNB)</td>
        </tr>`;
      }
      
      let html = `<div style="display:flex;align-items:center;gap:18px;margin-bottom:12px;flex-wrap:wrap;">
        <h3 style="color:#9aff00;margin:0;font-size:1.3rem;">Order Book</h3>
        <div>${tabs}</div>
      </div>`;
      html += `<table style="width:100%;border-radius:10px;overflow:hidden;font-size:1rem;">
        <thead><tr style="background:#23263a;color:#10b981;font-weight:700;"><th style="padding:8px;">Amount (BNB)</th><th>Buyer</th><th>Shares & Potential Return</th></tr></thead>
        <tbody id="orderBookRows">`;
      
      html += '</tbody></table>';
      obDiv.innerHTML = html;
      
      // Render rows asynchronously
      const rowsContainer = document.getElementById('orderBookRows');
      Promise.all(bids.map(order => rowHtml(order))).then(rows => {
        rowsContainer.innerHTML = rows.join('');
      });
      
      obDiv.querySelectorAll('.ob-tab').forEach(btn=>{
        btn.onclick = ()=>{
          selectedOutcome = parseInt(btn.dataset.idx);
          renderOrderBookPro(orderBook,market,selectedOutcome);
        };
      });
    }

    async function updateTradePanel() {
      if (!currentMarket || !currentMarket.options) return;
      const opt = currentMarket.options[selectedOutcome];
      
      // Get LMSR probabilities
      const probData = await getLMSRProbabilities(currentMarket.id);
      let probabilityText = 'Loading market sentiment...';
      let pricePerShare = 0.5; // Default fallback price
      
      if (probData && probData.prices && probData.prices[selectedOutcome]) {
        const probability = probData.probabilities[selectedOutcome];
        pricePerShare = probData.prices[selectedOutcome];
        probabilityText = `${probability}% market confidence (based on community investments)`;
      }
      
      // Show price per share instead of odds
      let priceDisplay = '';
      if (probData && probData.prices && probData.prices[selectedOutcome]) {
        priceDisplay = `<span style='color:#f59e0b;font-size:1.08em;font-weight:700;margin-left:8px;'>${pricePerShare.toFixed(3)} BNB/share</span>`;
      } else {
        priceDisplay = `<span style='color:#9ca3af;font-size:0.95em;font-weight:700;margin-left:8px;'>Loading price...</span>`;
      }
      
      document.getElementById('tradeOptionName').innerHTML = `<span style='color:#9aff00;'>${opt.name}</span> ${opt.image?`<img src='${opt.image}' style='width:28px;height:28px;border-radius:50%;vertical-align:middle;margin-left:6px;'>`:''} ${priceDisplay}`;
      document.getElementById('tradeOdds').textContent = probabilityText;
      document.getElementById('tradeAmount').value = '';
      document.getElementById('tradeMsg').textContent = '';
      
      calculateProfit();
    }

    async function handleBuy() {
      const amt = parseFloat(document.getElementById('tradeAmount').value);
      if (!amt || amt<=0) {
        document.getElementById('tradeMsg').textContent = window.i18n.t('enterValidAmount');
        return;
      }
      if (!walletAddress || !web3) {
        document.getElementById('tradeMsg').textContent = window.i18n.t('connectWalletFirst');
        return;
      }
      
      if (!window.ethereum) {
        document.getElementById('tradeMsg').textContent = window.i18n.t('metamaskNotConnected');
        return;
      }
      
      // Get current LMSR data and calculate execution price
      const probData = await getLMSRProbabilities(currentMarket.id);
      let executionPrice = 0.5; // Fallback price per share
      let sharesReceived = 0;
      
      const platformFee = amt * 0.01;
      const netPurchaseAmount = amt - platformFee;
      
      // Use proper LMSR mathematics for execution
      if (probData && probData.shares && window.lmsrEngine && selectedOutcome !== null && selectedOutcome !== undefined) {
        try {
          // Calculate exact shares and average execution price using LMSR
          const currentShares = probData.shares;
          sharesReceived = window.lmsrEngine.sharesToBuy(currentShares, selectedOutcome, netPurchaseAmount);
          executionPrice = netPurchaseAmount / sharesReceived; // Average price per share for this purchase
          
          console.log(`üí∞ ${window.i18n.t('tradeExecution')}:
            ${window.i18n.t('purchaseAmount')}: ${amt} BNB
            ${window.i18n.t('netAmount')}: ${netPurchaseAmount} BNB
            ${window.i18n.t('sharesReceived')}: ${sharesReceived.toFixed(3)}
            ${window.i18n.t('avgExecutionPrice')}: ${executionPrice.toFixed(3)} BNB/share`);
          
        } catch (error) {
          console.warn('LMSR execution calculation failed, using fallback:', error);
          executionPrice = probData.prices?.[selectedOutcome] || 0.5;
          sharesReceived = netPurchaseAmount / executionPrice;
        }
      } else {
        // Fallback calculation
        executionPrice = probData?.prices?.[selectedOutcome] || 0.5;
        sharesReceived = netPurchaseAmount / executionPrice;
        console.log(`üí∞ ${window.i18n.t('fallbackExecution')}`);
      }
      
      document.getElementById('tradeMsg').textContent = window.i18n.t('processingPurchase');
      try {
        // Convert BNB amount to Wei (ensure it's a string)
        const amountInWei = web3.utils.toWei(amt.toString(), 'ether');
        
        // Create transaction to treasury wallet - ensure all values are strings
        const transaction = {
          from: walletAddress.toString(),
          to: TREASURY_WALLET.toString(),
          value: '0x' + BigInt(amountInWei).toString(16), // Convert to hex string using BigInt
          gas: '0x5208', // 21000 in hex
        };
        
        console.log('Sending transaction:', transaction);
        
        // Send transaction through MetaMask
        const transactionHash = await window.ethereum.request({
          method: 'eth_sendTransaction',
          params: [transaction],
        });
        
        console.log('Purchase transaction sent:', transactionHash);
        
        // Record purchase in database with proper LMSR execution data
        await fetch(`${API_BASE_URL}/bets`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            marketId: currentMarket.id,
            optionId: selectedOutcome,
            amount: amt,
            bettorAddress: walletAddress,
            transactionSignature: transactionHash,
            executionOdds: executionPrice, // Store average price per share for this trade
            sharesReceived: sharesReceived // Optional: store calculated shares for verification
          })
        });
        
        document.getElementById('tradeMsg').textContent = `${window.i18n.t('purchaseCompleted')} ${window.i18n.t('received')} ${sharesReceived.toFixed(3)} ${window.i18n.t('shares').toLowerCase()}.`;
        await updateBalance();
        if (typeof loadMarketPage === 'function') loadMarketPage();
      } catch (e) {
        console.error('Purchase transaction error:', e);
        document.getElementById('tradeMsg').textContent = `${window.i18n.t('purchaseFailed')}: ${e.message || e}`;
      }
    }

    async function handleCancelPurchase() {
      if (!walletAddress) {
        document.getElementById('tradeMsg').textContent = 'Connect your wallet first.';
        return;
      }
      document.getElementById('tradeMsg').textContent = 'Requesting cancellation...';
      try {
        await fetch(`${API_BASE_URL}/cancel`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            marketId: currentMarket.id,
            optionId: selectedOutcome,
            bettorAddress: walletAddress.toString()
          })
        });
        document.getElementById('tradeMsg').textContent = 'Cancellation request sent. Refunds are processed within 24 hours.';
      } catch (e) {
        document.getElementById('tradeMsg').textContent = 'Cancellation failed: ' + (e.message || e);
      }
    }

    // Chart switching functionality
    function switchChart(chartType) {
      // Update tab states
      document.querySelectorAll('.chart-tab').forEach(tab => tab.classList.remove('active'));
      document.getElementById(chartType + 'Tab').classList.add('active');
      
      // Show/hide chart containers
      document.getElementById('probabilityChartContainer').style.display = chartType === 'probability' ? 'block' : 'none';
      document.getElementById('distributionChartContainer').style.display = chartType === 'distribution' ? 'block' : 'none';
      
      // Load chart if not already loaded and chart engine is available
      if (currentMarket && window.lmsrChartEngine) {
        try {
          // Add a small delay to ensure container is visible
          setTimeout(() => {
            if (chartType === 'probability') {
              window.lmsrChartEngine.createProbabilityChart('probabilityChartContainer', currentMarket.id);
            } else if (chartType === 'distribution') {
              window.lmsrChartEngine.createCurrentDistributionChart('distributionChartContainer', currentMarket.id);
            }
          }, 100);
        } catch (error) {
          console.error('Chart creation failed:', error);
          const container = document.getElementById(chartType + 'ChartContainer');
          if (container) {
            container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#ff6b6b;font-size:14px;">‚ö†Ô∏è Chart failed to load</div>';
          }
        }
      }
    }

    // Updated chart rendering function
    function renderChart(market, orderBook) {
      // Only initialize probability chart once, with a delay to ensure DOM is ready
      if (window.lmsrChartEngine && !window.lmsrChartEngine.chartInstances['probabilityChart']) {
        setTimeout(() => {
          try {
            window.lmsrChartEngine.createProbabilityChart('probabilityChartContainer', market.id);
          } catch (error) {
            console.error('Chart initialization failed:', error);
            const container = document.getElementById('probabilityChartContainer');
            if (container) {
              container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#ff6b6b;font-size:14px;">‚ö†Ô∏è Chart failed to load</div>';
            }
          }
        }, 200);
      } else if (!window.lmsrChartEngine) {
        console.warn('Chart engine not available');
        const container = document.getElementById('probabilityChartContainer');
        if (container) {
          container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#9ca3af;font-size:14px;">üìä Charts temporarily unavailable</div>';
        }
      }
    }

    async function loadMarketPage() {
      const marketId = getMarketId();
      if (!marketId) {
        document.getElementById('marketSection').innerHTML = '<div style="color:#ef4444;">Invalid market ID.</div>';
        return;
      }
      
      try {
        // Fetch both market and bets data (there's no separate orderbook endpoint)
        const marketResponse = await fetch(`${API_BASE_URL}/markets/${marketId}`);
        if (!marketResponse.ok) throw new Error('Failed to fetch market');
        const marketData = await marketResponse.json();
        
        const betsResponse = await fetch(`${API_BASE_URL}/bets?marketId=${marketId}`);
        if (!betsResponse.ok) throw new Error('Failed to fetch bets');
        const betsData = await betsResponse.json();
        
        const market = marketData.market;
        const orderBook = betsData.bets || [];
        
        // CRITICAL: Force parse metadata - this is where odds are stored
        if (typeof market.metadata === 'string') {
          console.log('‚ö†Ô∏è Metadata came as string, parsing...');
          try {
            market.metadata = JSON.parse(market.metadata);
          } catch (e) {
            console.error('Failed to parse metadata:', e);
            market.metadata = {};
          }
        }
        
        if (!market.metadata || typeof market.metadata !== 'object') {
          console.log('‚ö†Ô∏è Metadata missing, creating empty object');
          market.metadata = {};
        }
        
        // Ensure admin_odds array exists
        if (!Array.isArray(market.metadata.admin_odds)) {
          console.warn('‚ö†Ô∏è admin_odds not found or not an array, initializing empty');
          market.metadata.admin_odds = [];
        }
        
        // Debug output
        console.log('========================================');
        console.log('‚úì MARKET LOADED');
        console.log('Market ID:', market.id);
        console.log('Market title:', market.title);
        console.log('Metadata type:', typeof market.metadata);
        console.log('Metadata:', market.metadata);
        console.log('Admin odds:', market.metadata.admin_odds);
        console.log('Admin odds is array?', Array.isArray(market.metadata.admin_odds));
        if (Array.isArray(market.metadata.admin_odds)) {
          market.metadata.admin_odds.forEach((odd, i) => {
            console.log(`  Option ${i}: odds = ${odd} (${typeof odd})`);
          });
        }
        console.log('========================================');
        
        // Set global variables
        currentMarket = market;
        currentOrderBook = orderBook;
        selectedOutcome = 0;
        window.currentMarket = currentMarket;
        window.currentOrderBook = currentOrderBook;
        window.selectedOutcome = selectedOutcome;
        
        // Render everything
        await renderMarketInfo(market);
        renderChart(market, orderBook);
        renderOrderBookPro(orderBook, market, 0);
        updateTradePanel();
        
        // Setup buttons
        document.getElementById('buyBtn').onclick = handleBuy;
        document.getElementById('cancelBtn').onclick = handleCancelPurchase;
        document.getElementById('tradeAmount').oninput = calculateProfit;
        
        // Load comments
        await loadCommentsForMarket(marketId);
        setupCommentBox(marketId);
        
      } catch (e) {
        console.error('Load market error:', e);
        document.getElementById('marketSection').innerHTML = `<div style='color:#ef4444;'>Error: ${e.message}</div>`;
      }
    }

    async function loadMyBets() {
      const container = document.getElementById('betsContainer');
      const portfolioSummaryContainer = document.getElementById('portfolioSummary');
      
      if (!walletAddress) {
        container.innerHTML = `<div class="empty-state"><h3>Connect Wallet</h3><p>Connect your wallet to view your betting history.</p></div>`;
        if (portfolioSummaryContainer) portfolioSummaryContainer.innerHTML = '';
        return;
      }
      
      try {
        const res = await fetch(`${API_BASE_URL}/bets?address=${walletAddress.toString()}`);
        const data = await res.json();
        const bets = data.bets || [];
        
        if (bets.length === 0) {
          container.innerHTML = `<div class="empty-state"><h3>No Bets Yet</h3><p>Your betting history will appear here once you place your first bet.</p></div>`;
          if (portfolioSummaryContainer) portfolioSummaryContainer.innerHTML = '';
        } else {
          // Portfolio summary variables
          let totalInvested = 0;
          let totalCurrentValue = 0;
          let totalShares = 0;
          let activeBets = 0;
          
          const betCards = await Promise.all(bets.map(async bet => {
            let optionName = '';
            let optionImage = '';
            let allOptions = [];
            let market = null;
            
            if (bet.optionId !== undefined && bet.market_id) {
              try {
                const res = await fetch(`${API_BASE_URL}/markets/${bet.market_id}`);
                if (res.ok) {
                  market = (await res.json()).market;
                  if (market && market.options) {
                    allOptions = market.options;
                    if (market.options[bet.optionId]) {
                      optionName = market.options[bet.optionId].name || '';
                      optionImage = market.options[bet.optionId].image || '';
                    }
                  }
                }
              } catch (error) {
                console.warn('Failed to load market option data:', error);
              }
            }

            // Calculate shares and PNL
            let sharesHtml = '';
            let pnlHtml = '';
            
            const originalAmount = parseFloat(bet.amount || 0);
            const platformFee = originalAmount * 0.01; // 1% platform fee
            const netInvestment = originalAmount - platformFee;
            const executionPrice = bet.execution_odds || 0.5; // Price per share at purchase
            const sharesOwned = executionPrice > 0 ? netInvestment / executionPrice : 0;
            
            // Update portfolio totals
            totalInvested += netInvestment;
            totalShares += sharesOwned;
            if (market && market.status !== 'resolved') activeBets++;
            
            if (sharesOwned > 0) {
              sharesHtml = `<div style="background:rgba(154,255,0,0.08);padding:8px 12px;border-radius:8px;margin:8px 0;">
                <div style="color:#9aff00;font-weight:700;font-size:1.05rem;">Portfolio Position</div>
                <div style="color:#e6eef8;margin:4px 0;">
                  <span style="color:#10b981;font-weight:600;">${sharesOwned.toFixed(1)}</span> shares @ 
                  <span style="color:#f59e0b;">${executionPrice.toFixed(3)} BNB/share</span>
                </div>
                <div style="color:#9ca3af;font-size:0.9rem;">Net Investment: ${netInvestment.toFixed(3)} BNB (after 1% fee)</div>
              </div>`;
              
              // Get current market probabilities for PNL calculation
              try {
                const probData = await getLMSRProbabilities(bet.market_id);
                if (probData && probData.prices && probData.prices[bet.optionId] !== undefined) {
                  const currentPrice = probData.prices[bet.optionId];
                  const currentProbability = probData.probabilities[bet.optionId];
                  const currentValue = sharesOwned * currentPrice;
                  const unrealizedPnL = currentValue - netInvestment;
                  const pnlPercentage = ((unrealizedPnL / netInvestment) * 100).toFixed(1);
                  
                  // Update total current value
                  totalCurrentValue += currentValue;
                  
                  const pnlColor = unrealizedPnL >= 0 ? '#10b981' : '#ff6b6b';
                  const pnlSign = unrealizedPnL >= 0 ? '+' : '';
                  
                  pnlHtml = `<div style="background:rgba(${unrealizedPnL >= 0 ? '16,185,129' : '255,107,107'},0.08);padding:8px 12px;border-radius:8px;margin:8px 0;">
                    <div style="color:${pnlColor};font-weight:700;font-size:1.05rem;">
                      ${unrealizedPnL >= 0 ? 'üìà' : 'üìâ'} P&L: ${pnlSign}${unrealizedPnL.toFixed(3)} BNB (${pnlSign}${pnlPercentage}%)
                    </div>
                    <div style="color:#e6eef8;margin:4px 0;">
                      Current Value: <span style="color:#f59e0b;">${currentValue.toFixed(3)} BNB</span> 
                      (${currentPrice.toFixed(3)} BNB/share)
                    </div>
                    <div style="color:#9ca3af;font-size:0.9rem;">
                      Market Confidence: ${currentProbability}% | 
                      ${market?.status === 'resolved' ? 'Market Resolved' : 'Live Market'}
                    </div>
                  </div>`;
                } else {
                  // Use fallback current value if no price data
                  totalCurrentValue += netInvestment; // Conservative estimate
                  pnlHtml = `<div style="background:rgba(156,163,175,0.08);padding:8px 12px;border-radius:8px;margin:8px 0;">
                    <div style="color:#9ca3af;font-size:0.95rem;">üìä Current market data loading...</div>
                  </div>`;
                }
              } catch (error) {
                console.warn('Failed to calculate PNL for bet:', error);
                totalCurrentValue += netInvestment; // Conservative estimate
                pnlHtml = `<div style="background:rgba(156,163,175,0.08);padding:8px 12px;border-radius:8px;margin:8px 0;">
                  <div style="color:#9ca3af;font-size:0.95rem;">‚ö†Ô∏è Unable to calculate current P&L</div>
                </div>`;
              }
            }
            
            let optionsHtml = '';
            if (allOptions.length > 0) {
              optionsHtml = `<div style="display:flex;gap:12px;margin-top:8px;">` +
                allOptions.map((opt, idx) => {
                  const picked = idx === bet.optionId;
                  return `<div style="display:flex;flex-direction:column;align-items:center;justify-content:center;padding:6px 10px;border-radius:10px;min-width:70px;background:${picked ? '#9aff00' : '#23263a'};color:${picked ? '#041' : '#bcd3e6'};border:2px solid ${picked ? '#9aff00' : '#23263a'};font-weight:${picked ? '800' : '600'};box-shadow:${picked ? '0 2px 8px rgba(154,255,0,0.13)' : 'none'};transition:all 0.2s;">
                    ${opt.image ? `<img src='${opt.image}' alt='' style='width:22px;height:22px;border-radius:50%;background:#181e29;margin-bottom:4px;'>` : ''}
                    <span style="font-size:1.01rem;">${opt.name || 'Option ' + (idx+1)}</span>
                    ${picked ? '<span style=\'margin-top:3px;font-size:0.92em;font-weight:700;color:#10b981;\'>&#10003; Picked</span>' : ''}
                  </div>`;
                }).join('') + `</div>`;
            } else if (optionName) {
              optionsHtml = `<span style='display:flex;align-items:center;gap:6px;background:#23263a;padding:4px 10px;border-radius:8px;border:1.5px solid #9aff00;font-weight:700;color:#9aff00;'>${optionImage ? `<img src='${optionImage}' alt='' style='width:22px;height:22px;border-radius:50%;background:#181e29;'>` : ''}<span>${optionName}</span></span>`;
            }
            
            return `<div class="admin-card" style="background:#23263a;margin-bottom:18px;padding:18px 16px;border-radius:12px;">
              <div class="market-title" style="font-weight:700;font-size:1.1rem;color:#9aff00;">${bet.market_title || 'Unknown Market'}</div>
              <div style="display:flex;align-items:center;gap:10px;margin:8px 0;"><span style="color: #10b981; font-weight: 700;">Original Purchase: ${originalAmount.toFixed(3)} BNB</span></div>
              ${optionsHtml}
              ${sharesHtml}
              ${pnlHtml}
              <div style="color: #9ca3af; font-size: 12px;margin-top:6px;">${new Date(bet.created_at).toLocaleDateString()}${bet.transaction_signature ? ` | <a href="https://bscscan.com/tx/${bet.transaction_signature}" target="_blank" style="color: #10b981;">View TX</a>` : ''}</div>
            </div>`;
          }));
          
          // Display portfolio summary
          const totalPnL = totalCurrentValue - totalInvested;
          const pnlPercentage = totalInvested > 0 ? ((totalPnL / totalInvested) * 100).toFixed(1) : '0.0';
          const pnlColor = totalPnL >= 0 ? '#10b981' : '#ff6b6b';
          const pnlSign = totalPnL >= 0 ? '+' : '';
          
          if (portfolioSummaryContainer) {
            portfolioSummaryContainer.innerHTML = `
              <div style="background:#23263a;padding:16px 20px;border-radius:12px;border:1.5px solid rgba(154,255,0,0.3);min-width:180px;">
                <div style="color:#9aff00;font-weight:700;font-size:0.9rem;margin-bottom:6px;">${window.i18n.t('totalInvested')}</div>
                <div style="color:#e6eef8;font-size:1.4rem;font-weight:800;">${window.i18n.formatCurrency(totalInvested)}</div>
              </div>
              <div style="background:#23263a;padding:16px 20px;border-radius:12px;border:1.5px solid rgba(245,158,11,0.3);min-width:180px;">
                <div style="color:#f59e0b;font-weight:700;font-size:0.9rem;margin-bottom:6px;">${window.i18n.t('currentValue')}</div>
                <div style="color:#e6eef8;font-size:1.4rem;font-weight:800;">${window.i18n.formatCurrency(totalCurrentValue)}</div>
              </div>
              <div style="background:#23263a;padding:16px 20px;border-radius:12px;border:1.5px solid ${totalPnL >= 0 ? 'rgba(16,185,129,0.3)' : 'rgba(255,107,107,0.3)'};min-width:180px;">
                <div style="color:${pnlColor};font-weight:700;font-size:0.9rem;margin-bottom:6px;">${window.i18n.t('totalPnL')}</div>
                <div style="color:${pnlColor};font-size:1.4rem;font-weight:800;">${pnlSign}${window.i18n.formatCurrency(totalPnL)}</div>
                <div style="color:${pnlColor};font-size:0.9rem;font-weight:600;">(${pnlSign}${pnlPercentage}%)</div>
              </div>
              <div style="background:#23263a;padding:16px 20px;border-radius:12px;border:1.5px solid rgba(156,163,175,0.3);min-width:160px;">
                <div style="color:#9ca3af;font-weight:700;font-size:0.9rem;margin-bottom:6px;">${window.i18n.t('portfolioStats')}</div>
                <div style="color:#e6eef8;font-size:1.1rem;font-weight:600;">${totalShares.toFixed(0)} ${window.i18n.t('shares')}</div>
                <div style="color:#e6eef8;font-size:1.1rem;font-weight:600;">${activeBets} ${window.i18n.t('activeBets')}</div>
              </div>
            `;
          }
          
          container.innerHTML = betCards.join('');
        }
      } catch (error) {
        container.innerHTML = `<div class="empty-state"><h3>Error Loading Bets</h3><p>${error.message}</p></div>`;
        if (portfolioSummaryContainer) portfolioSummaryContainer.innerHTML = '';
      }
    }

    async function loadCommentsForMarket(marketId) {
      let bets = [];
      try {
        const res = await fetch(`${API_BASE_URL}/bets?market_id=${marketId}`);
        if (res.ok) {
          const data = await res.json();
          bets = data.bets || [];
        }
      } catch (error) {
        console.warn('Failed to load user bets:', error);
      }
      
      let allComments = [];
      for (const bet of bets) {
        try {
          const res = await fetch(`${API_BASE_URL}/bets/${bet.id}/comments`);
          if (res.ok) {
            const data = await res.json();
            if (Array.isArray(data.comments)) {
              data.comments.forEach(c => c.bet = bet);
              allComments = allComments.concat(data.comments);
            }
          }
        } catch (error) {
        console.warn('Failed to load user bets:', error);
      }
      }
      
      allComments.sort((a,b) => new Date(a.created_at) - new Date(b.created_at));
      renderCommentsList(allComments);
    }

    function renderCommentsList(comments) {
      const listDiv = document.getElementById('commentsList');
      if (!comments || comments.length === 0) {
        listDiv.innerHTML = `<div style='color:#bcd3e6;'>No comments yet. Be the first to comment!</div>`;
        return;
      }
      listDiv.innerHTML = comments.map(c => {
        const shortAddr = c.user_address.slice(0,4) + '...' + c.user_address.slice(-4);
        const pfp = `<span style="display:inline-block;width:32px;height:32px;border-radius:50%;background:#23263a;margin-right:10px;text-align:center;line-height:32px;font-weight:700;font-size:1.1rem;color:#9aff00;">${c.user_address[0]}</span>`;
        const cleanText = removeLinks(escapeHtml(c.comment_text));
        return `<div style="display:flex;align-items:flex-start;gap:10px;margin-bottom:14px;">
          ${pfp}
          <div style="flex:1;">
            <a href="https://solscan.io/address/${c.user_address}" target="_blank" rel="noopener" style="font-weight:700;color:#9aff00;font-size:1.01rem;text-decoration:none;cursor:pointer;">${shortAddr}</a>
            <div style="color:#e6eef8;font-size:1.07rem;margin:2px 0 2px 0;white-space:pre-line;">${cleanText}</div>
            <div style="color:#bcd3e6;font-size:0.97rem;">${new Date(c.created_at).toLocaleString()}</div>
          </div>
        </div>`;
      }).join('');
    }

    function escapeHtml(text) {
      return text.replace(/[&<>"']/g, function(m) {
        return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'})[m];
      });
    }

    function removeLinks(text) {
      let cleaned = text.replace(/https?:\/\/\S+/gi, '').replace(/www\.[^\s]+/gi, '');
      cleaned = cleaned.replace(/\b[a-zA-Z0-9.-]+\.(com|net|org|io|xyz|app|link|to|me|co|site|info|gov|edu)\b/gi, '');
      return cleaned;
    }

    function setupCommentBox(marketId) {
      const commentBox = document.getElementById('commentBoxContainer');
      const loginMsg = document.getElementById('commentLoginMsg');
      const postBtn = document.getElementById('postCommentBtn');
      const commentInput = document.getElementById('commentInput');
      const commentMsg = document.getElementById('commentMsg');
      
      commentBox.style.display = 'none';
      loginMsg.textContent = '';
      
      if (!walletAddress || !walletAddress.toString) {
        loginMsg.textContent = 'Connect your wallet and place a bet to comment.';
        return;
      }
      
      fetch(`${API_BASE_URL}/bets?address=${walletAddress.toString()}&market_id=${marketId}`)
        .then(res => res.json())
        .then(data => {
          if (data.bets && data.bets.length > 0) {
            commentBox.style.display = '';
            loginMsg.textContent = '';
            postBtn.onclick = async () => {
              let text = commentInput.value.trim();
              if (!text) {
                commentMsg.textContent = 'Comment cannot be empty.';
                return;
              }
              text = removeLinks(text);
              const betId = data.bets[0].id;
              postBtn.disabled = true;
              commentMsg.textContent = 'Posting...';
              try {
                const res = await fetch(`${API_BASE_URL}/bets/${betId}/comments`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ user_address: walletAddress.toString(), comment_text: text })
                });
                const resp = await res.json();
                if (res.ok && resp.comment) {
                  commentInput.value = '';
                  commentMsg.textContent = 'Comment posted!';
                  await loadCommentsForMarket(marketId);
                } else {
                  commentMsg.textContent = resp.error || 'Failed to post comment.';
                }
              } catch (e) {
                commentMsg.textContent = 'Failed to post comment.';
              }
              postBtn.disabled = false;
            };
          } else {
            loginMsg.textContent = 'You must place a bet on this market to comment.';
          }
        });
    }

    async function calculateProfit() {
      const amt = parseFloat(document.getElementById('tradeAmount').value);
      
      const feeBreakdownEl = document.getElementById('feeBreakdown');
      const platformFeeEl = document.getElementById('platformFeeAmount');
      const netBetEl = document.getElementById('netBetAmount');
      
      if (!amt || amt <= 0) {
        document.getElementById('profitCalc').textContent = `${window.i18n.t('expectedReturn')}: 0.000 BNB`;
        if (feeBreakdownEl) feeBreakdownEl.style.display = 'none';
        return;
      }
      
      // Calculate 1% platform fee on purchase
      const platformFee = amt * 0.01;
      const netPurchaseAmount = amt - platformFee;
      
      // Show fee breakdown
      if (platformFeeEl) platformFeeEl.textContent = `${platformFee.toFixed(6)} BNB`;
      if (netBetEl) netBetEl.textContent = `${netPurchaseAmount.toFixed(3)} BNB`;
      if (feeBreakdownEl) feeBreakdownEl.style.display = 'block';
      
      // Get LMSR data for proper calculation
      const probData = await getLMSRProbabilities(currentMarket.id);
      let probability = 50; // Fallback probability
      let sharesReceived = 0;
      let priceImpact = 0;
      let newProbability = probability;
      
      // Use proper LMSR mathematics if we have share data
      if (probData && probData.shares && window.lmsrEngine && selectedOutcome !== null && selectedOutcome !== undefined) {
        try {
          // Current market state
          const currentShares = probData.shares;
          const currentPrices = window.lmsrEngine.prices(currentShares);
          probability = Math.round(currentPrices[selectedOutcome] * 100);
          
          // Calculate exact shares using LMSR engine
          sharesReceived = window.lmsrEngine.sharesToBuy(currentShares, selectedOutcome, netPurchaseAmount);
          
          // Calculate price impact (new probability after purchase)
          const newShares = [...currentShares];
          newShares[selectedOutcome] += sharesReceived;
          const newPrices = window.lmsrEngine.prices(newShares);
          newProbability = Math.round(newPrices[selectedOutcome] * 100);
          priceImpact = newProbability - probability;
          
          console.log(`üìä ${window.i18n.t('lmsrCalculation')}:
            ${window.i18n.t('currentShares')}: [${currentShares.join(', ')}]
            ${window.i18n.t('currentProbability')}: ${probability}%
            ${window.i18n.t('sharesToBuy')}: ${sharesReceived.toFixed(3)}
            ${window.i18n.t('newProbability')}: ${newProbability}%
            ${window.i18n.t('priceImpact')}: +${priceImpact}%`);
          
        } catch (error) {
          console.warn('LMSR calculation failed, using fallback:', error);
          // Fallback to simple calculation
          const fallbackPrice = probData.prices?.[selectedOutcome] || 0.5;
          sharesReceived = netPurchaseAmount / fallbackPrice;
          probability = probData.probabilities?.[selectedOutcome] || 50;
        }
      } else {
        // Fallback calculation for backward compatibility
        const fallbackPrice = probData?.prices?.[selectedOutcome] || 0.5;
        sharesReceived = netPurchaseAmount / fallbackPrice;
        probability = probData?.probabilities?.[selectedOutcome] || 50;
        console.log(`üìä ${window.i18n.t('fallbackCalculation')}`);
      }
      
      // Calculate returns
      const maxReturn = sharesReceived * 1.0; // Max 1 BNB per share if wins
      const expectedReturn = sharesReceived * (newProbability / 100); // Expected value based on new market sentiment
      const avgCostPerShare = netPurchaseAmount / sharesReceived;
      
      // Price impact warning
      let priceImpactWarning = '';
      if (priceImpact > 5) {
        priceImpactWarning = `<div style="color:#ff6b6b;font-size:0.9rem;margin-top:4px;background:rgba(255,107,107,0.1);padding:4px 8px;border-radius:4px;">‚ö†Ô∏è ${window.i18n.t('largeTradeWarning')}: +${priceImpact}% ${window.i18n.t('priceImpact')}</div>`;
      } else if (priceImpact > 0) {
        priceImpactWarning = `<div style="color:#f59e0b;font-size:0.9rem;margin-top:4px;">üìà ${window.i18n.t('priceImpact')}: +${priceImpact}%</div>`;
      }
      
      document.getElementById('profitCalc').innerHTML = `
        <div>${window.i18n.t('shares')}: <span style="color:#9aff00;">${sharesReceived.toFixed(3)}</span> @ ${window.i18n.formatCurrency(avgCostPerShare)}/share</div>
        <div>${window.i18n.t('currentConfidence')}: <span style="color:#f59e0b;">${probability}%</span> ‚Üí <span style="color:#10b981;">${newProbability}%</span></div>
        <div>${window.i18n.t('maxReturn')}: <span style="color:#10b981;">${window.i18n.formatCurrency(maxReturn)}</span> ${window.i18n.t('ifWins')} (1% ${window.i18n.t('payoutFeeApplies')})</div>
        <div>${window.i18n.t('expectedReturn')}: <span style="color:#f59e0b;">${window.i18n.formatCurrency(expectedReturn)}</span> (${newProbability}% ${window.i18n.t('finalConfidence')})</div>
        ${priceImpactWarning}
      `;
    }

    // Event listeners
    window.addEventListener('DOMContentLoaded', () => {
      const btn = document.getElementById('walletBtn');
      btn.onclick = () => {
        if (walletAddress) {
          if (confirm(window.i18n.t('disconnectConfirm'))) disconnectWallet();
        } else {
          connectWallet();
        }
      };

      // Language switcher functionality
      const langBtn = document.getElementById('langBtn');
      const langDropdown = document.getElementById('langDropdown');
      
      // Update language button display
      function updateLangBtn() {
        if (!window.i18n || !window.i18n.currentLanguage) {
          console.warn('I18n not initialized yet');
          return;
        }
        const currentLang = window.i18n.currentLanguage;
        const flag = currentLang === 'zh-CN' ? 'üá®üá≥' : 'üá∫üá∏';
        const code = currentLang === 'zh-CN' ? 'CN' : 'EN';
        langBtn.textContent = `${flag} ${code}`;
      }
      
      // Toggle language dropdown
      langBtn.onclick = (e) => {
        e.stopPropagation();
        langDropdown.style.display = langDropdown.style.display === 'none' ? 'block' : 'none';
      };
      
      // Hide dropdown when clicking outside
      document.addEventListener('click', () => {
        langDropdown.style.display = 'none';
      });
      
      // Language option handlers
      document.querySelectorAll('.lang-option').forEach(option => {
        option.onclick = () => {
          const lang = option.dataset.lang;
          window.i18n.switchLanguage(lang);
          updateLangBtn();
          langDropdown.style.display = 'none';
          
          // Update URL parameter
          const url = new URL(window.location);
          url.searchParams.set('lang', lang);
          window.history.replaceState({}, '', url);
        };
      });
      
      // Initialize language display
      if (window.i18n && window.i18n.currentLanguage) {
        updateLangBtn();
        window.i18n.updateAllTexts();
      } else {
        console.warn('I18n not ready during initialization');
      }

      // Navigation logic for My Bets
      const myBetsNavLink = document.getElementById('myBetsNavLink');
      if (myBetsNavLink) {
        myBetsNavLink.onclick = (e) => {
          e.preventDefault();
          showMyBetsSection();
        };
      }

      // Quick bet amount buttons
      document.querySelectorAll('.quick-btn').forEach(btn => {
        btn.addEventListener('click', function() {
          const amount = this.dataset.amount;
          if (amount) {
            document.getElementById('tradeAmount').value = amount;
            calculateProfit();
          }
        });
      });

      // Max button
      const maxBtn = document.querySelector('.quick-btn-max');
      if (maxBtn) {
        maxBtn.addEventListener('click', function() {
          if (window.bnbBalance) {
            document.getElementById('tradeAmount').value = window.bnbBalance.toFixed(2);
            calculateProfit();
          }
        });
      }

      // Initialize Web3 and MetaMask
      initializeWeb3();

      document.getElementById('tradeAmount').oninput = calculateProfit;
      loadMarketPage();
    });

    // Function to show My Bets section
    function showMyBetsSection() {
      // Hide market section
      const marketSection = document.getElementById('marketSection');
      if (marketSection) marketSection.style.display = 'none';
      
      // Show My Bets section
      const mybetsSection = document.getElementById('mybetsSection');
      if (mybetsSection) {
        mybetsSection.style.display = 'block';
        loadMyBets(); // Load the user's bets with shares and PNL
      }
      
      // Update navigation highlight
      document.querySelectorAll('.nav-link').forEach(link => link.classList.remove('active'));
      const myBetsNavLink = document.getElementById('myBetsNavLink');
      if (myBetsNavLink) myBetsNavLink.classList.add('active');
    }

    // Function to show market section (for returning from My Bets)
    function showMarketSection() {
      // Show market section
      const marketSection = document.getElementById('marketSection');
      if (marketSection) marketSection.style.display = 'block';
      
      // Hide My Bets section
      const mybetsSection = document.getElementById('mybetsSection');
      if (mybetsSection) mybetsSection.style.display = 'none';
      
      // Update navigation highlight
      document.querySelectorAll('.nav-link').forEach(link => link.classList.remove('active'));
    }

    // Make functions available globally
    window.calculateProfit = calculateProfit;
    window.switchChart = switchChart;
  </script>

  <footer style="text-align:center; margin: 32px 0 16px 0;">
    <a href="https://x.com/BNBmarketCC" target="_blank" rel="noopener" class="primary" style="text-decoration:none;font-weight:600;font-size:16px;">
      Follow us on Twitter/X &rarr; @BNBmarketCC
    </a>
  </footer>
</body>
</html>
