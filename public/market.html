<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BNB Market - Professional Trading</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inter:400,600,700&display=swap">
  <style>
    body {
      font-family: 'Inter', Arial, sans-serif;
      background: linear-gradient(135deg, #111827 0%, #374151 50%, #111827 100%) !important;
      color: #e5e7eb !important;
      margin: 0;
      padding: 0;
      min-height: 100vh;
    }
    .primary {
      color: #6b7280 !important;
    }
    .accent {
      color: #9ca3af !important;
    }
    .danger {
      color: #9ca3af;
    }
    .surface {
      background: linear-gradient(135deg, #374151, #1f2937) !important;
    }
    .btn {
      background: linear-gradient(135deg, #374151 0%, #4b5563 100%) !important;
      color: white !important;
      border: 2px solid #6b7280 !important;
      padding: 10px 16px;
      border-radius: 8px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      box-shadow: 0 4px 14px rgba(107,114,128,0.3) !important;
      transition: background 0.2s, color 0.2s, transform 0.2s, box-shadow 0.2s;
    }
    .btn:hover {
      background: linear-gradient(135deg, #4b5563 0%, #6b7280 100%) !important;
      color: white !important;
      box-shadow: 0 6px 20px rgba(107,114,128,0.4) !important;
      transform: translateY(-1px) scale(1.03);
    }
    .btn.secondary {
      background: rgba(55,65,81,0.3) !important;
      color: #9ca3af !important;
      border: 1.5px solid #374151 !important;
    }
    .btn.danger, .btn.danger:hover {
      background: linear-gradient(135deg, #374151 0%, #4b5563 100%) !important;
      color: #fff !important;
      border: 2px solid #6b7280 !important;
      box-shadow: 0 4px 14px rgba(107,114,128,0.3) !important;
    }
    .badge-success {
      background: rgba(107,114,128,0.2) !important;
      color: #6b7280 !important;
      border-radius: 6px;
      padding: 2px 10px;
      font-size: 0.95em;
      font-weight: 600;
      display: inline-block;
    }
    .badge-pending {
      background: rgba(156,163,175,0.2) !important;
      color: #9ca3af !important;
      border-radius: 6px;
      padding: 2px 10px;
      font-size: 0.95em;
      font-weight: 600;
      display: inline-block;
    }
    .border-accent {
      border: 1.5px solid #6b7280 !important;
    }
    .border-subtle {
      border: 1.5px solid rgba(55,65,81,0.3) !important;
    }
    .text-secondary {
      color: #9ca3af !important;
    }
    .text-warning {
      color: #9ca3af !important;
    }
    .text-error {
      color: #9ca3af;
    }
    .text-title {
      color: #e5e7eb !important;
    }
    
    /* Header Styles */
    .header {
      background: linear-gradient(135deg, #374151 0%, #111827 50%, #374151 100%) !important;
      backdrop-filter: blur(8px);
      border-bottom: 2px solid #4b5563 !important;
      padding: 16px 20px;
      position: sticky;
      top: 0;
      z-index: 40;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    
    .header-inner {
      max-width: 1200px;
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 20px;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 700;
      color: #e5e7eb !important;
      font-size: 20px;
      text-decoration: none;
    }

    .brand .logo {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: linear-gradient(45deg, #e5e7eb 50%, #111827 50%);
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .brand .logo::before {
      content: '';
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #111827;
      position: absolute;
      top: 5px;
    }

    .brand .logo::after {
      content: '';
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #e5e7eb;
      position: absolute;
      bottom: 5px;
    }

    .nav {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .nav a {
      padding: 10px 16px;
      border-radius: 8px;
      color: #d1d5db;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      text-decoration: none;
      transition: all 0.2s;
    }

    .nav a.active, .nav a:hover {
      color: #e5e7eb;
      background: rgba(156, 163, 175, 0.1);
    }

    .nav a.admin {
      background: rgba(156, 163, 175, 0.1);
      color: #9ca3af;
      border: 1px solid rgba(156, 163, 175, 0.2);
    }

    .wallet-group {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .balance {
      background: rgba(55, 65, 81, 0.3);
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid rgba(75, 85, 99, 0.4);
      font-size: 13px;
      font-weight: 600;
      color: #e5e7eb;
    }

    .wallet-btn {
      background: linear-gradient(135deg, #374151 0%, #4b5563 100%);
      color: #e5e7eb;
      border: none;
      padding: 10px 16px;
      border-radius: 8px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .wallet-btn:hover {
      transform: translateY(-1px);
      background: linear-gradient(135deg, #4b5563 0%, #6b7280 100%);
    }

    .wallet-btn.connected {
      background: transparent;
      border: 1px solid #9ca3af;
      color: #9ca3af;
    }

    /* Language Switcher Styles */
    .language-switcher {
      position: relative;
      display: inline-block;
    }

    .lang-btn:hover {
      background: rgba(156, 163, 175, 0.1);
      border-color: rgba(156, 163, 175, 0.3);
    }

    .lang-dropdown {
      min-width: 120px;
    }

    .lang-option:hover {
      background: rgba(156, 163, 175, 0.1);
      color: #9ca3af;
    }

    /* Chart Tab Styles */
    .chart-tab {
      background: transparent;
      border: none;
      color: #9ca3af;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .chart-tab:hover {
      color: #d1d5db;
      background: rgba(156, 163, 175, 0.1);
    }
    
    .chart-tab.active {
      color: #e5e7eb;
      background: rgba(156, 163, 175, 0.2);
      border: 1px solid rgba(156, 163, 175, 0.3);
    }

    /* Yin Yang Option Buttons - Contrasting Binary Choices */
    .option-tab.yang {
      background: linear-gradient(135deg, #f8fafc, #e2e8f0) !important;
      color: #1e293b !important;
      border: 2px solid #cbd5e1 !important;
      box-shadow: 0 4px 12px rgba(248, 250, 252, 0.2) !important;
    }
    
    .option-tab.yang:hover {
      background: linear-gradient(135deg, #e2e8f0, #cbd5e1) !important;
      color: #0f172a !important;
      border: 2px solid #94a3b8 !important;
      box-shadow: 0 6px 16px rgba(248, 250, 252, 0.3) !important;
      transform: translateY(-1px) scale(1.02);
    }
    
    .option-tab.yang.active {
      background: linear-gradient(135deg, #ffffff, #f1f5f9) !important;
      color: #0f172a !important;
      border: 2px solid #06b6d4 !important;
      box-shadow: 0 0 0 3px rgba(6, 182, 212, 0.2), 0 6px 20px rgba(6, 182, 212, 0.1) !important;
    }
    
    .option-tab.yin {
      background: linear-gradient(135deg, #1e293b, #334155) !important;
      color: #e2e8f0 !important;
      border: 2px solid #475569 !important;
      box-shadow: 0 4px 12px rgba(30, 41, 59, 0.3) !important;
    }
    
    .option-tab.yin:hover {
      background: linear-gradient(135deg, #334155, #475569) !important;
      color: #f8fafc !important;
      border: 2px solid #64748b !important;
      box-shadow: 0 6px 16px rgba(30, 41, 59, 0.4) !important;
      transform: translateY(-1px) scale(1.02);
    }
    
    .option-tab.yin.active {
      background: linear-gradient(135deg, #0f172a, #1e293b) !important;
      color: #f8fafc !important;
      border: 2px solid #9ca3af !important;
      box-shadow: 0 0 0 3px rgba(156, 163, 175, 0.2), 0 6px 20px rgba(156, 163, 175, 0.1) !important;
    }

    /* Enhanced Trade Panel with Yang Light Accent */
    .trade-card.yang-enhanced {
      background: linear-gradient(135deg, #f8fafc, #e2e8f0, #1f2937) !important;
      border: 2px solid #cbd5e1 !important;
      box-shadow: 0 0 0 1px rgba(6, 182, 212, 0.1), 0 8px 32px rgba(248, 250, 252, 0.08) !important;
    }

    /* Alternating Market Cards for Flow */
    .market-section.yang-flow {
      background: linear-gradient(135deg, #f8fafc, #e2e8f0, #cbd5e1) !important;
      color: #0f172a !important;
      border: 1px solid #cbd5e1 !important;
    }
    
    .market-section.yin-flow {
      background: linear-gradient(135deg, #0f172a, #1e293b, #334155) !important;
      color: #e2e8f0 !important;
      border: 1px solid #475569 !important;
    }

    /* Purchase Button Yang Enhancement */
    .btn.yang-primary {
      background: linear-gradient(135deg, #06b6d4, #0891b2) !important;
      color: #ffffff !important;
      border: 2px solid #0891b2 !important;
      box-shadow: 0 0 0 3px rgba(6, 182, 212, 0.1), 0 6px 20px rgba(6, 182, 212, 0.2) !important;
    }
    
    .btn.yang-primary:hover {
      background: linear-gradient(135deg, #0891b2, #0e7490) !important;
      box-shadow: 0 0 0 3px rgba(6, 182, 212, 0.2), 0 8px 24px rgba(6, 182, 212, 0.3) !important;
      transform: translateY(-2px) scale(1.03);
    }
  </style>
</head>
<body>
  <header class="header">
    <div class="header-inner">
      <a href="index.html" class="brand">
        <div class="logo"></div>
        <div>
          <div>BNB Market</div>
          <div style="font-size: 12px; color: #9ca3af; font-weight: 400;">Balance • Harmony • Truth</div>
        </div>
      </a>
      <nav class="nav">
        <a href="index.html" class="nav-link">Markets</a>
        <a href="index.html" class="nav-link" id="myBetsNavLink" data-i18n="myBets">My Bets</a>
        <a href="index.html" class="nav-link" data-i18n="treasury">Treasury</a>
        <a href="index.html" class="nav-link" data-i18n="howItWorks">How It Works</a>
        <a href="index.html" id="adminTab" class="nav-link admin" style="display:none" data-i18n="adminPanel">Admin Panel</a>
      </nav>
      <div class="wallet-group">
        <!-- Language Switcher -->
        <div class="language-switcher" style="margin-right:12px;">
          <button id="langBtn" class="lang-btn" style="background:rgba(55,65,81,0.3);border:1px solid rgba(75,85,99,0.4);color:#e5e7eb;padding:8px 12px;border-radius:6px;font-size:13px;cursor:pointer;transition:all 0.2s;">
            EN
          </button>
          <div id="langDropdown" class="lang-dropdown" style="display:none;position:absolute;top:100%;right:0;background:#374151;border:1px solid rgba(75,85,99,0.4);border-radius:8px;padding:4px;margin-top:4px;box-shadow:0 4px 12px rgba(0,0,0,0.3);z-index:1000;">
            <button class="lang-option" data-lang="en" style="display:block;width:100%;text-align:left;background:none;border:none;color:#e5e7eb;padding:8px 12px;border-radius:4px;cursor:pointer;font-size:13px;transition:background 0.2s;">English</button>
            <button class="lang-option" data-lang="zh-CN" style="display:block;width:100%;text-align:left;background:none;border:none;color:#e5e7eb;padding:8px 12px;border-radius:4px;cursor:pointer;font-size:13px;transition:background 0.2s;">中文</button>
          </div>
        </div>
        <div class="balance" id="balanceDisplay" style="display:none;">
          BNB: <span id="bnbBalance">0.000</span>
        </div>
        <button id="walletBtn" class="btn wallet-btn" data-i18n="connectWallet">Connect Wallet</button>
      </div>
    </div>
  </header>

  <main>
    <section id="marketSection" class="market-section yin-flow" style="max-width:1200px;margin:40px auto 0 auto;padding:40px 36px 48px 36px;background:linear-gradient(135deg, rgba(31,41,55,0.8), rgba(55,65,81,0.6));border-radius:22px;box-shadow:0 4px 40px rgba(0,0,0,0.3);border:1px solid #4b5563;position:relative;overflow:hidden;">
      <!-- Add subtle Yin Yang background pattern -->
      <!-- Professional background elements -->
      <div style="position:absolute;top:20px;right:30px;width:60px;height:60px;opacity:0.05;pointer-events:none;background:linear-gradient(135deg, rgba(156,163,175,0.3), transparent);border-radius:50%;"></div>
      <div style="position:absolute;bottom:20px;left:30px;width:40px;height:40px;opacity:0.03;pointer-events:none;background:linear-gradient(135deg, rgba(6,182,212,0.3), transparent);border-radius:50%;"></div>
      <div id="marketInfo">
        <h2 id="marketTitle" class="primary" style="margin-bottom:8px;font-size:2rem;font-weight:800;"></h2>
        <div id="marketMeta" style="color:#d1d5db;font-size:1rem;margin-bottom:8px;"></div>
        <div id="marketVolume" style="color:#06b6d4;font-size:1.08rem;font-weight:700;margin-bottom:8px;"></div>
        <div id="marketOptions" style="display:flex;gap:18px;margin-bottom:32px;"></div>
        <div id="totalBuys" style="color:#d1d5db;font-size:1.1rem;font-weight:600;margin-bottom:18px;"></div>
      </div>
      
      <div style="margin-bottom:32px;">
        <div style="display: flex; gap: 40px; align-items: flex-start; flex-wrap: wrap; width: 100%;">
          <div style="flex: 2.5; min-width: 420px; background: linear-gradient(135deg, #1f2937 0%, #374151 100%); border-radius: 18px; padding: 32px 24px 32px 24px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); border: 1px solid #4b5563; position: relative;">
            <!-- Subtle Yin Yang symbol in chart area -->
          <!-- Professional decorative element -->
          <div style="position:absolute;top:15px;right:20px;width:24px;height:24px;opacity:0.05;pointer-events:none;background:linear-gradient(135deg, rgba(6,182,212,0.3), transparent);border-radius:50%;"></div>
            
            <!-- Chart Tabs -->
            <div style="display: flex; gap: 8px; margin-bottom: 20px; border-bottom: 1px solid #4b5563; padding-bottom: 12px;">
              <button id="probabilityTab" class="chart-tab active" onclick="switchChart('probability')" data-i18n="marketConfidenceOverTime">Market Confidence Over Time</button>
              <button id="distributionTab" class="chart-tab" onclick="switchChart('distribution')" data-i18n="currentMarketDistribution">Current Market Distribution</button>
            </div>
            
            <!-- Chart Containers -->
            <div id="probabilityChartContainer" style="height: 300px; position: relative;">
              <canvas id="probabilityChart"></canvas>
            </div>
            <div id="distributionChartContainer" style="height: 300px; position: relative; display: none;">
              <canvas id="distributionChart"></canvas>
            </div>
          </div>
          
          <div class="trade-card yang-enhanced" style="background:linear-gradient(135deg, #1f2937, #374151);border:1.5px solid #4b5563;border-radius:18px;box-shadow:0 4px 32px rgba(75,85,99,0.3);padding:36px 32px 28px 32px;max-width:440px;width:100%;min-width:340px;margin-top:0;">
            <div style="display:flex;align-items:center;gap:12px;margin-bottom:10px;">
              <div id="tradeOptionName" style="color:#9ca3af;font-weight:800;font-size:1.15rem;display:flex;align-items:center;gap:8px;"></div>
            </div>
            <div id="tradeOdds" style="color:#9ca3af;font-size:1.05rem;margin-bottom:10px;font-weight:600;"></div>
            <div style="display:flex;gap:8px;margin-bottom:12px;">
              <button class="btn quick-btn" type="button" data-amount="0.1" style="flex:1;min-width:0;background:#374151;color:#9ca3af;border:1.5px solid #6b7280;">0.1</button>
              <button class="btn quick-btn" type="button" data-amount="0.5" style="flex:1;min-width:0;background:#374151;color:#9ca3af;border:1.5px solid #6b7280;">0.5</button>
              <button class="btn quick-btn" type="button" data-amount="1" style="flex:1;min-width:0;background:#374151;color:#9ca3af;border:1.5px solid #6b7280;">1</button>
              <button class="btn quick-btn-max" type="button" style="flex:1;min-width:0;background:#374151;color:#9ca3af;border:1.5px solid #6b7280;" title="Max">Max</button>
            </div>
            <input id="tradeAmount" type="number" min="0.007585445110418999" step="0.001" placeholder="Amount (BNB)" data-i18n-placeholder="amount" style="width:100%;padding:16px 14px;border-radius:10px;border:2px solid #6b7280;background:#1f2937;color:#e5e7eb;font-size:1.2rem;margin-bottom:10px;outline:none;box-shadow:none;">
            <div id="feeBreakdown" style="color:#d1d5db;font-size:0.95rem;margin-bottom:10px;font-weight:500;background:rgba(156,163,175,0.08);padding:6px 8px;border-radius:6px;display:none;">
              <span data-i18n="platformFee">Platform Fee</span> (1%): <span id="platformFeeAmount">0.000 BNB</span> | <span data-i18n="netInvestment">Net Investment</span>: <span id="netBetAmount">0.000 BNB</span>
            </div>
            <div id="profitCalc" style="color:#d1d5db;font-size:1.08rem;margin-bottom:14px;font-weight:600;background:rgba(156,163,175,0.07);padding:8px 10px;border-radius:8px;"></div>
            <div style="display:flex;gap:10px;margin-bottom:10px;align-items:flex-start;">
              <button id="buyBtn" class="btn yang-primary" style="flex:1;width:100%;font-size:1.08rem;padding:13px 0;box-shadow:0 2px 8px rgba(156,163,175,0.07);" data-i18n="buyShares">Buy</button>
            </div>
            <div style="display:flex;gap:10px;margin-bottom:10px;align-items:flex-start;">
              <button id="cancelBtn" class="btn" style="flex:1;width:100%;background:#ef4444;color:#fff;font-size:1.08rem;padding:13px 0;box-shadow:0 2px 8px rgba(239,68,68,0.13);border:1.5px solid #ef4444;" data-i18n="cancelPrediction">Cancel Prediction</button>
            </div>
            <hr style="border:none;border-top:1px solid #4b5563;margin:12px 0 10px 0;">
            <div id="tradeMsg" style="margin-top:0;color:#d1d5db;font-size:1.05rem;min-height:22px;font-weight:500;"></div>
          </div>
        </div>
        
        <!-- Enhanced Yin Yang Order Book -->
        <div id="yinYangOrderBook" style="margin-top:40px;background:linear-gradient(135deg, #0f172a, #1e293b);border-radius:18px;padding:32px 24px;box-shadow:0 4px 32px rgba(0,0,0,0.2);border:1px solid #334155;position:relative;">
          <!-- Yin Yang background symbol -->
          <!-- Professional background accent -->
          <div style="position:absolute;top:20px;right:30px;width:32px;height:32px;opacity:0.04;pointer-events:none;background:linear-gradient(135deg, rgba(6,182,212,0.3), transparent);border-radius:50%;"></div>
          
          <div style="margin-bottom:24px;">
            <div style="display:flex;align-items:center;gap:12px;margin-bottom:8px;">
              <div style="width:40px;height:40px;border-radius:50%;background:linear-gradient(45deg, #f8fafc, #9ca3af);"></div>
              <div>
                <h2 style="color:#f8fafc;font-size:1.5rem;font-weight:800;margin:0;">Order Book</h2>
                <p style="color:#94a3b8;font-size:0.9rem;margin:0;">Professional Trading Interface</p>
              </div>
            </div>
          </div>

          <!-- Market Info Header -->
          <div style="background:rgba(51,65,85,0.3);border:1px solid #475569;border-radius:12px;padding:24px;margin-bottom:24px;">
            <h3 style="color:#f8fafc;font-size:1.25rem;font-weight:700;margin-bottom:8px;">Market Outcome Ranges</h3>
            <p style="color:#94a3b8;font-size:0.9rem;margin-bottom:16px;">Select an outcome range to place your prediction</p>
            <div style="display:grid;grid-template-columns:2fr 1fr 2fr;gap:32px;font-size:0.85rem;color:#64748b;font-weight:600;">
              <span style="color:#06b6d4;">OUTCOME</span>
              <span style="text-align:center;color:#d1d5db;">% CHANCE</span>
              <span style="text-align:right;color:#d1d5db;">ACTIONS</span>
            </div>
          </div>

          <!-- Order Book Entries -->
          <div id="orderBookEntries" style="display:flex;flex-direction:column;gap:8px;">
            <!-- Will be populated by JavaScript -->
          </div>

          <!-- Selection Feedback -->
          <div id="selectionFeedback" style="margin-top:24px;background:rgba(51,65,85,0.3);border:1px solid #475569;border-radius:12px;padding:16px;display:none;">
            <div style="font-size:0.9rem;color:#94a3b8;">
              Last selection: <span id="selectedRange" style="color:#f8fafc;font-weight:700;"></span> • 
              <span id="selectedSide" style="color:#f8fafc;"></span> • 
              <span id="selectedPrice" style="color:#06b6d4;"></span>
            </div>
          </div>
        </div>
        
        <div id="orderBook" style="margin-top:32px;"></div>
      </div>
      
      <!-- Polymarket-style Trade Panel -->
      <div id="tradePanelContainer" style="
        position: fixed;
        bottom: 0;
        right: 0;
        width: 400px;
        background: linear-gradient(135deg, #0f172a, #1e293b);
        border: 1px solid #334155;
        border-radius: 16px 16px 0 0;
        box-shadow: 0 -4px 32px rgba(0,0,0,0.3);
        transform: translateY(100%);
        transition: transform 0.3s ease;
        z-index: 10000;
        max-height: 500px;
        overflow-y: auto;
      ">
        <div style="padding: 24px;">
          <!-- Panel Header -->
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 id="tradePanelTitle" style="color: #f8fafc; margin: 0; font-size: 1.2rem; font-weight: 700;">
              Select an outcome to trade
            </h3>
            <button onclick="window.enhancedOrderBook.closeTradePanel()" style="
              background: none; 
              border: none; 
              color: #94a3b8; 
              font-size: 1.5rem; 
              cursor: pointer;
              padding: 4px;
            ">×</button>
          </div>

          <!-- Trade Panel Content -->
          <div id="tradePanelContent" style="display: none;">
            <!-- Selected Outcome Info -->
            <div id="selectedOutcomeInfo" style="
              background: rgba(51,65,85,0.3);
              border-radius: 12px;
              padding: 16px;
              margin-bottom: 20px;
            ">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <span id="selectedOutcomeName" style="color: #f8fafc; font-weight: 700; font-size: 1.1rem;"></span>
                <span id="selectedOutcomePrice" style="color: #06b6d4; font-weight: 800; font-size: 1.2rem;"></span>
              </div>
              <div style="color: #94a3b8; font-size: 0.9rem;">
                <span id="selectedOutcomeProbability"></span> • 
                <span id="selectedOutcomeOdds"></span>
              </div>
            </div>

            <!-- Buy/Sell Toggle -->
            <div style="display: flex; margin-bottom: 20px; background: rgba(51,65,85,0.3); border-radius: 8px; padding: 4px;">
              <button id="buyToggle" onclick="window.enhancedOrderBook.selectTradeSide('buy')" style="
                flex: 1;
                padding: 12px;
                background: linear-gradient(135deg, #10b981, #059669);
                color: white;
                border: none;
                border-radius: 6px;
                font-weight: 700;
                cursor: pointer;
                transition: all 0.2s;
              ">Buy</button>
              <button id="sellToggle" onclick="window.enhancedOrderBook.selectTradeSide('sell')" style="
                flex: 1;
                padding: 12px;
                background: transparent;
                color: #94a3b8;
                border: none;
                border-radius: 6px;
                font-weight: 700;
                cursor: pointer;
                transition: all 0.2s;
                margin-left: 4px;
              ">Sell</button>
            </div>

            <!-- Amount Input -->
            <div style="margin-bottom: 20px;">
              <label style="color: #94a3b8; display: block; margin-bottom: 8px; font-weight: 600;">
                Amount (BNB)
              </label>
              <input id="tradePanelAmount" type="number" min="0.007585445110418999" step="0.001" placeholder="0.00" style="
                width: 100%;
                padding: 14px 16px;
                background: rgba(51,65,85,0.5);
                border: 1px solid #475569;
                border-radius: 8px;
                color: #f8fafc;
                font-size: 1.1rem;
                font-weight: 600;
              ">
              <div style="display: flex; gap: 8px; margin-top: 8px;">
                <button onclick="document.getElementById('tradePanelAmount').value = '1'" style="
                  padding: 6px 12px;
                  background: rgba(100,116,139,0.2);
                  border: 1px solid #475569;
                  border-radius: 6px;
                  color: #94a3b8;
                  font-size: 0.85rem;
                  cursor: pointer;
                ">1 BNB</button>
                <button onclick="document.getElementById('tradePanelAmount').value = '5'" style="
                  padding: 6px 12px;
                  background: rgba(100,116,139,0.2);
                  border: 1px solid #475569;
                  border-radius: 6px;
                  color: #94a3b8;
                  font-size: 0.85rem;
                  cursor: pointer;
                ">5 BNB</button>
                <button onclick="document.getElementById('tradePanelAmount').value = '10'" style="
                  padding: 6px 12px;
                  background: rgba(100,116,139,0.2);
                  border: 1px solid #475569;
                  border-radius: 6px;
                  color: #94a3b8;
                  font-size: 0.85rem;
                  cursor: pointer;
                ">10 BNB</button>
              </div>
            </div>

            <!-- Trade Summary -->
            <div id="tradeSummary" style="
              background: rgba(6,182,212,0.1);
              border: 1px solid rgba(6,182,212,0.3);
              border-radius: 8px;
              padding: 16px;
              margin-bottom: 20px;
            ">
              <div style="color: #e2e8f0; font-size: 0.9rem; line-height: 1.5;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                  <span>Shares to receive:</span>
                  <span id="sharesToReceive" style="color: #06b6d4; font-weight: 700;">0.000</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                  <span>If correct, you get:</span>
                  <span id="potentialPayout" style="color: #10b981; font-weight: 700;">0.000 BNB</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                  <span>Potential profit:</span>
                  <span id="potentialProfit" style="color: #10b981; font-weight: 700;">+0.000 BNB (0%)</span>
                </div>
              </div>
            </div>

            <!-- Place Trade Button -->
            <button id="placeTradeBtn" onclick="window.enhancedOrderBook.executePanelTrade()" style="
              width: 100%;
              padding: 16px;
              background: linear-gradient(135deg, #06b6d4, #0891b2);
              color: white;
              border: none;
              border-radius: 8px;
              font-weight: 700;
              font-size: 1.1rem;
              cursor: pointer;
              transition: all 0.2s;
            ">
              Place Trade
            </button>
          </div>
        </div>
      </div>
      
      <!-- Comment Section -->
      <section id="commentSection" style="margin-top:40px;background:linear-gradient(135deg, #0f172a, #1e293b);border-radius:16px;padding:28px 24px 18px 24px;box-shadow:0 2px 16px rgba(16,185,129,0.07);max-width:700px;margin-left:auto;margin-right:auto;border:1px solid #334155;position:relative;">
        <!-- Yin symbol for comments -->
        <div style="position:absolute;top:15px;right:20px;font-size:1.5rem;opacity:0.08;color:#9ca3af;pointer-events:none;">🌙</div>
        
        <h3 style="color:#d1d5db;margin-bottom:10px;font-size:1.25rem;font-weight:700;" data-i18n="comments">Comments</h3>
        <div id="commentsList" style="margin-bottom:18px;"></div>
        <div id="commentBoxContainer" style="display:none;">
          <textarea id="commentInput" rows="3" maxlength="300" placeholder="Write a comment..." data-i18n-placeholder="writeComment" style="width:100%;padding:12px 10px;border-radius:8px;border:1.5px solid #475569;background:#1e293b;color:#e6eef8;font-size:1.08rem;resize:vertical;margin-bottom:8px;"></textarea>
          <div style="display:flex;align-items:center;justify-content:space-between;">
            <span id="commentWarning" style="color:#fbbf24;font-size:0.98rem;" data-i18n="warningScammers">Do not click any links beware of scammers.</span>
            <button id="postCommentBtn" class="btn yang-primary" style="padding:8px 18px;font-size:1rem;" data-i18n="postComment">Post</button>
          </div>
          <div id="commentMsg" style="color:#ff6b6b;font-size:0.98rem;margin-top:6px;min-height:18px;"></div>
        </div>
        <div id="commentLoginMsg" style="color:#bcd3e6;font-size:1.05rem;margin-top:8px;"></div>
      </section>
    </section>

    <!-- My Bets Section -->
    <section id="mybetsSection" class="market-section yang-flow" style="display:none;max-width:900px;margin:40px auto 0 auto;padding:32px 24px 40px 24px;background:linear-gradient(180deg, rgba(248,250,252,0.1), rgba(226,232,240,0.08), rgba(31,41,55,0.6));border-radius:18px;box-shadow:0 4px 32px rgba(0,0,0,0.10);border:1px solid rgba(203,213,225,0.1);position:relative;">
      <!-- Subtle Yang background symbol -->
      <div style="position:absolute;top:25px;right:30px;font-size:2.5rem;opacity:0.06;color:#06b6d4;pointer-events:none;">☀️</div>>
      <div class="section-header" style="margin-bottom:24px;">
        <h2 class="section-title" style="color:#d1d5db;font-size:2rem;font-weight:800;margin-bottom:12px;" data-i18n="myBettingPortfolio">My Betting Portfolio</h2>
        <div id="portfolioSummary" style="display:flex;gap:20px;flex-wrap:wrap;margin-bottom:16px;">
          <!-- Portfolio summary will be populated by JavaScript -->
        </div>
      </div>
      <div id="betsContainer">
        <div class="empty-state">
          <h3 data-i18n="connectWalletToBets">Connect Wallet</h3>
          <p data-i18n="connectWalletToView">Connect your wallet to view your betting history.</p>
        </div>
      </div>
    </section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
  <script src="odds-engine.js" onerror="console.warn('Failed to load odds-engine.js')"></script>
  <!-- <script src="lmsr-charts.js" onerror="console.warn('Failed to load lmsr-charts.js - using fallback')"></script> -->
  <script>
    // ========================================
    // API CONFIGURATION
    // ========================================
    
    // API BASE URL LOGIC - Must be defined first
    const API_BASE_URL = (function() {
      const { hostname } = window.location;
      if (hostname === 'localhost' || hostname === '127.0.0.1') {
        return 'http://localhost:10000/api';
      }
      if (hostname.endsWith('onrender.com')) {
        return `https://${hostname}/api`;
      }
      if (hostname === 'www.bnbmarket.cc') {
        return 'https://www.bnbmarket.cc/api';
      }
      if (hostname === 'bnbmarket.cc') {
        return 'https://bnbmarket.cc/api';
      }
      return window.location.origin + '/api';
    })();
    
    // ========================================
    // INTERNATIONALIZATION SYSTEM
    // ========================================
    
    /**
     * Translation data for BNBmarket
     * Supporting English (en) and Simplified Chinese (zh-CN)
     */
    const translations = {
      en: {
        // Navigation
        markets: "Markets",
        myBets: "My Bets",
        treasury: "Treasury",
        howItWorks: "How It Works",
        adminPanel: "Admin Panel",
        connectWallet: "Connect Wallet",
        disconnect: "Disconnect",
        
        // Market Info
        category: "Category",
        created: "Created",
        totalVolume: "Total Volume",
        totalBuys: "Total Buys",
        
        // Trading
        buyShares: "Buy",
        cancelPrediction: "Cancel Prediction",
        requestRefund: "Cancel Prediction",
        amount: "Amount",
        platformFee: "Platform Fee",
        netInvestment: "Net Investment",
        shares: "Shares",
        maxReturn: "Max Return",
        expectedReturn: "Expected Return",
        currentConfidence: "Current Confidence",
        finalConfidence: "final confidence",
        priceImpact: "Price impact",
        largeTradeWarning: "Large trade",
        ifWins: "if wins",
        payoutFeeApplies: "payout fee applies",
        
        // Portfolio
        portfolioPosition: "Portfolio Position",
        myBettingPortfolio: "My Betting Portfolio",
        totalInvested: "Total Invested",
        currentValue: "Current Value",
        totalPnL: "Total P&L",
        portfolioStats: "Portfolio Stats",
        activeBets: "Active Bets",
        originalPurchase: "Original Purchase",
        marketConfidence: "Market Confidence",
        liveMarket: "Live Market",
        marketResolved: "Market Resolved",
        
        // Status Messages
        connectWalletFirst: "Please connect your wallet first",
        enterValidAmount: "Enter a valid amount",
        processingPurchase: "Processing purchase...",
        purchaseCompleted: "Purchase completed!",
        purchaseFailed: "Purchase failed",
        received: "Received",
        cancellationRequested: "Prediction cancellation requested. Refunds are processed within 24 hours.",
        cancellationFailed: "Cancellation failed",
        
        // My Bets Section
        connectWalletToBets: "Connect Wallet",
        connectWalletToView: "Connect your wallet to view your betting history.",
        noBetsYet: "No Bets Yet",
        noBetsDescription: "Your betting history will appear here once you place your first bet.",
        errorLoadingBets: "Error Loading Bets",
        picked: "Picked",
        viewTx: "View TX",
        
        // Chart Labels
        marketConfidenceOverTime: "Market Confidence Over Time",
        currentMarketDistribution: "Current Market Distribution",
        chartLoadingError: "Chart failed to load",
        chartTempUnavailable: "Charts temporarily unavailable",
        currentMarketDataLoading: "Current market data loading...",
        unableToCalculatePnL: "Unable to calculate current P&L",
        
        // Comments
        comments: "Comments",
        writeComment: "Write a comment...",
        postComment: "Post",
        noCommentsYet: "No comments yet. Be the first to comment!",
        warningScammers: "Do not click any links beware of scammers.",
        commentEmpty: "Comment cannot be empty.",
        posting: "Posting...",
        commentPosted: "Comment posted!",
        failedToPost: "Failed to post comment.",
        mustPlaceBet: "You must place a bet on this market to comment.",
        
        // Errors and Warnings
        invalidMarketId: "Invalid market ID.",
        failedToFetchMarket: "Failed to fetch market",
        failedToFetchBets: "Failed to fetch bets",
        metamaskNotFound: "MetaMask wallet not found! Please install MetaMask.",
        metamaskNotConnected: "MetaMask not connected. Please reconnect.",
        disconnectConfirm: "Disconnect wallet?",
        
        // Time and Dates
        today: "Today",
        yesterday: "Yesterday",
        daysAgo: "days ago",
        
        // LMSR Messages
        lmsrCalculation: "LMSR Calculation",
        currentShares: "Current shares",
        currentProbability: "Current probability",
        sharesToBuy: "Shares to buy",
        newProbability: "New probability",
        fallbackCalculation: "Using fallback calculation (no LMSR data available)",
        tradeExecution: "LMSR Trade Execution",
        purchaseAmount: "Purchase amount",
        netAmount: "Net amount",
        sharesReceived: "Shares received",
        avgExecutionPrice: "Avg execution price",
        fallbackExecution: "Using fallback execution calculation"
      },
      
      'zh-CN': {
        // Navigation
        markets: "市场",
        myBets: "我的投注",
        treasury: "资金库",
        howItWorks: "工作原理",
        adminPanel: "管理面板",
        connectWallet: "连接钱包",
        disconnect: "断开连接",
        
        // Market Info  
        category: "类别",
        created: "创建时间",
        totalVolume: "总交易量",
        totalBuys: "总购买数",
        
        // Trading
        buyShares: "购买",
        cancelPrediction: "取消预测",
        requestRefund: "取消预测",
        amount: "金额",
        platformFee: "平台费用",
        netInvestment: "净投资",
        shares: "份额",
        maxReturn: "最大回报",
        expectedReturn: "预期回报",
        currentConfidence: "当前置信度",
        finalConfidence: "最终置信度",
        priceImpact: "价格影响",
        largeTradeWarning: "大额交易",
        ifWins: "如果获胜",
        payoutFeeApplies: "支付费用适用",
        
        // Portfolio
        portfolioPosition: "投资组合仓位",
        myBettingPortfolio: "我的投注组合",
        totalInvested: "总投资",
        currentValue: "当前价值",
        totalPnL: "总盈亏",
        portfolioStats: "组合统计",
        activeBets: "活跃投注",
        originalPurchase: "原始购买",
        marketConfidence: "市场置信度",
        liveMarket: "实时市场",
        marketResolved: "市场已结算",
        
        // Status Messages
        connectWalletFirst: "请先连接您的钱包",
        enterValidAmount: "请输入有效金额",
        processingPurchase: "处理购买中...",
        purchaseCompleted: "购买完成！",
        purchaseFailed: "购买失败",
        received: "已收到",
        cancellationRequested: "取消请求已发送。退款将在24小时内处理。",
        cancellationFailed: "取消失败",
        
        // My Bets Section
        connectWalletToBets: "连接钱包",
        connectWalletToView: "连接您的钱包以查看投注历史。",
        noBetsYet: "暂无投注",
        noBetsDescription: "您的投注历史将在您下第一笔投注后显示在这里。",
        errorLoadingBets: "加载投注错误",
        picked: "已选择",
        viewTx: "查看交易",
        
        // Chart Labels
        marketConfidenceOverTime: "市场置信度随时间变化",
        currentMarketDistribution: "当前市场分布",
        chartLoadingError: "图表加载失败",
        chartTempUnavailable: "图表暂时不可用",
        currentMarketDataLoading: "当前市场数据加载中...",
        unableToCalculatePnL: "无法计算当前盈亏",
        
        // Comments
        comments: "评论",
        writeComment: "写评论...",
        postComment: "发布",
        noCommentsYet: "暂无评论。成为第一个评论的人！",
        warningScammers: "请勿点击任何链接，谨防诈骗。",
        commentEmpty: "评论不能为空。",
        posting: "发布中...",
        commentPosted: "评论已发布！",
        failedToPost: "发布评论失败。",
        mustPlaceBet: "您必须在此市场下注才能评论。",
        
        // Errors and Warnings
        invalidMarketId: "无效的市场ID。",
        failedToFetchMarket: "获取市场失败",
        failedToFetchBets: "获取投注失败",
        metamaskNotFound: "未找到MetaMask钱包！请安装MetaMask。",
        metamaskNotConnected: "MetaMask未连接。请重新连接。",
        disconnectConfirm: "断开钱包连接？",
        
        // Time and Dates
        today: "今天",
        yesterday: "昨天", 
        daysAgo: "天前",
        
        // LMSR Messages
        lmsrCalculation: "LMSR计算",
        currentShares: "当前份额",
        currentProbability: "当前概率",
        sharesToBuy: "购买份额",
        newProbability: "新概率", 
        fallbackCalculation: "使用后备计算（无LMSR数据可用）",
        tradeExecution: "LMSR交易执行",
        purchaseAmount: "购买金额",
        netAmount: "净金额",
        sharesReceived: "收到份额",
        avgExecutionPrice: "平均执行价格",
        fallbackExecution: "使用后备执行计算"
      }
    };

    /**
     * Internationalization Manager
     */
    class I18nManager {
      constructor() {
        this.translations = translations;
        this.currentLanguage = this.detectLanguage();
        console.log(`I18n initialized with language: ${this.currentLanguage}`);
      }
      
      /**
       * Auto-detect user's preferred language
       */
      detectLanguage() {
        // Check URL parameter first
        const urlParams = new URLSearchParams(window.location.search);
        const langParam = urlParams.get('lang');
        if (langParam && this.translations[langParam]) {
          return langParam;
        }
        
        // Check localStorage
        const savedLang = localStorage.getItem('bnbmarket_language');
        if (savedLang && this.translations[savedLang]) {
          return savedLang;
        }
        
        // Check browser language
        const browserLang = navigator.language || navigator.userLanguage;
        if (browserLang.startsWith('zh')) {
          return 'zh-CN';
        }
        
        return 'en'; // Default to English
      }
      
      /**
       * Get translation for a key
       */
      t(key) {
        const lang = this.translations[this.currentLanguage];
        return lang && lang[key] ? lang[key] : this.translations.en[key] || key;
      }
      
      /**
       * Switch language
       */
      switchLanguage(lang) {
        if (!this.translations[lang]) {
          console.warn(`Language ${lang} not supported`);
          return;
        }
        
        this.currentLanguage = lang;
        localStorage.setItem('bnbmarket_language', lang);
        this.updateAllTexts();
        console.log(`Language switched to: ${lang}`);
      }
      
      /**
       * Update all translatable texts in the DOM
       */
      updateAllTexts() {
        // Update navigation
        const myBetsLink = document.getElementById('myBetsNavLink');
        if (myBetsLink) myBetsLink.textContent = this.t('myBets');
        
        // Update wallet button
        const walletBtn = document.getElementById('walletBtn');
        if (walletBtn && !walletAddress) {
          walletBtn.textContent = this.t('connectWallet');
        }
        
        // Update other elements with data-i18n attribute
        document.querySelectorAll('[data-i18n]').forEach(element => {
          const key = element.getAttribute('data-i18n');
          element.textContent = this.t(key);
        });
        
        // Update placeholders
        document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
          const key = element.getAttribute('data-i18n-placeholder');
          element.placeholder = this.t(key);
        });
        
        // Refresh current page content
        if (window.currentMarket) {
          this.updateMarketTexts();
        }
      }
      
      /**
       * Update market-specific texts
       */
      updateMarketTexts() {
        // Update trade panel
        const buyBtn = document.getElementById('buyBtn');
        if (buyBtn) buyBtn.textContent = this.t('purchaseShares');
        
        const cancelBtn = document.getElementById('cancelBtn');
        if (cancelBtn) cancelBtn.textContent = this.t('requestRefund');
        
        // Update chart tabs
        const probabilityTab = document.getElementById('probabilityTab');
        if (probabilityTab) probabilityTab.textContent = this.t('marketConfidenceOverTime');
        
        const distributionTab = document.getElementById('distributionTab');
        if (distributionTab) distributionTab.textContent = this.t('currentMarketDistribution');
      }
      
      /**
       * Format number with localization
       */
      formatNumber(number, decimals = 3) {
        if (this.currentLanguage === 'zh-CN') {
          return number.toLocaleString('zh-CN', { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
        }
        return number.toLocaleString('en-US', { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
      }
      
      /**
       * Format currency
       */
      formatCurrency(amount, currency = 'BNB') {
        const formatted = this.formatNumber(amount, 3);
        return `${formatted} ${currency}`;
      }
    }

    // Initialize global i18n manager
    window.i18n = new I18nManager();

    // ========================================
    // LMSR IMPLEMENTATION (Digital Ronin's Mathematical Foundation)
    // ========================================
    
    /**
     * Professional LMSR (Logarithmic Market Scoring Rule) Implementation
     * Based on the mathematical foundation provided by Digital Ronin
     * 
     * Formula: C(q) = b * ln(Σ e^(q_j/b))
     * Price: p_i(q) = e^(q_i/b) / Σ e^(q_j/b)
     */
    class LMSREngine {
      constructor(liquidityParameter = 50) {
        this.b = liquidityParameter; // Larger b = deeper market, less price impact
        console.log(`🔮 LMSR Engine initialized with liquidity parameter b=${this.b}`);
      }
      
      /**
       * Calculate the cost function C(q) = b * ln(Σ e^(q_j/b))
       * @param {number[]} q - Array of outstanding shares for each outcome
       * @param {number} b - Liquidity parameter (optional, uses instance default)
       * @returns {number} - Cost function value
       */
      cost(q, b = this.b) {
        const exps = q.map(x => Math.exp(x / b));
        const sum = exps.reduce((acc, val) => acc + val, 0);
        return b * Math.log(sum);
      }
      
      /**
       * Calculate instantaneous prices (probabilities) for all outcomes
       * @param {number[]} q - Array of outstanding shares for each outcome
       * @param {number} b - Liquidity parameter (optional)
       * @returns {number[]} - Array of probabilities (sum = 1)
       */
      prices(q, b = this.b) {
        const exps = q.map(x => Math.exp(x / b));
        const sum = exps.reduce((acc, val) => acc + val, 0);
        return exps.map(exp => exp / sum);
      }
      
      /**
       * Calculate cost to buy a delta vector of shares
       * @param {number[]} q - Current outstanding shares
       * @param {number[]} delta - Shares to buy (same length as q)
       * @param {number} b - Liquidity parameter (optional)
       * @returns {number} - Cost in BNB
       */
      costToBuy(q, delta, b = this.b) {
        if (q.length !== delta.length) {
          throw new Error('Share arrays must have same length');
        }
        const qNext = q.map((val, i) => val + (delta[i] || 0));
        return this.cost(qNext, b) - this.cost(q, b);
      }
      
      /**
       * Calculate cost to buy shares of a specific outcome
       * @param {number[]} q - Current outstanding shares
       * @param {number} outcomeIndex - Index of outcome to buy
       * @param {number} shareAmount - Number of shares to buy
       * @param {number} b - Liquidity parameter (optional)
       * @returns {number} - Cost in BNB
       */
      costToBuyOutcome(q, outcomeIndex, shareAmount, b = this.b) {
        const delta = new Array(q.length).fill(0);
        delta[outcomeIndex] = shareAmount;
        return this.costToBuy(q, delta, b);
      }
      
      /**
       * Calculate shares you get for a given BNB amount (reverse calculation)
       * Uses binary search to find optimal share purchase
       * @param {number[]} q - Current outstanding shares
       * @param {number} outcomeIndex - Index of outcome to buy
       * @param {number} bnbAmount - BNB to spend
       * @param {number} b - Liquidity parameter (optional)
       * @returns {number} - Number of shares you can buy
       */
      sharesToBuy(q, outcomeIndex, bnbAmount, b = this.b) {
        let low = 0;
        let high = bnbAmount * 10; // Upper bound estimate
        let tolerance = 0.0001;
        
        for (let iterations = 0; iterations < 100; iterations++) {
          const mid = (low + high) / 2;
          const cost = this.costToBuyOutcome(q, outcomeIndex, mid, b);
          
          if (Math.abs(cost - bnbAmount) < tolerance) {
            return mid;
          }
          
          if (cost < bnbAmount) {
            low = mid;
          } else {
            high = mid;
          }
        }
        
        return (low + high) / 2;
      }
      
      /**
       * Check if market is in neutral 50/50 state (for binary markets)
       * or balanced state (for multi-outcome markets)
       * @param {number[]} q - Outstanding shares
       * @returns {boolean} - True if market is balanced
       */
      isBalanced(q) {
        const prices = this.prices(q);
        const expectedPrice = 1 / q.length; // Equal probability for all outcomes
        const tolerance = 0.01; // 1% tolerance
        
        return prices.every(price => Math.abs(price - expectedPrice) < tolerance);
      }
      
      /**
       * Get market status description
       * @param {number[]} q - Outstanding shares
       * @returns {object} - Market analysis
       */
      analyzeMarket(q) {
        const prices = this.prices(q);
        const maxPrice = Math.max(...prices);
        const maxIndex = prices.indexOf(maxPrice);
        const dominantOutcome = maxIndex;
        const confidence = maxPrice * 100;
        const isNeutral = this.isBalanced(q);
        
        return {
          prices: prices.map(p => Math.round(p * 100)), // Convert to percentages
          dominantOutcome,
          confidence: Math.round(confidence),
          isNeutral,
          liquidityDepth: this.b,
          totalShares: q.reduce((sum, shares) => sum + shares, 0)
        };
      }
    }

    // Initialize global LMSR engine
    window.lmsrEngine = new LMSREngine(50); // Liquidity parameter b = 50
    
    /**
     * Helper function to get LMSR probabilities for market (backward compatibility)
     * This maintains compatibility with your existing code
     */
    async function getLMSRProbabilities(marketId) {
      try {
        // Try to get data from server first
        const response = await fetch(`${API_BASE_URL}/markets/${marketId}/probabilities`);
        if (response.ok) {
          const data = await response.json();
          
          // If server provides shares data, use our LMSR engine for calculation
          if (data.shares && Array.isArray(data.shares)) {
            const analysis = window.lmsrEngine.analyzeMarket(data.shares);
            return {
              probabilities: analysis.prices,
              prices: window.lmsrEngine.prices(data.shares).map(p => p), // Price per share
              shares: data.shares,
              analysis: analysis
            };
          }
          
          return data; // Fallback to server-provided data
        }
      } catch (error) {
        console.warn('Failed to fetch LMSR probabilities from server, using simulation:', error);
      }
      
      // Fallback to enhanced simulation if server fails or no data
      if (window.currentMarket && window.currentMarket.options) {
        try {
          const simulatedData = window.yinYangSimulator.getCurrentProbabilities(marketId, window.currentMarket.options);
          return {
            probabilities: simulatedData.probabilities,
            prices: simulatedData.prices,
            volume: simulatedData.volume,
            isSimulated: true
          };
        } catch (simError) {
          console.warn('Simulation fallback failed:', simError);
        }
      }
      
      return null;
    }

    // ========================================
    // CHART ENGINE WITH LMSR INTEGRATION
    // ========================================
    // Enhanced Prediction Market Trading System
    // ========================================
    
    class PredictionMarketEngine {
      constructor() {
        this.markets = new Map();
        this.userPositions = new Map();
        this.orderBook = new Map();
        this.tradeHistory = new Map();
      }
      
      // Initialize market with proper prediction market mechanics
      initializeMarket(marketId, options) {
        // Check if market is already initialized to prevent duplicates
        if (this.markets.has(marketId)) {
          console.log(`Market ${marketId} already initialized, skipping duplicate initialization`);
          return this.markets.get(marketId);
        }
        
        const market = {
          id: marketId,
          options: options,
          totalLiquidity: 10000, // Initial liquidity in BNB
          shares: options.map(() => 1000), // EQUAL starting shares - pure market!
          lastPrices: options.map(() => 1 / options.length), // Start with equal probability (50/50 for binary)
          volume24h: 0,
          totalVolume: 0
        };
        
        this.markets.set(marketId, market);
        this.orderBook.set(marketId, { bids: [], asks: [] });
        this.tradeHistory.set(marketId, []);
        
        console.log(`PREDICTION MARKET initialized: ${marketId}`);
        console.log(`Starting probabilities: ${options.map(() => (100/options.length).toFixed(1)).join('%, ')}%`);
        console.log(`Initial liquidity: ${market.totalLiquidity} BNB`);
        console.log(`Market will adjust based on trading activity only!`);
        
        return market;
      }
      
      // Calculate current market prices using AMM formula
      calculateMarketPrices(marketId) {
        const market = this.markets.get(marketId);
        if (!market) return null;
        
        const { shares, totalLiquidity } = market;
        const b = Math.sqrt(totalLiquidity); // Market maker parameter
        
        // Calculate probabilities using LMSR-like formula
        const sum = shares.reduce((acc, s) => acc + Math.exp(s / b), 0);
        const probabilities = shares.map(s => Math.exp(s / b) / sum);
        
        // Prices are the probabilities (what you pay for $1 payout)
        const prices = probabilities.map(p => Math.max(0.001, Math.min(0.999, p)));
        
        return {
          prices: prices,
          probabilities: probabilities.map(p => p * 100),
          impliedOdds: prices.map(p => 1 / p)
        };
      }
      
      // Execute a market buy order
      executeBuy(marketId, optionIndex, bnbAmount, userAddress) {
        const market = this.markets.get(marketId);
        if (!market) throw new Error('Market not found');
        
        console.log('🔥 BEFORE TRADE - Market shares:', [...market.shares]);
        
        const pricing = this.calculateMarketPrices(marketId);
        const pricePerShare = pricing.prices[optionIndex];
        
        console.log('Trade details:', {
          marketId,
          optionIndex,
          bnbAmount,
          pricePerShare,
          currentProbabilities: pricing.probabilities
        });
        
        // Calculate shares received
        const sharesReceived = bnbAmount / pricePerShare;
        
        // Platform fee (1%)
        const fee = bnbAmount * 0.01;
        const netAmount = bnbAmount - fee;
        
        // Update market state
        market.shares[optionIndex] += sharesReceived;
        market.totalVolume += bnbAmount;
        market.volume24h += bnbAmount;
        
        console.log('🔥 AFTER TRADE - Market shares:', [...market.shares]);
        console.log('Shares added to option', optionIndex, ':', sharesReceived);
        
        // Calculate new probabilities after the trade
        const newPricing = this.calculateMarketPrices(marketId);
        console.log('📈 NEW PROBABILITIES after trade:', newPricing.probabilities);
        console.log('NEW PRICES after trade:', newPricing.prices);
        
        // Verify the market state changed
        console.log('🔍 Market state verification:');
        console.log('  - Market ID:', marketId);
        console.log('  - Total shares now:', market.shares);
        console.log('  - Total volume now:', market.totalVolume);
        console.log('  - Shares for option', optionIndex, ':', market.shares[optionIndex]);
        
        // Update user position
        const userKey = `${userAddress}-${marketId}`;
        if (!this.userPositions.has(userKey)) {
          this.userPositions.set(userKey, {});
        }
        
        const positions = this.userPositions.get(userKey);
        if (!positions[optionIndex]) {
          positions[optionIndex] = { shares: 0, invested: 0 };
        }
        
        positions[optionIndex].shares += sharesReceived;
        positions[optionIndex].invested += netAmount;
        
        // Record trade
        const trade = {
          timestamp: Date.now(),
          user: userAddress,
          optionIndex,
          side: 'buy',
          amount: bnbAmount,
          shares: sharesReceived,
          price: pricePerShare,
          fee: fee
        };
        
        this.tradeHistory.get(marketId).push(trade);
        
        return {
          success: true,
          trade: trade,
          newPosition: positions[optionIndex],
          marketPricing: this.calculateMarketPrices(marketId)
        };
      }
      
      // Calculate potential payout for a position
      calculatePayout(marketId, optionIndex, shares, resolvedOutcome) {
        if (optionIndex === resolvedOutcome) {
          return shares; // Each share pays 1 BNB if correct
        }
        return 0; // Shares become worthless if wrong
      }
      
      // Get market depth and liquidity info
      getMarketDepth(marketId) {
        const market = this.markets.get(marketId);
        if (!market) return null;
        
        const pricing = this.calculateMarketPrices(marketId);
        
        return {
          prices: pricing.prices,
          probabilities: pricing.probabilities,
          liquidity: market.totalLiquidity,
          volume24h: market.volume24h,
          totalVolume: market.totalVolume,
          shares: market.shares
        };
      }
    }
    
    // Initialize prediction market engine
    window.predictionMarket = new PredictionMarketEngine();

    // ========================================
    // Enhanced Order Book with Proper Trading
    // ========================================
    
    class EnhancedOrderBook {
      constructor() {
        this.selectedOutcome = null;
        this.selectedSide = null;
        this.showLimitOrder = false;
        this.currentMarket = null;
      }
      
      // Render comprehensive order book with buy/sell mechanics
      renderOrderBook(market) {
        if (!market) return;
        
        this.currentMarket = market;
        
        // Initialize prediction market
        window.predictionMarket.initializeMarket(market.id, market.options);
        
        const container = document.getElementById('orderBookEntries');
        if (!container) return;
        
        const marketDepth = window.predictionMarket.getMarketDepth(market.id);
        
        container.innerHTML = '';
        
        // Add explanation section
        this.renderExplanation(container);
        
        // Render each option as a trading pair
        market.options.forEach((option, index) => {
          const probability = marketDepth.probabilities[index];
          const price = marketDepth.prices[index];
          const oppositePrice = 1 - price;
          
          const entryDiv = document.createElement('div');
          entryDiv.className = 'prediction-market-row';
          entryDiv.style.cssText = `
            background: linear-gradient(135deg, rgba(51,65,85,0.3), rgba(30,41,59,0.2));
            border: 1px solid #475569;
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 16px;
            transition: all 0.3s ease;
          `;
          
          entryDiv.innerHTML = `
            <div style="display: grid; grid-template-columns: 1fr auto auto auto; gap: 24px; align-items: center;">
              <!-- Market Info -->
              <div>
                <div style="color: #f8fafc; font-weight: 800; font-size: 1.2rem; margin-bottom: 8px;">
                  ${option.name}
                </div>
                <div style="display: flex; gap: 16px; align-items: center; margin-bottom: 8px;">
                  <span style="color: #06b6d4; font-weight: 700; font-size: 1.1rem;">
                    ${probability.toFixed(1)}% chance
                  </span>
                  <span style="color: #94a3b8; font-size: 0.9rem;">
                    Vol: ${(marketDepth.volume24h / 1000).toFixed(1)}k BNB
                  </span>
                </div>
                <div style="color: #64748b; font-size: 0.85rem;">
                  Current implied odds: ${(1/price).toFixed(2)}:1
                </div>
              </div>
              
              <!-- YES Trading -->
              <div style="text-align: center; min-width: 140px;">
                <div style="color: #94a3b8; font-size: 0.8rem; margin-bottom: 4px;">BUY YES</div>
                <div style="color: #10b981; font-weight: 800; font-size: 1.3rem; margin-bottom: 8px;">
                  ${price.toFixed(3)} BNB
                </div>
                <button 
                  onclick="window.enhancedOrderBook.openTradePanel(${index}, 'yes', ${price})"
                  style="background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; padding: 10px 16px; border-radius: 8px; font-weight: 700; cursor: pointer; transition: all 0.2s;"
                  onmouseover="this.style.transform='scale(1.05)'"
                  onmouseout="this.style.transform='scale(1)'"
                >
                  ☀️ Buy Yes
                </button>
              </div>
              
              <!-- NO Trading -->
              <div style="text-align: center; min-width: 140px;">
                <div style="color: #94a3b8; font-size: 0.8rem; margin-bottom: 4px;">BUY NO</div>
                <div style="color: #ef4444; font-weight: 800; font-size: 1.3rem; margin-bottom: 8px;">
                  ${oppositePrice.toFixed(3)} BNB
                </div>
                <button 
                  onclick="window.enhancedOrderBook.openTradePanel(${index}, 'no', ${oppositePrice})"
                  style="background: linear-gradient(135deg, #ef4444, #dc2626); color: white; border: none; padding: 10px 16px; border-radius: 8px; font-weight: 700; cursor: pointer; transition: all 0.2s;"
                  onmouseover="this.style.transform='scale(1.05)'"
                  onmouseout="this.style.transform='scale(1)'"
                >
                  🌙 Buy No
                </button>
              </div>
              
              <!-- Advanced Options -->
              <div style="text-align: center;">
                <button 
                  onclick="window.enhancedOrderBook.showLimitOrderModal(${index})"
                  style="background: rgba(100,116,139,0.2); color: #94a3b8; border: 1px solid #475569; padding: 8px 12px; border-radius: 6px; font-size: 0.85rem; cursor: pointer;"
                >
                  Limit Order
                </button>
              </div>
            </div>
            
            <!-- Profit Calculator -->
            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #475569;">
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; font-size: 0.85rem; color: #94a3b8;">
                <div>
                  <strong style="color: #10b981;">If YES wins:</strong> 
                  1 BNB investment → ${(1/price).toFixed(2)} BNB payout (${((1/price - 1) * 100).toFixed(1)}% profit)
                </div>
                <div>
                  <strong style="color: #ef4444;">If NO wins:</strong> 
                  1 BNB investment → ${(1/oppositePrice).toFixed(2)} BNB payout (${((1/oppositePrice - 1) * 100).toFixed(1)}% profit)
                </div>
              </div>
            </div>
          `;
          
          container.appendChild(entryDiv);
        });
        
        // Add trading modal
        this.createTradingModal();
      }
      
      // Render explanation of how prediction markets work
      renderExplanation(container) {
        const explanationDiv = document.createElement('div');
        explanationDiv.style.cssText = `
          background: linear-gradient(135deg, rgba(6,182,212,0.1), rgba(15,23,42,0.8));
          border: 1px solid rgba(6,182,212,0.3);
          border-radius: 12px;
          padding: 20px;
          margin-bottom: 24px;
        `;
        
        explanationDiv.innerHTML = `
          <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
            <div style="font-size: 2rem;">🔍</div>
            <h3 style="color: #06b6d4; font-size: 1.3rem; font-weight: 800; margin: 0;">
              How Prediction Markets Work
            </h3>
          </div>
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; color: #e2e8f0; font-size: 0.9rem; line-height: 1.5;">
            <div>
              <div style="color: #10b981; font-weight: 700; margin-bottom: 8px;">🟢 Buy YES Shares</div>
              <ul style="margin: 0; padding-left: 16px;">
                <li>Pay current YES price per share</li>
                <li>Each share pays 1 BNB if outcome is YES</li>
                <li>Example: Buy at 0.3 BNB → Get 3.33x return if correct</li>
                <li>Lose investment if outcome is NO</li>
              </ul>
            </div>
            
            <div>
              <div style="color: #ef4444; font-weight: 700; margin-bottom: 8px;">🔴 Buy NO Shares</div>
              <ul style="margin: 0; padding-left: 16px;">
                <li>Pay current NO price per share</li>
                <li>Each share pays 1 BNB if outcome is NO</li>
                <li>Example: Buy at 0.7 BNB → Get 1.43x return if correct</li>
                <li>Lose investment if outcome is YES</li>
              </ul>
            </div>
          </div>
          
          <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(6,182,212,0.3);">
            <div style="color: #94a3b8; font-size: 0.85rem;">
              <strong style="color: #06b6d4;">💡 Key Point:</strong> 
              YES price + NO price ≈ 1 BNB. Prices reflect market confidence. 
              Higher price = lower chance but higher payout. Lower price = higher chance but lower payout.
            </div>
          </div>
        `;
        
        container.appendChild(explanationDiv);
      }
      
      // Show trading modal for market orders
      showTradeModal(optionIndex, side, currentPrice) {
        const modal = document.getElementById('tradingModal');
        const option = this.currentMarket.options[optionIndex];
        
        document.getElementById('modalTitle').textContent = 
          `${side.toUpperCase()} - ${option.name}`;
        document.getElementById('modalCurrentPrice').textContent = 
          `${currentPrice.toFixed(3)} BNB per share`;
        document.getElementById('modalSide').value = side;
        document.getElementById('modalOptionIndex').value = optionIndex;
        document.getElementById('modalPrice').value = currentPrice.toFixed(3);
        
        // Calculate potential returns
        const potentialReturn = 1 / currentPrice;
        const profit = ((potentialReturn - 1) * 100).toFixed(1);
        document.getElementById('modalProfit').textContent = 
          `Potential: ${potentialReturn.toFixed(2)}x return (${profit}% profit)`;
        
        modal.style.display = 'flex';
      }
      
      // Create trading modal
      createTradingModal() {
        if (document.getElementById('tradingModal')) return;
        
        const modal = document.createElement('div');
        modal.id = 'tradingModal';
        modal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0,0,0,0.8);
          display: none;
          align-items: center;
          justify-content: center;
          z-index: 10000;
        `;
        
        modal.innerHTML = `
          <div style="background: linear-gradient(135deg, #1e293b, #0f172a); border: 1px solid #334155; border-radius: 16px; padding: 32px; max-width: 500px; width: 90%;">
            <h2 id="modalTitle" style="color: #f8fafc; margin: 0 0 16px 0; font-size: 1.5rem;"></h2>
            
            <div style="margin-bottom: 20px;">
              <div style="color: #94a3b8; margin-bottom: 8px;">Current Price:</div>
              <div id="modalCurrentPrice" style="color: #06b6d4; font-size: 1.3rem; font-weight: 800;"></div>
              <div id="modalProfit" style="color: #10b981; font-size: 0.9rem; margin-top: 4px;"></div>
            </div>
            
            <div style="margin-bottom: 20px;">
              <label style="color: #94a3b8; display: block; margin-bottom: 8px;">Amount to Invest (BNB):</label>
              <input id="modalAmount" type="number" min="0.007585445110418999" step="0.001" placeholder="1.0" 
                style="width: 100%; padding: 12px; background: #334155; border: 1px solid #475569; border-radius: 8px; color: #f8fafc; font-size: 1.1rem;">
            </div>
            
            <div style="margin-bottom: 24px; background: rgba(51,65,85,0.3); padding: 16px; border-radius: 8px;">
              <div id="modalCalculation" style="color: #e2e8f0; font-size: 0.9rem;"></div>
            </div>
            
            <div style="display: flex; gap: 12px;">
              <button onclick="window.enhancedOrderBook.executeTrade()" 
                style="flex: 1; background: linear-gradient(135deg, #06b6d4, #0891b2); color: white; border: none; padding: 14px; border-radius: 8px; font-weight: 700; cursor: pointer;">
                Confirm Trade
              </button>
              <button onclick="window.enhancedOrderBook.closeModal()" 
                style="flex: 1; background: rgba(100,116,139,0.2); color: #94a3b8; border: 1px solid #475569; padding: 14px; border-radius: 8px; cursor: pointer;">
                Cancel
              </button>
            </div>
            
            <input id="modalSide" type="hidden">
            <input id="modalOptionIndex" type="hidden">
            <input id="modalPrice" type="hidden">
          </div>
        `;
        
        document.body.appendChild(modal);
        
        // Update calculation when amount changes
        document.getElementById('modalAmount').addEventListener('input', () => {
          this.updateTradeCalculation();
        });
      }
      
      // Update trade calculation display
      updateTradeCalculation() {
        const amount = parseFloat(document.getElementById('modalAmount').value) || 0;
        const price = parseFloat(document.getElementById('modalPrice').value);
        const side = document.getElementById('modalSide').value;
        
        if (amount > 0) {
          const shares = amount / price;
          const potentialPayout = shares * 1; // Each share pays 1 BNB if correct
          const profit = potentialPayout - amount;
          const profitPercent = ((profit / amount) * 100).toFixed(1);
          
          document.getElementById('modalCalculation').innerHTML = `
            <strong>Trade Summary:</strong><br>
            • Investment: ${amount.toFixed(3)} BNB<br>
            • Shares received: ${shares.toFixed(3)}<br>
            • If ${side.toUpperCase()} wins: ${potentialPayout.toFixed(3)} BNB<br>
            • Profit: ${profit.toFixed(3)} BNB (${profitPercent}%)<br>
            • If wrong: Lose ${amount.toFixed(3)} BNB
          `;
        }
      }
      
      // Execute the trade
      async executeTrade() {
        const amount = parseFloat(document.getElementById('modalAmount').value);
        const optionIndex = parseInt(document.getElementById('modalOptionIndex').value);
        const side = document.getElementById('modalSide').value;
        const minBet = 0.007585445110418999; // $10 USD in BNB
        
        if (!amount || amount <= 0) {
          alert('Please enter a valid amount');
          return;
        }
        
        if (amount < minBet) {
          alert(`Minimum bet is ${minBet} BNB ($10 USD)`);
          return;
        }
        
        try {
          // Execute through prediction market engine
          const result = window.predictionMarket.executeBuy(
            this.currentMarket.id,
            optionIndex,
            amount,
            walletAddress || 'demo_user'
          );
          
          if (result.success) {
            // Update UI
            this.renderOrderBook(this.currentMarket);
            this.closeModal();
            
            // Show success message
            this.showTradeMessage(
              `✅ Successfully bought ${result.trade.shares.toFixed(3)} ${side.toUpperCase()} shares for ${amount} BNB`,
              'success'
            );
            
            // CRITICAL: Update charts with new market data
            setTimeout(() => {
              this.updateChartsAfterTrade();
            }, 300);
          }
        } catch (error) {
          alert(`Trade failed: ${error.message}`);
        }
      }
      
      // Update charts after a trade is executed
      updateChartsAfterTrade() {
        try {
          console.log('🔄 Starting chart update after trade...');
          
          // Show visual feedback that charts are updating
          this.showChartUpdateIndicator();
          
          // Get updated market pricing from prediction market engine
          const marketDepth = window.predictionMarket.getMarketDepth(this.currentMarket.id);
          console.log('📊 Market depth after trade:', marketDepth);
          
          if (marketDepth && window.lmsrChartEngine) {
            // Update the current market data with new probabilities
            const updatedMarket = {
              ...this.currentMarket,
              currentProbabilities: marketDepth.probabilities,
              currentPrices: marketDepth.prices,
              totalVolume: marketDepth.totalVolume,
              volume24h: marketDepth.volume24h
            };
            
            // Store globally for chart access
            window.currentMarket = updatedMarket;
            console.log('✅ Updated global market data:', updatedMarket);
            
            // Recreate charts with updated data
            console.log('🔄 Refreshing charts with new probabilities:', marketDepth.probabilities);
            
            // Add slight delay for visual effect and force chart refresh
            setTimeout(() => {
              console.log('📊 Creating probability chart...');
              
              // Force destroy and recreate for immediate update
              if (window.lmsrChartEngine.chartInstances && window.lmsrChartEngine.chartInstances['probabilityChart']) {
                window.lmsrChartEngine.chartInstances['probabilityChart'].destroy();
                delete window.lmsrChartEngine.chartInstances['probabilityChart'];
              }
              if (window.lmsrChartEngine.chartInstances && window.lmsrChartEngine.chartInstances['distributionChart']) {
                window.lmsrChartEngine.chartInstances['distributionChart'].destroy();
                delete window.lmsrChartEngine.chartInstances['distributionChart'];
              }
              
              window.lmsrChartEngine.createProbabilityChart('probabilityChartContainer', this.currentMarket.id);
              
              console.log('📊 Creating distribution chart...');
              window.lmsrChartEngine.createCurrentDistributionChart('distributionChartContainer', this.currentMarket.id);
              
              // Hide update indicator
              this.hideChartUpdateIndicator();
              
              // Show probability change notification
              this.showProbabilityChangeNotification(marketDepth.probabilities);
              
              console.log('✅ Charts update completed - forced refresh with live data');
            }, 500);
            
            // Also update any volume charts if they exist
            if (window.lmsrChartEngine.createVolumeChart) {
              setTimeout(() => {
                window.lmsrChartEngine.createVolumeChart('volumeChartContainer', this.currentMarket.id);
              }, 600);
            }
          } else {
            console.error('❌ Missing market depth or chart engine:', { 
              marketDepth: !!marketDepth, 
              chartEngine: !!window.lmsrChartEngine 
            });
          }
        } catch (error) {
          console.error('Error updating charts after trade:', error);
          this.hideChartUpdateIndicator();
        }
      }
      
      // Show visual indicator that charts are updating
      showChartUpdateIndicator() {
        const indicators = ['probabilityChartContainer', 'distributionChartContainer'];
        
        indicators.forEach(containerId => {
          const container = document.getElementById(containerId);
          if (container) {
            // Add updating overlay
            const overlay = document.createElement('div');
            overlay.id = `${containerId}-updating`;
            overlay.style.cssText = `
              position: absolute;
              top: 0;
              left: 0;
              right: 0;
              bottom: 0;
              background: rgba(15, 23, 42, 0.8);
              display: flex;
              align-items: center;
              justify-content: center;
              color: #06b6d4;
              font-weight: 700;
              font-size: 1.1rem;
              border-radius: 12px;
              z-index: 1000;
            `;
            overlay.innerHTML = `
              <div style="text-align: center;">
                <div style="font-size: 1.2rem; margin-bottom: 8px; font-weight: 600;">Analytics</div>
                <div>Updating Chart...</div>
                <div style="margin-top: 8px; width: 40px; height: 3px; background: linear-gradient(90deg, #06b6d4, #3b82f6); border-radius: 2px; animation: pulse 1.5s infinite;"></div>
              </div>
            `;
            
            container.style.position = 'relative';
            container.appendChild(overlay);
          }
        });
      }
      
      // Hide chart update indicators
      hideChartUpdateIndicator() {
        const indicators = ['probabilityChartContainer-updating', 'distributionChartContainer-updating'];
        
        indicators.forEach(indicatorId => {
          const indicator = document.getElementById(indicatorId);
          if (indicator) {
            indicator.remove();
          }
        });
      }
      
      // Show probability change notification
      showProbabilityChangeNotification(newProbabilities) {
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: linear-gradient(135deg, #10b981, #059669);
          color: white;
          padding: 16px 20px;
          border-radius: 12px;
          box-shadow: 0 4px 20px rgba(16, 185, 129, 0.3);
          z-index: 10001;
          font-weight: 700;
          max-width: 300px;
        `;
        
        const probText = newProbabilities.map((prob, index) => {
          const option = this.currentMarket.options[index];
          const symbol = option.name.includes('YES') ? '☀️' : '🌙';
          return `${symbol} ${option.name.split(' ')[0]}: ${prob.toFixed(1)}%`;
        }).join('<br>');
        
        notification.innerHTML = `
          <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
            <div style="font-size: 1.5rem;">📈</div>
            <div style="font-size: 1.1rem;">Market Updated!</div>
          </div>
          <div style="font-size: 0.9rem; line-height: 1.4;">
            ${probText}
          </div>
        `;
        
        document.body.appendChild(notification);
        
        // Auto-remove after 4 seconds
        setTimeout(() => {
          if (notification.parentNode) {
            notification.remove();
          }
        }, 4000);
      }
      
      // Close modal
      closeModal() {
        document.getElementById('tradingModal').style.display = 'none';
      }
      
      // Show limit order modal
      showLimitOrderModal(optionIndex) {
        // For now, just show an info alert about limit orders
        const option = this.currentMarket.options[optionIndex];
        alert(`🔄 Limit Orders for "${option.name}"\n\nLimit orders allow you to set a specific price you want to pay.\n\n• Set a lower price than current market price\n• Your order will execute when someone sells at your price\n• Useful for getting better entry prices\n\nThis feature will be available in the next update!`);
      }
      
      // Show trade message
      showTradeMessage(message, type) {
        const messageEl = document.getElementById('tradeMsg');
        if (messageEl) {
          messageEl.innerHTML = `<div style="color:${type === 'success' ? '#10b981' : '#ef4444'};font-weight:600;">${message}</div>`;
          setTimeout(() => {
            messageEl.innerHTML = '';
          }, 5000);
        }
      }
      
      // ========================================
      // Polymarket-style Trade Panel Functions
      // ========================================
      
      // Open trade panel (like Polymarket)
      openTradePanel(optionIndex, side, currentPrice) {
        this.selectedOptionIndex = optionIndex;
        this.selectedSide = side;
        this.selectedPrice = currentPrice;
        
        const option = this.currentMarket.options[optionIndex];
        const marketDepth = window.predictionMarket.getMarketDepth(this.currentMarket.id);
        
        // Update panel info
        document.getElementById('selectedOutcomeName').textContent = option.name;
        document.getElementById('selectedOutcomePrice').textContent = `${currentPrice.toFixed(3)} BNB`;
        document.getElementById('selectedOutcomeProbability').textContent = `${marketDepth.probabilities[optionIndex].toFixed(1)}% chance`;
        document.getElementById('selectedOutcomeOdds').textContent = `${(1/currentPrice).toFixed(2)}:1 odds`;
        
        // Update title
        document.getElementById('tradePanelTitle').textContent = `Trade: ${option.name}`;
        
        // Show content and animate panel
        document.getElementById('tradePanelContent').style.display = 'block';
        document.getElementById('tradePanelContainer').style.transform = 'translateY(0)';
        
        // Set initial trade side
        this.selectTradeSide('buy');
        
        // Set up real-time updates
        this.setupTradePanelUpdates();
      }
      
      // Close trade panel
      closeTradePanel() {
        document.getElementById('tradePanelContainer').style.transform = 'translateY(100%)';
        setTimeout(() => {
          document.getElementById('tradePanelContent').style.display = 'none';
        }, 300);
      }
      
      // Select trade side (buy/sell)
      selectTradeSide(side) {
        this.selectedSide = side;
        
        const buyBtn = document.getElementById('buyToggle');
        const sellBtn = document.getElementById('sellToggle');
        
        if (side === 'buy') {
          buyBtn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
          buyBtn.style.color = 'white';
          sellBtn.style.background = 'transparent';
          sellBtn.style.color = '#94a3b8';
        } else {
          sellBtn.style.background = 'linear-gradient(135deg, #ef4444, #dc2626)';
          sellBtn.style.color = 'white';
          buyBtn.style.background = 'transparent';
          buyBtn.style.color = '#94a3b8';
        }
        
        this.updateTradeSummary();
      }
      
      // Set up real-time updates for trade panel
      setupTradePanelUpdates() {
        const amountInput = document.getElementById('tradePanelAmount');
        
        // Update summary when amount changes
        amountInput.addEventListener('input', () => {
          this.updateTradeSummary();
        });
        
        // Initial update
        this.updateTradeSummary();
      }
      
      // Update trade summary display
      updateTradeSummary() {
        const amount = parseFloat(document.getElementById('tradePanelAmount').value) || 0;
        
        if (amount > 0 && this.selectedPrice) {
          const shares = amount / this.selectedPrice;
          const potentialPayout = shares * 1; // Each share pays 1 BNB if correct
          const profit = potentialPayout - amount;
          const profitPercent = ((profit / amount) * 100).toFixed(1);
          
          document.getElementById('sharesToReceive').textContent = shares.toFixed(3);
          document.getElementById('potentialPayout').textContent = `${potentialPayout.toFixed(3)} BNB`;
          document.getElementById('potentialProfit').textContent = `+${profit.toFixed(3)} BNB (${profitPercent}%)`;
          
          // Update button
          document.getElementById('placeTradeBtn').textContent = `${this.selectedSide === 'buy' ? 'Buy' : 'Sell'} ${shares.toFixed(2)} shares`;
        } else {
          document.getElementById('sharesToReceive').textContent = '0.000';
          document.getElementById('potentialPayout').textContent = '0.000 BNB';
          document.getElementById('potentialProfit').textContent = '+0.000 BNB (0%)';
          document.getElementById('placeTradeBtn').textContent = 'Enter amount';
        }
      }
      
      // Execute trade from panel
      async executePanelTrade() {
        const amount = parseFloat(document.getElementById('tradePanelAmount').value);
        const minBet = 0.007585445110418999; // $10 USD in BNB
        
        if (!amount || amount <= 0) {
          alert('Please enter a valid amount');
          return;
        }
        
        if (amount < minBet) {
          alert(`Minimum bet is ${minBet} BNB ($10 USD)`);
          return;
        }
        
        try {
          console.log('🚀 TRADE PANEL - Submitting real bet to server...');
          
          // FIRST: Submit a real bet to the server to update probabilities (like order book)
          const panelBetData = {
            marketId: this.currentMarket.id,
            bettorAddress: walletAddress || 'trade_panel_user_' + Date.now(),
            optionId: this.selectedOptionIndex,
            amount: amount,
            transactionSignature: 'trade_panel_' + Date.now() + '_' + Math.random().toString(36)
          };
          
          console.log('📤 TRADE PANEL - SUBMITTING REAL BET TO SERVER:', panelBetData);
          
          // Submit bet to server to update the database
          const betResponse = await fetch(`${API_BASE_URL}/bets`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(panelBetData)
          });
          
          let serverBetResult;
          if (betResponse.ok) {
            serverBetResult = await betResponse.json();
            console.log('✅ Trade panel server bet submitted successfully:', serverBetResult);
          } else {
            console.warn('⚠️ Trade panel server bet submission failed:', await betResponse.text());
            serverBetResult = { success: false };
          }
          
          // Also execute through prediction market engine for UI consistency
          const result = window.predictionMarket.executeBuy(
            this.currentMarket.id,
            this.selectedOptionIndex,
            amount,
            walletAddress || 'demo_user'
          );
          
          if (result.success || serverBetResult.bet) {
            console.log('🎯 Trade panel executed successfully, fetching fresh server data...');
            
            // CRITICAL: Fetch fresh data from server after bet submission (same as order book)
            setTimeout(async () => {
              try {
                // Get updated probabilities from server
                const freshData = await getLMSRProbabilities(this.currentMarket.id);
                console.log('📊 FRESH SERVER DATA FROM TRADE PANEL:', freshData);
                
                if (freshData && freshData.probabilities) {
                  const updatedDepth = {
                    probabilities: freshData.probabilities,
                    prices: freshData.prices,
                    shares: freshData.volumes || [1000, 1000],
                    totalVolume: freshData.total_volume || 1000
                  };
                  
                  console.log(`🔄 TRADE PANEL - FORCING CHART REFRESH WITH SERVER DATA:`, updatedDepth);
                  
                  // Flash the chart containers to show something is happening
                  const probContainer = document.getElementById('probabilityChartContainer');
                  const distContainer = document.getElementById('distributionChartContainer');
                  if (probContainer) {
                    probContainer.style.border = "3px solid #ff6600";
                    setTimeout(() => probContainer.style.border = "none", 2000);
                  }
                  if (distContainer) {
                    distContainer.style.border = "3px solid #ff6600";
                    setTimeout(() => distContainer.style.border = "none", 2000);
                  }
                  
                  // Force immediate chart recreation with server data
                  this.forceChartsRefresh(updatedDepth);
                } else {
                  console.warn('⚠️ No fresh data received from server for trade panel');
                  // Fallback to local data
                  const updatedDepth = window.predictionMarket.getMarketDepth(this.currentMarket.id);
                  this.forceChartsRefresh(updatedDepth);
                }
              } catch (error) {
                console.error('❌ Failed to fetch fresh server data for trade panel:', error);
                // Fallback to local data
                const updatedDepth = window.predictionMarket.getMarketDepth(this.currentMarket.id);
                this.forceChartsRefresh(updatedDepth);
              }
            }, 1000); // Wait 1 second for server to process the bet
            
            // Update UI
            this.renderOrderBook(this.currentMarket);
            this.closeTradePanel();
            
            // Show success message
            this.showTradeMessage(
              `✅ Successfully bought ${result.shares?.toFixed(3) || amount} shares for ${amount} BNB`,
              'success'
            );
          }
        } catch (error) {
          console.error('Trade panel error:', error);
          alert(`Trade failed: ${error.message}`);
        }
      }
      
      // Force immediate chart refresh with new data
      forceChartsRefresh(marketDepth) {
        console.log('🔄 Force refreshing charts with data:', marketDepth);
        console.log('📊 Current probabilities being applied:', marketDepth.probabilities);
        
        // Destroy existing charts completely
        if (window.Chart && window.Chart.instances) {
          const instanceCount = Object.keys(window.Chart.instances).length;
          console.log(`🗑️ Destroying ${instanceCount} existing chart instances`);
          Object.values(window.Chart.instances).forEach(chart => {
            if (chart) chart.destroy();
          });
        }
        
        // Clear chart containers
        const probContainer = document.getElementById('probabilityChartContainer');
        const distContainer = document.getElementById('distributionChartContainer');
        
        if (probContainer) {
          probContainer.innerHTML = '';
          console.log('🧹 Cleared probability chart container');
        }
        if (distContainer) {
          distContainer.innerHTML = '';
          console.log('🧹 Cleared distribution chart container');
        }
        
        // Create new charts with live data
        setTimeout(() => {
          console.log('🎨 Creating new charts with probabilities:', marketDepth.probabilities);
          this.createLiveChart('probabilityChartContainer', marketDepth, 'line');
          this.createLiveChart('distributionChartContainer', marketDepth, 'doughnut');
          console.log('✅ Charts forcibly refreshed with new probabilities');
        }, 100);
      }
      
      // Create chart directly with live market data
      createLiveChart(containerId, marketDepth, chartType) {
        const container = document.getElementById(containerId);
        if (!container || !marketDepth) return;
        
        const canvas = document.createElement('canvas');
        container.appendChild(canvas);
        
        if (typeof Chart !== 'undefined') {
          const ctx = canvas.getContext('2d');
          // Use global currentMarket instead of this.currentMarket
          const market = window.currentMarket || currentMarket;
          const options = market ? market.options : [
            { name: 'Yes' },
            { name: 'No' }
          ];
          
          console.log('📊 Creating chart with market options:', options);
          
          let chartConfig;
          
          if (chartType === 'line') {
            chartConfig = {
              type: 'line',
              data: {
                labels: ['Start', 'Current'],
                datasets: options.map((option, index) => ({
                  label: `${option.name} (${marketDepth.probabilities[index].toFixed(1)}%)`,
                  data: [50, marketDepth.probabilities[index]], // Show change from 50% to current
                  borderColor: index === 0 ? '#10b981' : '#ef4444',
                  backgroundColor: index === 0 ? 'rgba(16,185,129,0.1)' : 'rgba(239,68,68,0.1)',
                  tension: 0.4
                }))
              },
              options: {
                responsive: true,
                plugins: {
                  title: { display: true, text: 'Market Probabilities', color: '#f8fafc' },
                  legend: { labels: { color: '#f8fafc' } }
                },
                scales: {
                  y: { 
                    beginAtZero: true, 
                    max: 100,
                    ticks: { color: '#94a3b8' },
                    grid: { color: 'rgba(148,163,184,0.1)' }
                  },
                  x: { 
                    ticks: { color: '#94a3b8' },
                    grid: { color: 'rgba(148,163,184,0.1)' }
                  }
                }
              }
            };
          } else {
            chartConfig = {
              type: 'doughnut',
              data: {
                labels: options.map((option, index) => 
                  `${option.name} (${marketDepth.probabilities[index].toFixed(1)}%)`
                ),
                datasets: [{
                  data: marketDepth.probabilities,
                  backgroundColor: options.map((_, index) => 
                    index === 0 ? '#10b981' : '#ef4444'
                  ),
                  borderWidth: 2,
                  borderColor: '#1e293b'
                }]
              },
              options: {
                responsive: true,
                plugins: {
                  title: { display: true, text: 'Current Distribution', color: '#f8fafc' },
                  legend: { labels: { color: '#f8fafc' } }
                }
              }
            };
          }
          
          console.log(`🎨 Creating ${chartType} chart with config:`, chartConfig);
          const newChart = new Chart(ctx, chartConfig);
          console.log(`📊 Successfully created ${chartType} chart with probabilities:`, marketDepth.probabilities);
          console.log('📈 Chart instance:', newChart);
        } else {
          console.warn('⚠️ Chart.js not available for chart creation');
        }
      }
    }
    
    // Initialize enhanced order book
    window.enhancedOrderBook = new EnhancedOrderBook();

    // ========================================
    // TEST FUNCTION FOR CHART UPDATES
    // ========================================
    
    function testChartUpdate() {
      console.log('🧪 TESTING DIRECT CHART UPDATE');
      
      // Flash the page to show the button was clicked
      document.body.style.backgroundColor = '#ff0000';
      setTimeout(() => document.body.style.backgroundColor = '', 500);
      
      // Create random test data
      const randomProb1 = Math.random() * 80 + 10; // 10-90%
      const randomProb2 = 100 - randomProb1;
      
      const testData = {
        probabilities: [randomProb1, randomProb2],
        prices: [randomProb1/100, randomProb2/100],
        shares: [1000 + Math.random() * 500, 1000 + Math.random() * 500],
        totalVolume: 1000 + Math.random() * 2000
      };
      
      console.log('🎲 Generated random test data:', testData);
      
      // Force chart refresh with test data
      if (window.enhancedOrderBook && window.enhancedOrderBook.forceChartsRefresh) {
        window.enhancedOrderBook.forceChartsRefresh(testData);
        console.log('✅ Called forceChartsRefresh with test data');
      } else {
        console.error('❌ Enhanced order book not available');
      }
    }
    
    // Make test function globally available
    window.testChartUpdate = testChartUpdate;

    // ========================================
    // Enhanced Yin Yang Order Book System
    // ========================================
    
    class YinYangOrderBookSystem {
      constructor() {
        this.selectedOutcome = null;
        this.selectedSide = null;
        this.outcomes = [];
        this.isInitialized = false;
      }
      
      // Generate dynamic outcome ranges based on current market
      generateOutcomeRanges(market) {
        if (!market || !market.options) return [];
        
        const ranges = [];
        
        // If market has specific volume ranges, use those
        if (market.volumeRanges) {
          return market.volumeRanges;
        }
        
        // Generate ranges based on market options
        market.options.forEach((option, index) => {
          const volume = Math.random() * 500000 + 50000; // $50k - $550k
          const probability = Math.random() * 95 + 1; // 1-96%
          const change = (Math.random() - 0.5) * 40; // -20% to +20%
          const yesPrice = (probability / 100).toFixed(3);
          const noPrice = ((100 - probability) / 100).toFixed(3);
          
          ranges.push({
            range: option.name,
            volume: `$${(volume / 1000).toFixed(0)}k Vol.`,
            probability: Math.round(probability),
            change: Math.round(change),
            yesPrice: `${yesPrice}¢`,
            noPrice: `${noPrice}¢`,
            optionIndex: index,
            isYang: option.isYang || option.name.toLowerCase().includes('yes') || index === 0
          });
        });
        
        return ranges;
      }
      
      // Render the order book interface
      renderOrderBook(market) {
        if (!market) return;
        
        this.outcomes = this.generateOutcomeRanges(market);
        const container = document.getElementById('orderBookEntries');
        if (!container) return;
        
        container.innerHTML = '';
        
        this.outcomes.forEach((outcome, index) => {
          const entryDiv = document.createElement('div');
          entryDiv.className = 'order-book-entry';
          entryDiv.style.cssText = `
            background: rgba(51,65,85,0.2);
            border: 1px solid #475569;
            border-radius: 12px;
            padding: 16px;
            transition: all 0.3s ease;
            cursor: pointer;
          `;
          
          entryDiv.onmouseenter = () => {
            entryDiv.style.borderColor = '#64748b';
            entryDiv.style.background = 'rgba(51,65,85,0.4)';
          };
          
          entryDiv.onmouseleave = () => {
            entryDiv.style.borderColor = '#475569';
            entryDiv.style.background = 'rgba(51,65,85,0.2)';
          };
          
          entryDiv.innerHTML = `
            <div style="display:grid;grid-template-columns:2fr 1fr 2fr;gap:16px;align-items:center;">
              <!-- Left: Outcome Info -->
              <div>
                <div style="color:#f8fafc;font-weight:700;font-size:1.1rem;margin-bottom:4px;">${outcome.range}</div>
                <div style="color:#64748b;font-size:0.85rem;display:flex;align-items:center;gap:4px;">
                  ${outcome.volume}
                  <svg style="width:12px;height:12px;" fill="currentColor" viewBox="0 0 20 20">
                    <path d="M10 12a2 2 0 100-4 2 2 0 000 4z"/>
                    <path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd"/>
                  </svg>
                </div>
              </div>

              <!-- Middle: Probability -->
              <div style="text-align:center;">
                <div style="display:flex;align-items:center;justify-content:center;gap:8px;">
                  <span style="color:#f8fafc;font-weight:800;font-size:1.5rem;">${outcome.probability}%</span>
                  <span style="font-size:0.85rem;font-weight:700;color:${outcome.change > 0 ? '#10b981' : '#ef4444'};">
                    ${outcome.change > 0 ? '+' : ''}${outcome.change}%
                  </span>
                </div>
              </div>

              <!-- Right: Buy Buttons -->
              <div style="display:flex;gap:12px;">
                <!-- YES Button - Yang (Light) -->
                <button 
                  onclick="window.yinYangOrderBook.handleBuy(${index}, 'yes')"
                  style="flex:1;background:linear-gradient(135deg, #f1f5f9, #e2e8f0);color:#0f172a;font-weight:700;padding:12px 16px;border-radius:8px;border:2px solid #cbd5e1;transition:all 0.3s ease;box-shadow:0 2px 8px rgba(241,245,249,0.3);"
                  onmouseover="this.style.background='linear-gradient(135deg, #ffffff, #f1f5f9)';this.style.borderColor='#94a3b8';this.style.transform='translateY(-1px) scale(1.02)';"
                  onmouseout="this.style.background='linear-gradient(135deg, #f1f5f9, #e2e8f0)';this.style.borderColor='#cbd5e1';this.style.transform='none';"
                >
                  <div style="font-size:0.75rem;color:#475569;margin-bottom:2px;">陽 Buy Yes</div>
                  <div style="font-size:1.1rem;font-weight:800;">${outcome.yesPrice}</div>
                </button>

                <!-- NO Button - Yin (Dark) -->
                <button 
                  onclick="window.yinYangOrderBook.handleBuy(${index}, 'no')"
                  style="flex:1;background:linear-gradient(135deg, #1e293b, #0f172a);color:#f1f5f9;font-weight:700;padding:12px 16px;border-radius:8px;border:2px solid #475569;transition:all 0.3s ease;box-shadow:0 2px 8px rgba(30,41,59,0.5);"
                  onmouseover="this.style.background='linear-gradient(135deg, #334155, #1e293b)';this.style.borderColor='#64748b';this.style.transform='translateY(-1px) scale(1.02)';"
                  onmouseout="this.style.background='linear-gradient(135deg, #1e293b, #0f172a)';this.style.borderColor='#475569';this.style.transform='none';"
                >
                  <div style="font-size:0.75rem;color:#94a3b8;margin-bottom:2px;">陰 Buy No</div>
                  <div style="font-size:1.1rem;font-weight:800;">${outcome.noPrice}</div>
                </button>
              </div>
            </div>
          `;
          
          container.appendChild(entryDiv);
        });
        
        this.isInitialized = true;
      }
      
      // Handle buy button clicks
      handleBuy(outcomeIndex, side) {
        console.log(`🚀 TRADE BUTTON CLICKED: ${side.toUpperCase()} for outcome ${outcomeIndex}`);
        console.log('🎯 Current outcomes:', this.outcomes);
        
        // Add immediate visual feedback
        document.body.style.border = "5px solid #ff0000";
        setTimeout(() => document.body.style.border = "none", 1000);
        
        const outcome = this.outcomes[outcomeIndex];
        if (!outcome) {
          console.error('❌ No outcome found for index:', outcomeIndex);
          return;
        }
        
        console.log(`📊 BEFORE TRADE - Outcome probability: ${outcome.probability}%`);
        
        this.selectedOutcome = outcome;
        this.selectedSide = side;
        
        // Update selection feedback
        this.updateSelectionFeedback();
        
        // Simulate the buy in our trading system
        this.executeBuy(outcome, side);
        
        console.log(`💰 Buying ${side} for ${outcome.range} at ${side === 'yes' ? outcome.yesPrice : outcome.noPrice}`);
      }
      
      // Execute the buy and update charts
      async executeBuy(outcome, side) {
        console.log(`🔥 EXECUTING TRADE: ${side} for outcome with probability ${outcome.probability}%`);
        
        if (!currentMarket) {
          console.error('❌ No current market available');
          return;
        }
        
        // Determine the option index
        const optionIndex = outcome.optionIndex !== undefined ? outcome.optionIndex : 0;
        console.log(`📍 Using option index: ${optionIndex}`);
        
        // If side is 'no', we need to find the opposing option or create one
        let targetOptionIndex = optionIndex;
        if (side === 'no') {
          // For NO bets, either use a specific NO option or the opposing option
          const noOption = currentMarket.options.find(opt => 
            opt.name.toLowerCase().includes('no') || 
            opt.name.toLowerCase().includes('false') ||
            opt.name.toLowerCase().includes('反對')
          );
          if (noOption) {
            targetOptionIndex = currentMarket.options.indexOf(noOption);
          } else {
            // Use the next option as the opposing choice
            targetOptionIndex = (optionIndex + 1) % currentMarket.options.length;
          }
        }
        
        console.log(`🎯 Target option index: ${targetOptionIndex}`);
        
        // Random amount between 0.1 and 2 BNB for simulation
        const amount = 0.1 + Math.random() * 1.9;
        console.log(`💰 Trade amount: ${amount.toFixed(3)} BNB`);
        
        try {
          // BEFORE TRADE STATE
          console.log(`📊 BEFORE TRADE - Probability: ${outcome.probability}%`);
          
          // FIRST: Submit a real bet to the server to update probabilities
          const simulatedBetData = {
            marketId: currentMarket.id,
            bettorAddress: walletAddress || 'simulation_user_' + Date.now(),
            optionId: targetOptionIndex,
            amount: amount,
            transactionSignature: 'simulation_' + Date.now() + '_' + Math.random().toString(36)
          };
          
          console.log('🚀 SUBMITTING SIMULATED BET TO SERVER:', simulatedBetData);
          
          // Submit bet to server to update the database
          const betResponse = await fetch(`${API_BASE_URL}/bets`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(simulatedBetData)
          });
          
          let serverBetResult;
          if (betResponse.ok) {
            serverBetResult = await betResponse.json();
            console.log('✅ Server bet submitted successfully:', serverBetResult);
          } else {
            console.warn('⚠️ Server bet submission failed, continuing with local simulation');
            serverBetResult = { success: false };
          }
          
          // Execute the trade using our enhanced trading system (for compatibility)
          const tradeResult = await window.enhancedTrading.executeTrade(
            currentMarket.id,
            targetOptionIndex,
            amount,
            walletAddress || 'simulation_user'
          );
          
          console.log('💼 Local trade result:', tradeResult);
          
          if (tradeResult.success || serverBetResult.bet) {
            // Update the outcome probability based on the trade
            const impact = Math.min(amount * 5, 15); // Limit impact to 15%
            console.log(`📈 Calculated impact: ${impact}%`);
            
            const oldProbability = outcome.probability;
            
            if (side === 'yes') {
              outcome.probability = Math.min(95, outcome.probability + impact);
            } else {
              outcome.probability = Math.max(5, outcome.probability - impact);
            }
            
            console.log(`📊 AFTER TRADE - Probability changed from ${oldProbability}% to ${outcome.probability}%`);
            
            // Update price based on new probability
            outcome.yesPrice = `${(outcome.probability / 100).toFixed(3)}¢`;
            outcome.noPrice = `${((100 - outcome.probability) / 100).toFixed(3)}¢`;
            
            console.log(`💲 Updated prices - YES: ${outcome.yesPrice}, NO: ${outcome.noPrice}`);
            
            // Re-render the order book with updated data
            this.renderOrderBook(currentMarket);
            
            // CRITICAL: Fetch fresh data from server after bet submission
            console.log('🔄 FETCHING FRESH DATA FROM SERVER AFTER TRADE...');
            
            setTimeout(async () => {
              try {
                // Get updated probabilities from server
                const freshData = await getLMSRProbabilities(currentMarket.id);
                console.log('📊 FRESH SERVER DATA:', freshData);
                
                if (freshData && freshData.probabilities) {
                  const updatedDepth = {
                    probabilities: freshData.probabilities,
                    prices: freshData.prices,
                    shares: freshData.volumes || [1000, 1000],
                    totalVolume: freshData.total_volume || 1000
                  };
                  
                  console.log(`🔄 FORCING CHART REFRESH WITH FRESH SERVER DATA:`, updatedDepth);
                  
                  // Flash the chart containers to show something is happening
                  const probContainer = document.getElementById('probabilityChartContainer');
                  const distContainer = document.getElementById('distributionChartContainer');
                  if (probContainer) {
                    probContainer.style.border = "3px solid #00ff00";
                    setTimeout(() => probContainer.style.border = "none", 2000);
                  }
                  if (distContainer) {
                    distContainer.style.border = "3px solid #00ff00";
                    setTimeout(() => distContainer.style.border = "none", 2000);
                  }
                  
                  // Use the enhanced order book's force chart refresh with server data
                  window.enhancedOrderBook.forceChartsRefresh(updatedDepth);
                } else {
                  console.warn('⚠️ No fresh data received from server, using fallback');
                  // Fallback to old method
                  const updatedDepth = {
                    probabilities: currentMarket.options.map((_, i) => 
                      i === targetOptionIndex ? outcome.probability : (100 - outcome.probability)
                    ),
                    prices: currentMarket.options.map((_, i) => 
                      i === targetOptionIndex ? outcome.probability / 100 : (100 - outcome.probability) / 100
                    ),
                    shares: currentMarket.options.map((_, i) => 
                      i === targetOptionIndex ? 1000 + amount * 10 : 1000 - amount * 10
                    ),
                    totalVolume: 1000 + amount
                  };
                  window.enhancedOrderBook.forceChartsRefresh(updatedDepth);
                }
              } catch (error) {
                console.error('❌ Failed to fetch fresh server data:', error);
                // Fallback to local calculation
                const updatedDepth = {
                  probabilities: currentMarket.options.map((_, i) => 
                    i === targetOptionIndex ? outcome.probability : (100 - outcome.probability)
                  ),
                  prices: currentMarket.options.map((_, i) => 
                    i === targetOptionIndex ? outcome.probability / 100 : (100 - outcome.probability) / 100
                  ),
                  shares: currentMarket.options.map((_, i) => 
                    i === targetOptionIndex ? 1000 + amount * 10 : 1000 - amount * 10
                  ),
                  totalVolume: 1000 + amount
                };
                window.enhancedOrderBook.forceChartsRefresh(updatedDepth);
              }
            }, 1000); // Wait 1 second for server to process the bet
            
            // Show success message
            this.showTradeMessage(`✅ Simulated ${side.toUpperCase()} trade for ${outcome.range}`, 'success');
          } else {
            console.error('❌ Trade failed:', tradeResult);
          }
        } catch (error) {
          console.error('💥 Order book trade error:', error);
          this.showTradeMessage(`❌ Trade failed: ${error.message}`, 'error');
        }
      }
      
      // Update selection feedback display
      updateSelectionFeedback() {
        const feedback = document.getElementById('selectionFeedback');
        const selectedRange = document.getElementById('selectedRange');
        const selectedSide = document.getElementById('selectedSide');
        const selectedPrice = document.getElementById('selectedPrice');
        
        if (feedback && this.selectedOutcome && this.selectedSide) {
          selectedRange.textContent = this.selectedOutcome.range;
          selectedSide.textContent = this.selectedSide === 'yes' ? '陽 YES' : '陰 NO';
          selectedPrice.textContent = this.selectedSide === 'yes' ? this.selectedOutcome.yesPrice : this.selectedOutcome.noPrice;
          feedback.style.display = 'block';
        }
      }
      
      // Refresh charts after trade
      refreshCharts() {
        if (currentMarket && window.lmsrChartEngine) {
          setTimeout(() => {
            // Refresh both charts
            window.lmsrChartEngine.createProbabilityChart('probabilityChartContainer', currentMarket.id);
            window.lmsrChartEngine.createCurrentDistributionChart('distributionChartContainer', currentMarket.id);
            
            // Update market info
            renderMarketInfo(currentMarket);
            updateTradePanel();
          }, 500);
        }
      }
      
      // Show trade message
      showTradeMessage(message, type) {
        const messageEl = document.getElementById('tradeMsg');
        if (messageEl) {
          messageEl.innerHTML = `<div style="color:${type === 'success' ? '#10b981' : '#ef4444'};font-weight:600;">${message}</div>`;
          setTimeout(() => {
            messageEl.innerHTML = '';
          }, 3000);
        }
      }
    }
    
    // Initialize the order book system
    window.yinYangOrderBook = new YinYangOrderBookSystem();

    // ========================================
    // Market Simulation and Enhanced Trading Logic
    // ========================================
    
    class YinYangMarketSimulator {
      constructor() {
        this.simulationData = new Map();
        this.isSimulating = false;
      }
      
      // Generate realistic market data with Yin Yang philosophy
      generateMarketSimulation(marketId, options) {
        const simulation = {
          timePoints: [],
          probabilities: [],
          volumes: [],
          trades: []
        };
        
        // Generate 24 hours of data points (every hour)
        const now = Date.now();
        const hourMs = 60 * 60 * 1000;
        
        for (let i = 23; i >= 0; i--) {
          const timestamp = now - (i * hourMs);
          simulation.timePoints.push(new Date(timestamp));
          
          // Generate probabilities that follow Yin Yang balance principles
          const optionProbs = options.map((option, index) => {
            const isYangOption = option.name.toLowerCase().includes('yes') || 
                               option.name.toLowerCase().includes('true') || 
                               option.name.toLowerCase().includes('支持') || 
                               index === 0;
            
            // Yang options tend to be more volatile (optimistic swings)
            // Yin options tend to be more stable (conservative)
            let baseProb = 100 / options.length; // Start balanced
            
            if (isYangOption) {
              // Yang: More dynamic, influenced by "positive energy"
              const yangVariation = 15 * Math.sin((i / 24) * Math.PI * 2) + 
                                   10 * Math.random() - 5;
              baseProb += yangVariation;
            } else {
              // Yin: More stable, gradual changes
              const yinVariation = 8 * Math.cos((i / 24) * Math.PI * 1.5) + 
                                  5 * Math.random() - 2.5;
              baseProb += yinVariation;
            }
            
            return Math.max(5, Math.min(95, baseProb)); // Keep within bounds
          });
          
          // Normalize probabilities to sum to 100%
          const sum = optionProbs.reduce((a, b) => a + b, 0);
          const normalizedProbs = optionProbs.map(p => (p / sum) * 100);
          
          simulation.probabilities.push(normalizedProbs);
          
          // Generate trading volume (higher volume during "market hours")
          const hourOfDay = new Date(timestamp).getHours();
          const isActiveHour = hourOfDay >= 9 && hourOfDay <= 21; // 9 AM to 9 PM
          const baseVolume = isActiveHour ? 0.5 + Math.random() * 2 : 0.1 + Math.random() * 0.3;
          simulation.volumes.push(baseVolume);
          
          // Generate individual trades
          const numTrades = Math.floor(Math.random() * 5) + 1;
          for (let t = 0; t < numTrades; t++) {
            const optionIndex = Math.floor(Math.random() * options.length);
            const amount = 0.01 + Math.random() * 0.5;
            simulation.trades.push({
              timestamp,
              optionIndex,
              amount,
              type: 'buy'
            });
          }
        }
        
        this.simulationData.set(marketId, simulation);
        return simulation;
      }
      
      // Get current simulated probabilities
      getCurrentProbabilities(marketId, options) {
        let simulation = this.simulationData.get(marketId);
        if (!simulation) {
          simulation = this.generateMarketSimulation(marketId, options);
        }
        
        const latest = simulation.probabilities[simulation.probabilities.length - 1];
        return {
          probabilities: latest,
          prices: latest.map(prob => prob / 100), // Convert to price per share
          volume: simulation.volumes[simulation.volumes.length - 1]
        };
      }
      
      // Simulate a new trade affecting market probabilities
      simulateTrade(marketId, optionIndex, amount, options) {
        let simulation = this.simulationData.get(marketId);
        if (!simulation) {
          simulation = this.generateMarketSimulation(marketId, options);
        }
        
        // Add trade to simulation
        simulation.trades.push({
          timestamp: Date.now(),
          optionIndex,
          amount,
          type: 'buy'
        });
        
        // Update probabilities based on trade (LMSR-like logic)
        const currentProbs = simulation.probabilities[simulation.probabilities.length - 1];
        const newProbs = [...currentProbs];
        
        // Increase probability of bought option, decrease others
        const impact = Math.min(amount * 10, 20); // Limit impact
        newProbs[optionIndex] += impact;
        
        // Redistribute from other options
        const reduction = impact / (options.length - 1);
        for (let i = 0; i < newProbs.length; i++) {
          if (i !== optionIndex) {
            newProbs[i] = Math.max(5, newProbs[i] - reduction);
          }
        }
        
        // Normalize
        const sum = newProbs.reduce((a, b) => a + b, 0);
        const normalizedProbs = newProbs.map(p => (p / sum) * 100);
        
        // Add new data point
        simulation.timePoints.push(new Date());
        simulation.probabilities.push(normalizedProbs);
        simulation.volumes.push(simulation.volumes[simulation.volumes.length - 1] + amount);
        
        return this.getCurrentProbabilities(marketId, options);
      }
    }
    
    // Initialize market simulator
    window.yinYangSimulator = new YinYangMarketSimulator();
    
    // ========================================
    // Enhanced Trading Logic with Multiple Options
    // ========================================
    
    class EnhancedTradingEngine {
      constructor() {
        this.marketOptions = new Map();
        this.userPositions = new Map();
      }
      
      // Create a market with up to 6 options following Yin Yang principles
      createMarket(marketData) {
        const options = marketData.options || [];
        
        // Ensure we have at least 2 options, max 6
        while (options.length < 2) {
          const count = options.length;
          options.push({
            name: count === 0 ? 'YES ☀️' : 'NO 🌙',
            image: null,
            isYang: count === 0
          });
        }
        
        // Limit to 6 options maximum for UI clarity
        if (options.length > 6) {
          options.splice(6);
        }
        
        // Auto-detect and tag Yin/Yang nature
        options.forEach((option, index) => {
          if (!option.hasOwnProperty('isYang')) {
            const isYangOption = option.name.toLowerCase().includes('yes') || 
                               option.name.toLowerCase().includes('true') || 
                               option.name.toLowerCase().includes('支持') || 
                               option.name.toLowerCase().includes('positive') ||
                               index === 0;
            option.isYang = isYangOption;
          }
        });
        
        this.marketOptions.set(marketData.id, options);
        return options;
      }
      
      // Calculate trading price with Yin Yang bonuses
      calculateTradePrice(marketId, optionIndex, amount, options) {
        const probabilities = window.yinYangSimulator.getCurrentProbabilities(marketId, options);
        const basePrice = probabilities.prices[optionIndex];
        
        // Apply Yin Yang philosophy bonuses
        const option = options[optionIndex];
        let bonus = 1.0;
        
        if (option.isYang) {
          // Yang options get slight discount for optimistic traders
          bonus = 0.98;
        } else {
          // Yin options get slight premium for contrarian traders
          bonus = 1.02;
        }
        
        // Volume impact
        const volumeImpact = Math.min(amount * 0.01, 0.05); // Max 5% impact
        const finalPrice = basePrice * bonus * (1 + volumeImpact);
        
        return {
          pricePerShare: finalPrice,
          totalCost: amount,
          sharesReceived: amount / finalPrice,
          platformFee: amount * 0.01, // 1% fee
          netAmount: amount * 0.99
        };
      }
      
      // Execute trade with enhanced logic
      async executeTrade(marketId, optionIndex, amount, userAddress) {
        const options = this.marketOptions.get(marketId) || currentMarket.options;
        const tradeDetails = this.calculateTradePrice(marketId, optionIndex, amount, options);
        
        // Update user positions
        const userKey = `${userAddress}-${marketId}`;
        if (!this.userPositions.has(userKey)) {
          this.userPositions.set(userKey, {});
        }
        
        const positions = this.userPositions.get(userKey);
        if (!positions[optionIndex]) {
          positions[optionIndex] = { shares: 0, invested: 0 };
        }
        
        positions[optionIndex].shares += tradeDetails.sharesReceived;
        positions[optionIndex].invested += tradeDetails.netAmount;
        
        // Update market simulation
        window.yinYangSimulator.simulateTrade(marketId, optionIndex, amount, options);
        
        return {
          success: true,
          tradeDetails,
          newPosition: positions[optionIndex],
          message: `Successfully purchased ${tradeDetails.sharesReceived.toFixed(3)} shares of ${options[optionIndex].name}`
        };
      }
      
      // Get user's portfolio for a market
      getUserPortfolio(marketId, userAddress) {
        const userKey = `${userAddress}-${marketId}`;
        return this.userPositions.get(userKey) || {};
      }
    }
    
    // Initialize trading engine
    window.enhancedTrading = new EnhancedTradingEngine();

    // ========================================
    // Define LMSRChartEngine fallback BEFORE any other code
    class LMSRChartEngineFallback {
      constructor() {
        console.log('Using simple LMSR chart engine - basic functionality');
        this.chartInstances = {}; // Track chart instances
      }
      
      destroyChart(chartId) {
        if (this.chartInstances[chartId]) {
          this.chartInstances[chartId].destroy();
          delete this.chartInstances[chartId];
        }
      }
      
      async createProbabilityChart(containerId, marketId) {
        console.log('Creating simple probability chart for market', marketId);
        const container = document.getElementById(containerId) || document.querySelector(`#${containerId}`);
        if (!container) return null;

        try {
          // Destroy existing chart if it exists
          this.destroyChart('probabilityChart');
          
          // Get LIVE market data from prediction market engine
          let market, marketDepth, probabilities, prices;
          
          if (window.predictionMarket && window.predictionMarket.markets.has(marketId)) {
            // Use live data from prediction market engine
            marketDepth = window.predictionMarket.getMarketDepth(marketId);
            market = window.predictionMarket.markets.get(marketId);
            probabilities = marketDepth.probabilities;
            prices = marketDepth.prices;
            console.log('📊 Using LIVE market data for probability chart:', { 
              marketId,
              probabilities, 
              prices,
              shares: market.shares,
              totalVolume: marketDepth.totalVolume
            });
          } else {
            console.warn('⚠️ Prediction market not found, using fallback data');
            // Fallback to current market data
            market = window.currentMarket;
            if (!market || !market.options) {
              throw new Error('No market data available');
            }
            
            // Generate simulation data as fallback
            const simulation = window.yinYangSimulator.generateMarketSimulation(marketId, market.options);
            probabilities = simulation.probabilities[simulation.probabilities.length - 1]; // Get latest
            prices = probabilities.map(p => p / 100); // Convert to prices
            console.log('📊 Using fallback simulation data:', { probabilities, prices });
          }

          // Create fresh canvas
          container.innerHTML = '';
          const canvas = document.createElement('canvas');
          canvas.id = 'probabilityChart';
          canvas.width = container.offsetWidth || 400;
          canvas.height = container.offsetHeight || 300;
          container.appendChild(canvas);

          if (typeof Chart !== 'undefined') {
            const ctx = canvas.getContext('2d');
            
            // Create time series showing current and projected probabilities
            const timeLabels = [];
            const timeSeriesData = [];
            
            // Generate 20 time points for smooth visualization using LIVE data
            for (let i = 0; i < 20; i++) {
              const time = new Date(Date.now() - (19 - i) * 60000); // Last 20 minutes
              timeLabels.push(time.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }));
              
              // Use LIVE probabilities for all time points (real-time market state)
              timeSeriesData.push([...probabilities]); // Use current live probabilities
            }
            
            console.log('📈 Chart will show probabilities:', probabilities);
            console.log('📊 Time series data points:', timeSeriesData.length);
            
            const chartInstance = new Chart(ctx, {
              type: 'line',
              data: {
                labels: timeLabels,
                datasets: market.options.map((option, index) => {
                  // Extract probability data for this option over time
                  const probData = timeSeriesData.map(probArray => probArray[index]);
                  
                  // Determine Yin Yang colors
                  const isYangOption = option.name.toLowerCase().includes('yes') || 
                                     option.name.toLowerCase().includes('true') || 
                                     option.name.toLowerCase().includes('支持') || 
                                     index === 0;
                  const isYinOption = option.name.toLowerCase().includes('no') || 
                                    option.name.toLowerCase().includes('false') || 
                                    option.name.toLowerCase().includes('反對') || 
                                    index === 1;
                  
                  let borderColor, backgroundColor;
                  if (isYangOption) {
                    borderColor = '#06b6d4';
                    backgroundColor = 'rgba(6, 182, 212, 0.15)';
                  } else if (isYinOption) {
                    borderColor = '#9ca3af';
                    backgroundColor = 'rgba(156, 163, 175, 0.15)';
                  } else {
                    const yinYangColors = [
                      { border: '#0891b2', bg: 'rgba(8, 145, 178, 0.15)' },
                      { border: '#6b7280', bg: 'rgba(107, 114, 128, 0.15)' },
                      { border: '#0284c7', bg: 'rgba(2, 132, 199, 0.15)' },
                      { border: '#4b5563', bg: 'rgba(75, 85, 99, 0.15)' }
                    ];
                    const colorSet = yinYangColors[index % yinYangColors.length];
                    borderColor = colorSet.border;
                    backgroundColor = colorSet.bg;
                  }
                  
                  return {
                    label: `${isYangOption ? '☀️' : (isYinOption ? '🌙' : '⚡')} ${option.name}`,
                    data: probData,
                    borderColor: borderColor,
                    backgroundColor: backgroundColor,
                    tension: 0.3,
                    borderWidth: 3,
                    pointBackgroundColor: borderColor,
                    pointBorderColor: '#ffffff',
                    pointBorderWidth: 2,
                    pointRadius: 4,
                    pointHoverRadius: 8,
                    fill: true
                  };
                })
              },
              options: {
                responsive: true,
                plugins: {
                  legend: { 
                    labels: { 
                      color: '#ffffff',
                      font: { size: 14, weight: 'bold' },
                      padding: 15,
                      usePointStyle: true
                    } 
                  },
                  title: { 
                    display: true, 
                    text: '☯ Market Confidence Over Time', 
                    color: '#ffffff',
                    font: { size: 16, weight: 'bold' }
                  },
                  tooltip: {
                    callbacks: {
                      label: function(context) {
                        const label = context.dataset.label || '';
                        const value = context.parsed.y || 0;
                        return `${label}: ${value.toFixed(1)}% confidence`;
                      }
                    },
                    backgroundColor: 'rgba(15, 23, 42, 0.9)',
                    titleColor: '#06b6d4',
                    bodyColor: '#e2e8f0',
                    borderColor: '#334155',
                    borderWidth: 1
                  }
                },
                scales: {
                  y: { 
                    beginAtZero: true, 
                    max: 100,
                    ticks: { 
                      color: '#9ca3af',
                      callback: function(value) {
                        return value + '%';
                      }
                    },
                    title: { 
                      display: true, 
                      text: 'Market Confidence (%)', 
                      color: '#9ca3af',
                      font: { weight: 'bold' }
                    },
                    grid: {
                      color: 'rgba(156, 163, 175, 0.1)'
                    }
                  },
                  x: { 
                    ticks: { color: '#9ca3af' },
                    grid: {
                      color: 'rgba(156, 163, 175, 0.1)'
                    }
                  }
                },
                animation: {
                  duration: 1500,
                  easing: 'easeOutQuart'
                },
                interaction: {
                  intersect: false,
                  mode: 'index'
                }
              }
            });
            
            // Store chart instance for later cleanup
            this.chartInstances['probabilityChart'] = chartInstance;
          } else {
            container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#9ca3af;font-size:14px;">Chart.js not available</div>';
          }
        } catch (error) {
          console.error('Chart creation failed:', error);
          container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#ff6b6b;font-size:14px;">⚠️ Chart failed to load</div>';
        }
        return null;
      }
      
      async createCurrentDistributionChart(containerId, marketId) {
        console.log('Creating simple distribution chart for market', marketId);
        const container = document.getElementById(containerId) || document.querySelector(`#${containerId}`);
        if (!container) return null;

        try {
          // Destroy existing chart if it exists
          this.destroyChart('distributionChart');
          
          // Get LIVE market data from prediction market engine
          let market, probabilities;
          
          if (window.predictionMarket && window.predictionMarket.markets.has(marketId)) {
            // Use live data from prediction market engine
            const marketDepth = window.predictionMarket.getMarketDepth(marketId);
            market = window.predictionMarket.markets.get(marketId);
            probabilities = marketDepth.probabilities;
            console.log('📊 Using LIVE distribution data:', { 
              marketId,
              probabilities,
              shares: market.shares,
              volume: marketDepth.volume24h
            });
          } else {
            console.warn('⚠️ Prediction market not found for distribution, using fallback');
            // Fallback to current market data
            market = window.currentMarket;
            if (!market || !market.options) {
              throw new Error('No market data available');
            }
            
            // Get current probabilities from simulation as fallback
            const currentData = window.yinYangSimulator.getCurrentProbabilities(marketId, market.options);
            probabilities = currentData.probabilities;
            console.log('📊 Using fallback distribution data:', probabilities);
          }

          // Create fresh canvas
          container.innerHTML = '';
          const canvas = document.createElement('canvas');
          canvas.id = 'distributionChart';
          canvas.width = container.offsetWidth || 400;
          canvas.height = container.offsetHeight || 300;
          container.appendChild(canvas);

          if (typeof Chart !== 'undefined') {
            const ctx = canvas.getContext('2d');
            
            const chartInstance = new Chart(ctx, {
              type: 'doughnut',
              data: {
                labels: market.options.map((option, index) => {
                  // Add Yin Yang symbols to labels
                  const isYangOption = option.name.toLowerCase().includes('yes') || 
                                     option.name.toLowerCase().includes('true') || 
                                     option.name.toLowerCase().includes('支持') || 
                                     index === 0;
                  const isYinOption = option.name.toLowerCase().includes('no') || 
                                    option.name.toLowerCase().includes('false') || 
                                    option.name.toLowerCase().includes('反對') || 
                                    index === 1;
                  
                  const symbol = isYangOption ? '☀️' : (isYinOption ? '🌙' : '⚡');
                  return `${symbol} ${option.name} (${probabilities[index].toFixed(1)}%)`;
                }),
                datasets: [{
                  data: probabilities,
                  backgroundColor: probabilities.map((prob, index) => {
                    const option = market.options[index];
                    
                    // Determine Yin Yang colors based on option type
                    const isYangOption = option.name.toLowerCase().includes('yes') || 
                                       option.name.toLowerCase().includes('true') || 
                                       option.name.toLowerCase().includes('支持') || 
                                       index === 0;
                    const isYinOption = option.name.toLowerCase().includes('no') || 
                                      option.name.toLowerCase().includes('false') || 
                                      option.name.toLowerCase().includes('反對') || 
                                      index === 1;
                    
                    if (isYangOption) {
                      return '#06b6d4'; // Yang - Bright cyan
                    } else if (isYinOption) {
                      return '#9ca3af'; // Yin - Gray
                    } else {
                      // Alternate Yin Yang colors for additional options
                      const yinYangPalette = [
                        '#0891b2', // Light Yang
                        '#6b7280', // Deep Yin
                        '#0284c7', // Bright Yang
                        '#4b5563'  // Dark Yin
                      ];
                      return yinYangPalette[index % yinYangPalette.length];
                    }
                  }),
                  borderColor: '#1e293b',
                  borderWidth: 3,
                  hoverBorderColor: '#ffffff',
                  hoverBorderWidth: 4
                }]
              },
              options: {
                responsive: true,
                plugins: {
                  legend: { 
                    labels: { 
                      color: '#ffffff',
                      font: { size: 14, weight: 'bold' },
                      padding: 20,
                      usePointStyle: true,
                      pointStyle: 'circle'
                    },
                    position: 'bottom'
                  },
                  title: { 
                    display: true, 
                    text: '☯ Current Market Distribution', 
                    color: '#ffffff',
                    font: { size: 16, weight: 'bold' },
                    padding: { bottom: 20 }
                  },
                  tooltip: {
                    callbacks: {
                      label: function(context) {
                        const label = context.label || '';
                        const value = context.parsed || 0;
                        return `${label}: ${value.toFixed(1)}% confidence`;
                      }
                    },
                    backgroundColor: 'rgba(15, 23, 42, 0.9)',
                    titleColor: '#06b6d4',
                    bodyColor: '#e2e8f0',
                    borderColor: '#334155',
                    borderWidth: 1
                  }
                },
                animation: {
                  animateRotate: true,
                  animateScale: true,
                  duration: 1500,
                  easing: 'easeOutQuart'
                },
                elements: {
                  arc: {
                    borderJoinStyle: 'round'
                  }
                }
              }
            });
            
            // Store chart instance for later cleanup
            this.chartInstances['distributionChart'] = chartInstance;
          } else {
            container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#9ca3af;font-size:14px;">Chart.js not available</div>';
          }
        } catch (error) {
          console.error('Chart creation failed:', error);
          container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#ff6b6b;font-size:14px;">⚠️ Chart failed to load</div>';
        }
        return null;
      }
    }

    // Check if the real LMSRChartEngine loaded, if not use fallback
    if (typeof LMSRChartEngine === 'undefined') {
      console.warn('Using simple LMSR chart engine');
      window.LMSRChartEngine = LMSRChartEngineFallback;
    }

    // Initialize chart engine ONLY ONCE
    if (!window.lmsrChartEngine) {
      window.lmsrChartEngine = new (window.LMSRChartEngine || LMSRChartEngineFallback)();
      console.log('✅ Simple chart engine initialized');
    }

    // Initialize Web3 and BSC connection
    let wallet = null;
    let bnbBalance = 0;
    let isAdmin = false;
    
    // LMSR Chart initialization with simulated trading and USD pricing
    function initializeSimpleCharts() {
      console.log('Initializing LMSR charts with trade sequence analysis...');
      
      // Trade sequence to analyze
      const tradeSequence = [1, 5, 10, 50, 100, 20, 10, 200, 500, 1000];
      const liquidityParams = [10, 100, 1000]; // b values
      const BNB_USD_RATE = 600;
      
      // Current liquidity parameter (rotate every 30 seconds)
      const currentBIndex = Math.floor(Date.now() / 30000) % liquidityParams.length;
      const currentB = liquidityParams[currentBIndex];
      
      // Calculate LMSR prices: p_i = e^(q_i/b) / Σ(e^(q_j/b))
      function calculateLMSRPrice(qYes, qNo, b) {
        const expYes = Math.exp(qYes / b);
        const expNo = Math.exp(qNo / b);
        const sum = expYes + expNo;
        return expYes / sum;
      }
      
      // Calculate cost to buy shares: C(q') - C(q)
      function calculateTradeCost(qYes, qNo, deltaQ, b) {
        const currentCost = b * Math.log(Math.exp(qYes / b) + Math.exp(qNo / b));
        const newCost = b * Math.log(Math.exp((qYes + deltaQ) / b) + Math.exp(qNo / b));
        return newCost - currentCost;
      }
      
      // Solve for shares given USD amount
      function solveSharesForAmount(qYes, qNo, usdAmount, b) {
        const bnbAmount = usdAmount / BNB_USD_RATE;
        let deltaQ = 0;
        let step = 0.1;
        let cost = 0;
        
        // Simple iterative solver
        for (let i = 0; i < 1000; i++) {
          cost = calculateTradeCost(qYes, qNo, deltaQ, b);
          if (Math.abs(cost - bnbAmount) < 0.0001) break;
          if (cost < bnbAmount) {
            deltaQ += step;
          } else {
            deltaQ -= step;
            step *= 0.5;
          }
        }
        return deltaQ;
      }
      
      // Run trade sequence simulation
      let qYes = 0;
      let qNo = 0;
      const tradeResults = [];
      
      tradeSequence.forEach((amount, index) => {
        const priceBefore = calculateLMSRPrice(qYes, qNo, currentB);
        const deltaQ = solveSharesForAmount(qYes, qNo, amount, currentB);
        qYes += deltaQ;
        const priceAfter = calculateLMSRPrice(qYes, qNo, currentB);
        const costPerShare = amount / deltaQ;
        
        tradeResults.push({
          trade: index + 1,
          amount: amount,
          deltaQ: deltaQ,
          cumulativeQ: qYes,
          priceBefore: priceBefore,
          priceAfter: priceAfter,
          costPerShare: costPerShare
        });
      });
      
      // Calculate current price and percentages
      const currentPrice = calculateLMSRPrice(qYes, qNo, currentB);
      const yesPercentage = Math.round(currentPrice * 100);
      const noPercentage = 100 - yesPercentage;
      
      // Probability Chart with Trade Sequence Results
      const probContainer = document.getElementById('probabilityChartContainer');
      if (probContainer) {
        const liquidityColors = {10: '#ef4444', 100: '#eab308', 1000: '#10b981'};
        const liquidityNames = {10: 'Thin', 100: 'Medium', 1000: 'Deep'};
        
        probContainer.innerHTML = `
          <div style="display:flex;flex-direction:column;height:100%;background:rgba(31,41,55,0.5);border-radius:8px;padding:20px;">
            <div style="color:#e5e7eb;font-weight:600;text-align:center;margin-bottom:12px;">
              📊 LMSR Trade Sequence Analysis (b=${currentB} - ${liquidityNames[currentB]} Liquidity)
            </div>
            
            <div style="flex:1;display:flex;flex-direction:column;">
              <!-- Current Market State -->
              <div style="display:flex;justify-content:space-between;margin-bottom:16px;padding:12px;background:rgba(55,65,81,0.5);border-radius:6px;">
                <div style="text-align:center;">
                  <div style="color:${liquidityColors[currentB]};font-size:24px;font-weight:700;">${yesPercentage}%</div>
                  <div style="color:#9ca3af;font-size:12px;">Final YES Price</div>
                  <div style="color:#9ca3af;font-size:10px;">${qYes.toFixed(1)} shares</div>
                </div>
                <div style="text-align:center;">
                  <div style="color:#6b7280;font-size:16px;font-weight:600;">Total Volume</div>
                  <div style="color:#e5e7eb;font-size:14px;">$${tradeSequence.reduce((a,b) => a+b, 0)}</div>
                  <div style="color:#9ca3af;font-size:10px;">${tradeResults.length} trades</div>
                </div>
                <div style="text-align:center;">
                  <div style="color:#ef4444;font-size:24px;font-weight:700;">${noPercentage}%</div>
                  <div style="color:#9ca3af;font-size:12px;">Final NO Price</div>
                  <div style="color:#9ca3af;font-size:10px;">${qNo.toFixed(1)} shares</div>
                </div>
              </div>
              
              <!-- Trade Results Table -->
              <div style="flex:1;overflow-y:auto;">
                <table style="width:100%;font-size:11px;color:#e5e7eb;">
                  <thead style="background:rgba(55,65,81,0.7);position:sticky;top:0;">
                    <tr>
                      <th style="padding:6px 4px;text-align:left;">#</th>
                      <th style="padding:6px 4px;text-align:right;">Amount</th>
                      <th style="padding:6px 4px;text-align:right;">Shares Δq</th>
                      <th style="padding:6px 4px;text-align:right;">Price Before</th>
                      <th style="padding:6px 4px;text-align:right;">Price After</th>
                      <th style="padding:6px 4px;text-align:right;">$/Share</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${tradeResults.map(result => `
                      <tr style="border-bottom:1px solid rgba(75,85,99,0.3);">
                        <td style="padding:4px;color:${liquidityColors[currentB]};font-weight:600;">${result.trade}</td>
                        <td style="padding:4px;text-align:right;">$${result.amount}</td>
                        <td style="padding:4px;text-align:right;">${result.deltaQ.toFixed(2)}</td>
                        <td style="padding:4px;text-align:right;">${(result.priceBefore*100).toFixed(1)}%</td>
                        <td style="padding:4px;text-align:right;">${(result.priceAfter*100).toFixed(1)}%</td>
                        <td style="padding:4px;text-align:right;">$${result.costPerShare.toFixed(2)}</td>
                      </tr>
                    `).join('')}
                  </tbody>
                </table>
              </div>
            </div>
            
            <div style="text-align:center;color:#6b7280;font-size:10px;margin-top:8px;border-top:1px solid #374151;padding-top:6px;">
              Sequence: [${tradeSequence.join(', ')}] USD | Rotates b=${liquidityParams.join('→')} every 30s
            </div>
          </div>
        `;
      }
      
      // Distribution Chart with Continuous Purchase Simulation
      const distContainer = document.getElementById('distributionChartContainer');
      if (distContainer) {
        // Simulate continuous $1000 purchase in 50 steps
        const totalAmount = 1000;
        const steps = 50;
        const stepAmount = totalAmount / steps;
        
        let contQYes = 0;
        let contQNo = 0;
        const continuousResults = [];
        
        for (let i = 1; i <= steps; i++) {
          const priceBefore = calculateLMSRPrice(contQYes, contQNo, currentB);
          const deltaQ = solveSharesForAmount(contQYes, contQNo, stepAmount, currentB);
          contQYes += deltaQ;
          const priceAfter = calculateLMSRPrice(contQYes, contQNo, currentB);
          
          continuousResults.push({
            step: i,
            cumulativeAmount: i * stepAmount,
            price: priceAfter,
            totalShares: contQYes
          });
        }
        
        // Show order dependency example
        const orderA_first = solveSharesForAmount(0, 0, 100, currentB);
        const orderA_priceFirst = 100 / orderA_first;
        const orderA_qAfterFirst = orderA_first;
        
        const orderB_second = solveSharesForAmount(orderA_qAfterFirst, 0, 100, currentB);
        const orderB_priceSecond = 100 / orderB_second;
        
        // Reverse order
        const orderB_first = solveSharesForAmount(0, 0, 100, currentB);
        const orderB_priceFirst = 100 / orderB_first;
        const orderB_qAfterFirst = orderB_first;
        
        const orderA_second = solveSharesForAmount(orderB_qAfterFirst, 0, 100, currentB);
        const orderA_priceSecond = 100 / orderA_second;
        
        distContainer.innerHTML = `
          <div style="display:flex;flex-direction:column;height:100%;background:rgba(31,41,55,0.5);border-radius:8px;padding:20px;">
            <div style="color:#e5e7eb;font-weight:600;text-align:center;margin-bottom:12px;">
              📈 Continuous Purchase & Order Effects (b=${currentB})
            </div>
            
            <!-- Price Evolution Chart -->
            <div style="margin-bottom:16px;padding:12px;background:rgba(55,65,81,0.5);border-radius:6px;">
              <div style="color:#e5e7eb;font-size:12px;margin-bottom:8px;">$1000 Purchase in ${steps} steps - Price Evolution:</div>
              <div style="height:60px;position:relative;background:#1f2937;border-radius:4px;overflow:hidden;">
                <div style="position:absolute;bottom:0;left:0;right:0;height:2px;background:${liquidityColors[currentB]};"></div>
                ${continuousResults.map((result, i) => `
                  <div style="position:absolute;bottom:2px;left:${(i/steps)*100}%;width:${100/steps}%;height:${result.price*100}%;background:linear-gradient(to top, ${liquidityColors[currentB]}20, ${liquidityColors[currentB]}60);border-right:1px solid rgba(0,0,0,0.1);"></div>
                `).join('')}
              </div>
              <div style="display:flex;justify-content:space-between;color:#9ca3af;font-size:10px;margin-top:4px;">
                <span>Start: ${(continuousResults[0]?.price*100 || 0).toFixed(1)}%</span>
                <span>End: ${(continuousResults[steps-1]?.price*100 || 0).toFixed(1)}%</span>
              </div>
            </div>
            
            <!-- Order Dependency Example -->
            <div style="margin-bottom:12px;">
              <div style="color:#e5e7eb;font-size:12px;margin-bottom:8px;">Order Dependency - Two $100 trades:</div>
              <div style="display:flex;gap:8px;">
                <div style="flex:1;padding:8px;background:rgba(16,185,129,0.1);border:1px solid #10b981;border-radius:4px;">
                  <div style="color:#10b981;font-size:11px;font-weight:600;">A buys first</div>
                  <div style="color:#e5e7eb;font-size:10px;">A pays: $${orderA_priceFirst.toFixed(2)}/share</div>
                  <div style="color:#e5e7eb;font-size:10px;">B pays: $${orderB_priceSecond.toFixed(2)}/share</div>
                </div>
                <div style="flex:1;padding:8px;background:rgba(239,68,68,0.1);border:1px solid #ef4444;border-radius:4px;">
                  <div style="color:#ef4444;font-size:11px;font-weight:600;">B buys first</div>
                  <div style="color:#e5e7eb;font-size:10px;">B pays: $${orderB_priceFirst.toFixed(2)}/share</div>
                  <div style="color:#e5e7eb;font-size:10px;">A pays: $${orderA_priceSecond.toFixed(2)}/share</div>
                </div>
              </div>
              <div style="color:#9ca3af;font-size:9px;margin-top:4px;text-align:center;">
                First buyer advantage: $${(Math.max(orderA_priceSecond, orderB_priceSecond) - Math.min(orderA_priceFirst, orderB_priceFirst)).toFixed(2)}/share
              </div>
            </div>
            
            <!-- Liquidity Comparison -->
            <div style="flex:1;">
              <div style="color:#e5e7eb;font-size:12px;margin-bottom:6px;">Liquidity Impact Comparison:</div>
              ${liquidityParams.map(b => {
                const testPrice = calculateLMSRPrice(10, 0, b);
                return `
                  <div style="display:flex;justify-content:space-between;align-items:center;padding:4px 8px;margin-bottom:2px;background:rgba(${b === currentB ? '255,255,255' : '75,85,99'},0.${b === currentB ? '1' : '05'});border-radius:3px;">
                    <span style="color:${liquidityColors[b]};font-size:11px;font-weight:600;">b=${b}</span>
                    <span style="color:#e5e7eb;font-size:10px;">10 shares → ${(testPrice*100).toFixed(1)}%</span>
                    <span style="color:#9ca3af;font-size:9px;">${liquidityNames[b]}</span>
                  </div>
                `;
              }).join('')}
            </div>
            
            <div style="text-align:center;color:#6b7280;font-size:9px;margin-top:6px;border-top:1px solid #374151;padding-top:4px;">
              Lower b = more price impact | Higher b = smoother prices
            </div>
          </div>
        `;
      }
      
      console.log(`✅ LMSR trade analysis initialized with b=${currentB}`);
      if (probContainer) {
        probContainer.innerHTML = `
          <div style="display:flex;flex-direction:column;height:100%;background:rgba(31,41,55,0.5);border-radius:8px;padding:20px;">
            <div style="color:#e5e7eb;font-weight:600;text-align:center;margin-bottom:12px;">� LMSR Live Pricing (1 BNB = $${BNB_USD_RATE})</div>
            
            <div style="flex:1;display:flex;align-items:center;justify-content:space-between;">
              <div style="text-align:center;flex:1;padding:0 10px;">
                <div style="color:#10b981;font-size:28px;font-weight:700;margin-bottom:4px;">${yesPercentage}%</div>
                <div style="color:#9ca3af;font-size:14px;margin-bottom:8px;">YES Probability</div>
                
                <div style="background:rgba(16,185,129,0.1);border:1px solid #10b981;border-radius:6px;padding:8px;margin-bottom:6px;">
                  <div style="color:#10b981;font-size:16px;font-weight:600;">$${yesCostUSD.toFixed(2)}</div>
                  <div style="color:#9ca3af;font-size:11px;">${yesCostBNB.toFixed(4)} BNB</div>
                  <div style="color:#10b981;font-size:10px;">to buy 1 share</div>
                </div>
                
                <div style="color:#10b981;font-size:12px;margin-bottom:2px;">
                  Profit if YES: <strong>$${yesProfitUSD.toFixed(2)}</strong>
                </div>
                <div style="color:#9ca3af;font-size:10px;">
                  ${qYes.toFixed(1)} shares outstanding
                </div>
              </div>
              
              <div style="width:2px;height:100px;background:linear-gradient(to bottom, #10b981, #ef4444);margin:0 15px;"></div>
              
              <div style="text-align:center;flex:1;padding:0 10px;">
                <div style="color:#ef4444;font-size:28px;font-weight:700;margin-bottom:4px;">${noPercentage}%</div>
                <div style="color:#9ca3af;font-size:14px;margin-bottom:8px;">NO Probability</div>
                
                <div style="background:rgba(239,68,68,0.1);border:1px solid #ef4444;border-radius:6px;padding:8px;margin-bottom:6px;">
                  <div style="color:#ef4444;font-size:16px;font-weight:600;">$${noCostUSD.toFixed(2)}</div>
                  <div style="color:#9ca3af;font-size:11px;">${noCostBNB.toFixed(4)} BNB</div>
                  <div style="color:#ef4444;font-size:10px;">to buy 1 share</div>
                </div>
                
                <div style="color:#ef4444;font-size:12px;margin-bottom:2px;">
                  Profit if NO: <strong>$${noProfitUSD.toFixed(2)}</strong>
                </div>
                <div style="color:#9ca3af;font-size:10px;">
                  ${qNo.toFixed(1)} shares outstanding
                </div>
              </div>
            </div>
            
            <div style="text-align:center;color:#6b7280;font-size:11px;margin-top:8px;border-top:1px solid #374151;padding-top:6px;">
              Total Market Volume: $${totalVolumeUSD.toFixed(0)} (${totalVolumeBNB.toFixed(2)} BNB)
            </div>
          </div>
        `;
      }
      
      // Distribution Chart with recent activity
      const distContainer = document.getElementById('distributionChartContainer');
      if (distContainer) {
        distContainer.innerHTML = `
          <div style="display:flex;flex-direction:column;height:100%;background:rgba(31,41,55,0.5);border-radius:8px;padding:20px;">
            <div style="color:#e5e7eb;font-weight:600;text-align:center;margin-bottom:12px;">📊 Live Market Activity</div>
            
            <!-- Market Distribution -->
            <div style="margin-bottom:16px;">
              <div style="display:flex;justify-content:space-between;margin-bottom:8px;">
                <span style="color:#10b981;font-size:14px;font-weight:600;">YES: ${yesPercentage}%</span>
                <span style="color:#ef4444;font-size:14px;font-weight:600;">NO: ${noPercentage}%</span>
              </div>
              <div style="height:12px;background:#374151;border-radius:6px;overflow:hidden;position:relative;">
                <div style="height:100%;width:${yesPercentage}%;background:linear-gradient(90deg, #10b981, #059669);position:absolute;left:0;"></div>
                <div style="height:100%;width:${noPercentage}%;background:linear-gradient(90deg, #ef4444, #dc2626);position:absolute;right:0;"></div>
              </div>
            </div>
            
            <!-- Recent Trades -->
            <div style="flex:1;">
              <div style="color:#e5e7eb;font-size:12px;font-weight:600;margin-bottom:8px;">Recent Trades:</div>
              <div style="max-height:120px;overflow-y:auto;">
                ${recentTrades.map(trade => `
                  <div style="display:flex;justify-content:space-between;align-items:center;padding:4px 8px;margin-bottom:4px;background:rgba(${trade.side === 'YES' ? '16,185,129' : '239,68,68'},0.1);border-radius:4px;">
                    <div style="display:flex;align-items:center;gap:6px;">
                      <span style="color:${trade.side === 'YES' ? '#10b981' : '#ef4444'};font-weight:600;font-size:11px;">${trade.side}</span>
                      <span style="color:#e5e7eb;font-size:11px;">$${trade.amount.toFixed(0)}</span>
                    </div>
                    <span style="color:#9ca3af;font-size:10px;">${trade.timeAgo}s ago</span>
                  </div>
                `).join('')}
              </div>
            </div>
            
            <!-- LMSR Formula Info -->
            <div style="background:rgba(55,65,81,0.5);border-radius:4px;padding:8px;margin-top:8px;">
              <div style="color:#e5e7eb;font-size:10px;text-align:center;margin-bottom:2px;">LMSR Cost Formula:</div>
              <div style="color:#9ca3af;font-size:9px;text-align:center;font-family:monospace;">
                Cost = b × ln(Σe^(q'/b)) - b × ln(Σe^(q/b))
              </div>
              <div style="color:#6b7280;font-size:8px;text-align:center;margin-top:2px;">
                Liquidity parameter b = ${b}
              </div>
            </div>
          </div>
        `;
      }
      
      console.log('✅ LMSR simulation with USD pricing initialized');
      console.log(`� Current prices: YES=$${yesCostUSD.toFixed(2)} (${yesPercentage}%), NO=$${noCostUSD.toFixed(2)} (${noPercentage}%)`);
    }
    
    // Run LMSR simulation immediately and refresh every 10 seconds for live feel
    setTimeout(initializeSimpleCharts, 500); 
    setInterval(initializeSimpleCharts, 10000); // Update every 10 seconds for dynamic activity

    // Initialize Web3 and BSC connection
    
    // BSC Configuration
    const TREASURY_WALLET = '0x7eCa382995Df91C250896c0EC73c9d2893F7800e';
    const BSC_MAINNET_CONFIG = {
      chainId: '0x38',
      chainName: 'Binance Smart Chain',
      nativeCurrency: { name: 'BNB', symbol: 'BNB', decimals: 18 },
      rpcUrls: ['https://bsc-dataseed1.binance.org/'],
      blockExplorerUrls: ['https://bscscan.com/'],
    };
  </script>
  
  <div id="loadingScreen" style="position:fixed;inset:0;background:linear-gradient(135deg, #111827 0%, #374151 50%, #111827 100%);display:flex;align-items:center;justify-content:center;z-index:9999;">
    <div style="text-align:center;color:#9ca3af;">
      <div style="width:50px;height:50px;border:4px solid rgba(156,163,175,0.3);border-top-color:#9ca3af;border-radius:50%;animation:spin 1s linear infinite;margin:0 auto 16px;"></div>
      <div style="font-size:18px;font-weight:700;">Loading BNB Market...</div>
    </div>
  </div>
  <style>@keyframes spin{0%{transform:rotate(0deg);}100%{transform:rotate(360deg);}}</style>
  <script>
    window.addEventListener('DOMContentLoaded', () => {
      setTimeout(() => {
        document.getElementById('loadingScreen').style.display = 'none';
      }, 1000);
    });
  </script>
  
  <script>
    // Helper function to get LIVE market probabilities from prediction market engine
    // This is a TRUE prediction market - no admin manipulation!
    async function getLMSRProbabilities(marketId) {
      try {
        const response = await fetch(`${API_BASE_URL}/markets/${marketId}/probabilities`);
        if (response.ok) {
          return await response.json();
        }
      } catch (error) {
        console.warn('Failed to fetch LMSR probabilities:', error);
      }
      return null;
    }

    // Helper function to calculate implied odds from probability
    function probabilityToOdds(probability) {
      if (!probability || probability <= 0) return null;
      return 1 / probability;
    }

    // Helper function to get LMSR price per share for an option
    async function getLMSRPrice(market, optionIndex) {
      const probData = await getLMSRProbabilities(market.id);
      if (!probData || !probData.prices || !probData.prices[optionIndex]) {
        console.warn(`LMSR prices not available for option ${optionIndex}`);
        return 0.5; // Default fallback price
      }
      
      return probData.prices[optionIndex];
    }

    // Globals
    let walletAddress = null;
    let web3 = null; // Move web3 declaration here
    window.bnbBalance = 0;
    let currentOrderBook = null;
    let currentMarket = null;
    let selectedOutcome = 0;
    window.currentOrderBook = currentOrderBook;
    window.currentMarket = currentMarket;
    window.selectedOutcome = selectedOutcome;

    // Web3 initialization
    async function initializeWeb3() {
      try {
        if (!window.ethereum) {
          console.log('MetaMask not detected');
          return false;
        }
        
        web3 = new Web3(window.ethereum);
        
        // Check if wallet was previously connected
        const accounts = await window.ethereum.request({ method: 'eth_accounts' });
        if (accounts.length > 0) {
          walletAddress = accounts[0];
          // Check if this wallet is admin
          const adminWallet = '0x7eCa382995Df91C250896c0EC73c9d2893F7800e';
          isAdmin = walletAddress.toLowerCase() === adminWallet.toLowerCase();
          await updateBalance();
        }
        
        console.log('Successfully initialized Web3 connection');
        return true;
      } catch (error) {
        console.error('Failed to initialize Web3:', error);
        return false;
      }
    }

    // Wallet functions
    async function updateBalance() {
      if (!walletAddress || !web3) {
        document.getElementById('balanceDisplay').style.display = 'none';
        return;
      }
      try {
        const balance = await web3.eth.getBalance(walletAddress);
        window.bnbBalance = parseFloat(web3.utils.fromWei(balance, 'ether'));
        document.getElementById('bnbBalance').textContent = window.bnbBalance.toFixed(3);
        document.getElementById('balanceDisplay').style.display = '';
      } catch (e) {
        console.error('Balance update failed:', e);
        document.getElementById('balanceDisplay').style.display = 'none';
      }
    }

    function setWalletBtnConnected(addr) {
      const btn = document.getElementById('walletBtn');
      btn.textContent = addr.slice(0, 4) + '...' + addr.slice(-4);
      btn.classList.add('connected');
    }
    
    function setWalletBtnDisconnected() {
      const btn = document.getElementById('walletBtn');
      btn.textContent = window.i18n.t('connectWallet');
      btn.classList.remove('connected');
    }

    async function connectWallet() {
      if (!window.ethereum) {
        alert(window.i18n.t('metamaskNotFound'));
        window.open('https://metamask.io/', '_blank');
        return;
      }
      try {
        // Request account access
        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
        
        if (accounts.length === 0) {
          alert('No accounts found');
          return;
        }

        walletAddress = accounts[0];
        
        // Switch to BSC network if needed
        try {
          await window.ethereum.request({
            method: 'wallet_switchEthereumChain',
            params: [{ chainId: '0x38' }], // BSC Mainnet
          });
        } catch (switchError) {
          if (switchError.code === 4902) {
            try {
              await window.ethereum.request({
                method: 'wallet_addEthereumChain',
                params: [BSC_MAINNET_CONFIG],
              });
            } catch (addError) {
              console.error('Failed to add BSC network:', addError);
            }
          }
        }
        
        setWalletBtnConnected(walletAddress);
        await updateBalance();
        updateAdminTabVisibility();
      } catch (e) {
        console.error('Wallet connection failed:', e);
        setWalletBtnDisconnected();
      }
    }

    function disconnectWallet() {
      walletAddress = null;
      setWalletBtnDisconnected();
      document.getElementById('balanceDisplay').style.display = 'none';
    }

    function updateAdminTabVisibility() {
      const adminTab = document.getElementById('adminTab');
      const ADMIN_WALLET = '0x7eCa382995Df91C250896c0EC73c9d2893F7800e';
      if (walletAddress && walletAddress.toLowerCase() === ADMIN_WALLET.toLowerCase()) {
        if (adminTab) adminTab.style.display = '';
      } else {
        if (adminTab) adminTab.style.display = 'none';
      }
    }

    // Utility
    function getMarketId() {
      // First try URL parameters (?id=123)
      const params = new URLSearchParams(window.location.search);
      const paramId = params.get('id');
      if (paramId) {
        return parseInt(paramId);
      }
      
      // Then try SEO-friendly URL path (/market/title-123 or /title-123)
      const path = window.location.pathname;
      let slug = '';
      
      if (path.startsWith('/market/')) {
        slug = path.replace('/market/', '');
      } else if (path !== '/' && path !== '/market.html') {
        slug = path.replace('/', '');
      }
      
      if (slug) {
        // Extract ID from slug (last number after hyphen)
        const matches = slug.match(/-(\d+)$/);
        if (matches) {
          return parseInt(matches[1]);
        }
      }
      
      return null;
    }

    // UI Rendering
    async function renderMarketInfo(market) {
      document.getElementById('marketTitle').textContent = market.title;
      document.getElementById('marketMeta').textContent = `Category: ${market.category} | Created: ${new Date(market.created_at).toLocaleString()}`;
      
      let totalVolume = 0;
      try {
        const res = await fetch(`${API_BASE_URL}/bets?marketId=${market.id}`);
        if (res.ok) {
          const data = await res.json();
          if (Array.isArray(data.bets)) {
            totalVolume = data.bets.reduce((sum, b) => sum + (parseFloat(b.amount) || 0), 0);
          }
        }
      } catch (e) {
        if (window.currentOrderBook && Array.isArray(window.currentOrderBook)) {
          totalVolume = window.currentOrderBook.reduce((sum, b) => sum + (parseFloat(b.amount) || 0), 0);
        }
      }
      
      document.getElementById('marketVolume').innerHTML = `Total Volume: <span style='color:#06b6d4;'>${totalVolume.toFixed(3)} BNB</span>`;
      
      const optionsDiv = document.getElementById('marketOptions');
      optionsDiv.innerHTML = '';
      
      // Get LMSR probabilities for the market
      const probData = await getLMSRProbabilities(market.id);
      
      (market.options || []).forEach(async (opt, i) => {
        const el = document.createElement('div');
        
        // Apply Yin Yang styling based on option type
        const isYangOption = opt.name && (opt.name.toLowerCase().includes('yes') || opt.name.toLowerCase().includes('true') || opt.name.toLowerCase().includes('支持') || i === 0);
        const isYinOption = opt.name && (opt.name.toLowerCase().includes('no') || opt.name.toLowerCase().includes('false') || opt.name.toLowerCase().includes('反對') || i === 1);
        
        let yinYangClass = '';
        if (isYangOption) {
          yinYangClass = ' yang';
        } else if (isYinOption) {
          yinYangClass = ' yin';
        } else {
          // Alternate for other options
          yinYangClass = i % 2 === 0 ? ' yang' : ' yin';
        }
        
        el.className = 'option-tab' + (i===selectedOutcome?' active':'') + yinYangClass;
        
        // Enhanced styling with better contrast and visual hierarchy
        const baseStyle = 'padding:12px 14px 8px 14px;border-radius:12px;min-width:90px;text-align:center;cursor:pointer;transition:all 0.3s ease;display:flex;flex-direction:column;align-items:center;justify-content:center;position:relative;overflow:hidden;';
        
        // Add subtle Yin Yang symbols as background elements
        const symbolStyle = isYangOption ? 
          'background-image: radial-gradient(circle at 20% 80%, rgba(6,182,212,0.08) 20%, transparent 20%);' :
          'background-image: radial-gradient(circle at 80% 20%, rgba(156,163,175,0.12) 20%, transparent 20%);';
        
        el.style = baseStyle + symbolStyle;
        
        let oddsDisplay = '';
        let probabilityDisplay = '';
        
        if (probData && probData.probabilities && probData.probabilities[i] !== undefined) {
          const probability = probData.probabilities[i];
          const textColor = isYangOption ? '#475569' : '#9ca3af';
          probabilityDisplay = `<div style='color:${textColor};font-size:0.9em;font-weight:600;margin-top:3px;'>${probability}% confidence</div>`;
          // Show price per share instead of odds
          if (probData.prices && probData.prices[i]) {
            const pricePerShare = probData.prices[i];
            oddsDisplay = `<div style='color:${textColor};font-size:0.85em;font-weight:500;'>${pricePerShare.toFixed(3)} BNB/share</div>`;
          }
        } else {
          const textColor = isYangOption ? '#64748b' : '#9ca3af';
          probabilityDisplay = `<div style='color:${textColor};font-size:0.85em;font-weight:600;margin-top:3px;'>Loading...</div>`;
        }
        
        // Add philosophical symbols for YES/NO
        const symbol = isYangOption ? '☀️' : (isYinOption ? '🌙' : '');
        const symbolDisplay = symbol ? `<span style='font-size:1.2em;margin-bottom:4px;'>${symbol}</span>` : '';
        
        const nameColor = isYangOption ? '#0f172a' : '#e2e8f0';
        
        el.innerHTML = `
          ${opt.image ? `<img src='${opt.image}' alt='' style='width:40px;height:40px;border-radius:50%;margin-bottom:6px;border:2px solid ${isYangOption ? '#cbd5e1' : '#475569'};'>` : ''}
          ${symbolDisplay}
          <div style="font-size:1.08rem;font-weight:700;color:${nameColor};margin-bottom:2px;">${opt.name || 'Option ' + (i+1)}</div>
          ${probabilityDisplay}
          ${oddsDisplay}
        `;
        
        el.onclick = ()=>{
          selectedOutcome = i;
          renderMarketInfo(market);
          renderChart(market, currentOrderBook);
          renderOrderBookPro(currentOrderBook, market, selectedOutcome);
          updateTradePanel();
          calculateProfit();
        };
        optionsDiv.appendChild(el);
      });
      
      if (currentOrderBook && market.options) {
        let html = '<span style="color:#d1d5db;">Total Buys:</span> ';
        const totals = Array(market.options.length).fill(0);
        currentOrderBook.forEach(b=>{ if(b.option_id!==undefined) totals[b.option_id]+=1; });
        html += market.options.map((opt,i)=>`${opt.name}: <span style='color:#d1d5db;'>${totals[i]}</span>`).join(' &nbsp; ');
        document.getElementById('totalBuys').innerHTML = html;
      }
      
      // Render the enhanced order book (ONLY ONE - prevent duplication)
      if (window.enhancedOrderBook) {
        window.enhancedOrderBook.renderOrderBook(market);
      }
      
      // COMMENTED OUT to prevent duplicate rendering:
      // if (window.yinYangOrderBook) {
      //   window.yinYangOrderBook.renderOrderBook(market);
      // }
    }

    function renderOrderBookPro(orderBook, market, selectedOutcome) {
      const obDiv = document.getElementById('orderBook');
      
      if (!orderBook || orderBook.length === 0) {
        obDiv.innerHTML = '<div style="color:#d1d5db;">No bets yet.</div>';
        return;
      }
      
      const filtered = orderBook.filter(b => b.option_id === selectedOutcome);
      const bids = filtered;
      bids.sort((a,b) => parseFloat(b.amount) - parseFloat(a.amount));
      const maxShares = Math.max(...bids.map(x => parseFloat(x.amount)), 1);
      
      // Calculate summary stats for this option
      const totalVolume = bids.reduce((sum, bet) => sum + parseFloat(bet.amount), 0);
      const uniqueBuyers = new Set(bids.map(bet => bet.bettor_address || bet.address || bet.transaction_signature).filter(Boolean)).size;
      const averageBet = bids.length > 0 ? totalVolume / bids.length : 0;
      
      let tabs = '';
      (market.options||[]).forEach((opt,i)=>{
        // Apply Yin Yang styling to order book tabs
        const isYangOption = opt.name && (opt.name.toLowerCase().includes('yes') || opt.name.toLowerCase().includes('true') || opt.name.toLowerCase().includes('支持') || i === 0);
        const isYinOption = opt.name && (opt.name.toLowerCase().includes('no') || opt.name.toLowerCase().includes('false') || opt.name.toLowerCase().includes('反對') || i === 1);
        
        let activeColors, inactiveColors;
        if (isYangOption) {
          activeColors = 'background:linear-gradient(135deg, #f8fafc, #e2e8f0);color:#0f172a;border:2px solid #06b6d4;box-shadow:0 0 0 2px rgba(6,182,212,0.1);';
          inactiveColors = 'background:linear-gradient(135deg, #e2e8f0, #cbd5e1);color:#334155;border:2px solid #94a3b8;';
        } else if (isYinOption) {
          activeColors = 'background:linear-gradient(135deg, #0f172a, #1e293b);color:#f8fafc;border:2px solid #9ca3af;box-shadow:0 0 0 2px rgba(156,163,175,0.1);';
          inactiveColors = 'background:linear-gradient(135deg, #1e293b, #334155);color:#e2e8f0;border:2px solid #475569;';
        } else {
          // Alternate for other options
          if (i % 2 === 0) {
            activeColors = 'background:linear-gradient(135deg, #f8fafc, #e2e8f0);color:#0f172a;border:2px solid #06b6d4;box-shadow:0 0 0 2px rgba(6,182,212,0.1);';
            inactiveColors = 'background:linear-gradient(135deg, #e2e8f0, #cbd5e1);color:#334155;border:2px solid #94a3b8;';
          } else {
            activeColors = 'background:linear-gradient(135deg, #0f172a, #1e293b);color:#f8fafc;border:2px solid #9ca3af;box-shadow:0 0 0 2px rgba(156,163,175,0.1);';
            inactiveColors = 'background:linear-gradient(135deg, #1e293b, #334155);color:#e2e8f0;border:2px solid #475569;';
          }
        }
        
        const colors = i===selectedOutcome ? activeColors : inactiveColors;
        tabs += `<button class="ob-tab${i===selectedOutcome?' active':''}" data-idx="${i}" style="${colors}padding:8px 16px;border-radius:8px;font-weight:600;cursor:pointer;transition:all 0.3s ease;margin-right:6px;">${opt.name}</button>`;
      });
      
      async function rowHtml(order) {
        // Debug: Log the order structure to see available fields
        console.log('Order data structure:', {
          id: order.id,
          amount: order.amount,
          transaction_signature: order.transaction_signature,
          bettor_address: order.bettor_address,
          address: order.address,
          created_at: order.created_at,
          all_fields: Object.keys(order)
        });
        
        const barW = Math.max(8, 180*(parseFloat(order.amount)/maxShares));
        
        // Get current LMSR probabilities for potential return calculation
        const probData = await getLMSRProbabilities(market.id);
        let sharesOwned = 0;
        let potentialReturn = 0;
        
        if (probData && probData.prices && probData.prices[selectedOutcome]) {
          // Calculate shares owned: amount / price per share at time of purchase
          const executionPrice = order.execution_odds || probData.prices[selectedOutcome];
          sharesOwned = parseFloat(order.amount) / executionPrice;
          
          // Potential return is shares * probability of winning (max 1 BNB per share if wins)
          const winProbability = probData.probabilities[selectedOutcome] / 100;
          potentialReturn = sharesOwned * winProbability;
        } else {
          // Fallback calculation
          potentialReturn = parseFloat(order.amount) * 1.5;
        }
        
        let buyerCell = '-';
        
        // Priority 1: Show wallet address if available
        if (order.bettor_address) {
          const shortAddr = order.bettor_address.slice(0,6) + '...' + order.bettor_address.slice(-4);
          buyerCell = `<div style="display:flex;flex-direction:column;gap:2px;">
            <a href="https://bscscan.com/address/${order.bettor_address}" target="_blank" rel="noopener" style="color:#10b981;font-weight:700;text-decoration:none;font-size:14px;">
              ${shortAddr}
            </a>
            <span style="color:#64748b;font-size:11px;">Buyer Address</span>
          </div>`;
        }
        // Priority 2: Show transaction signature as fallback
        else if (order.transaction_signature) {
          const shortTx = order.transaction_signature.slice(0,6) + '...' + order.transaction_signature.slice(-4);
          buyerCell = `<div style="display:flex;flex-direction:column;gap:2px;">
            <a href="https://bscscan.com/tx/${order.transaction_signature}" target="_blank" rel="noopener" style="color:#06b6d4;font-weight:700;text-decoration:none;font-size:14px;">
              ${shortTx}
            </a>
            <span style="color:#64748b;font-size:11px;">Transaction</span>
          </div>`;
        }
        // Priority 3: Show any other address field
        else if (order.address) {
          const shortAddr = order.address.slice(0,6) + '...' + order.address.slice(-4);
          buyerCell = `<div style="display:flex;flex-direction:column;gap:2px;">
            <a href="https://bscscan.com/address/${order.address}" target="_blank" rel="noopener" style="color:#8b5cf6;font-weight:700;text-decoration:none;font-size:14px;">
              ${shortAddr}
            </a>
            <span style="color:#64748b;font-size:11px;">Address</span>
          </div>`;
        }
        // Priority 4: Show timestamp as identifier if no address
        else {
          const date = new Date(order.created_at);
          const timeStr = date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
          buyerCell = `<div style="display:flex;flex-direction:column;gap:2px;">
            <span style="color:#f59e0b;font-weight:600;font-size:14px;">${timeStr}</span>
            <span style="color:#64748b;font-size:11px;">Anonymous</span>
          </div>`;
        }
        return `<tr style="background:rgba(16,185,129,0.08);border-bottom:1px solid rgba(55,65,81,0.3);">
          <td style="position:relative;padding:12px 8px;">
            <div style="position:absolute;left:0;top:0;height:100%;width:${barW}px;background:rgba(16,185,129,0.13);border-radius:4px;"></div>
            <span style="position:relative;z-index:2;font-weight:700;color:#10b981;font-size:16px;">${parseFloat(order.amount).toFixed(3)} BNB</span>
          </td>
          <td style="position:relative;z-index:2;padding:12px 8px;">${buyerCell}</td>
          <td style="position:relative;z-index:2;color:#e2e8f0;padding:12px 8px;">
            <div style="display:flex;flex-direction:column;gap:2px;">
              <span style="font-weight:600;color:#06b6d4;">${sharesOwned.toFixed(2)} shares</span>
              <span style="color:#94a3b8;font-size:13px;">Return: ${potentialReturn.toFixed(3)} BNB</span>
            </div>
          </td>
          <td style="position:relative;z-index:2;color:#94a3b8;padding:12px 8px;font-size:13px;">
            ${new Date(order.created_at).toLocaleString('en-US', { 
              month: 'short', 
              day: 'numeric', 
              hour: '2-digit', 
              minute: '2-digit' 
            })}
          </td>
        </tr>`;
      }
      
      let html = `<div style="display:flex;align-items:center;gap:18px;margin-bottom:12px;flex-wrap:wrap;">
        <h3 style="color:#9ca3af;margin:0;font-size:1.3rem;">Order Book</h3>
        <div>${tabs}</div>
      </div>`;
      
      // Market Summary Section
      html += `
        <div style="
          margin-bottom: 20px; 
          padding: 16px; 
          background: linear-gradient(135deg, rgba(59,130,246,0.1), rgba(37,99,235,0.05)); 
          border-radius: 12px; 
          border: 1px solid rgba(59,130,246,0.2);
          backdrop-filter: blur(10px);
        ">
          <h4 style="margin: 0 0 12px 0; color: #e2e8f0; font-size: 16px; font-weight: 600;">Market Summary</h4>
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 12px;">
            <div style="text-align: center; padding: 8px;">
              <div style="color: #94a3b8; font-size: 11px; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px;">Total Volume</div>
              <div style="color: #10b981; font-size: 18px; font-weight: 700;">${totalVolume.toFixed(2)} BNB</div>
            </div>
            <div style="text-align: center; padding: 8px;">
              <div style="color: #94a3b8; font-size: 11px; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px;">Unique Buyers</div>
              <div style="color: #3b82f6; font-size: 18px; font-weight: 700;">${uniqueBuyers}</div>
            </div>
            <div style="text-align: center; padding: 8px;">
              <div style="color: #94a3b8; font-size: 11px; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px;">Average Bet</div>
              <div style="color: #f59e0b; font-size: 18px; font-weight: 700;">${averageBet.toFixed(3)} BNB</div>
            </div>
            <div style="text-align: center; padding: 8px;">
              <div style="color: #94a3b8; font-size: 11px; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px;">Total Bets</div>
              <div style="color: #ef4444; font-size: 18px; font-weight: 700;">${bids.length}</div>
            </div>
          </div>
        </div>`;
        
      html += `<table style="width:100%;border-radius:12px;overflow:hidden;font-size:1rem;border:1px solid #374151;">
        <thead><tr style="background:linear-gradient(135deg, #374151, #475569);color:#e2e8f0;font-weight:700;">
          <th style="padding:12px 8px;text-align:left;border-right:1px solid #4b5563;">Amount (BNB)</th>
          <th style="padding:12px 8px;text-align:left;border-right:1px solid #4b5563;">Buyer</th>
          <th style="padding:12px 8px;text-align:left;border-right:1px solid #4b5563;">Position & Return</th>
          <th style="padding:12px 8px;text-align:left;">Time</th>
        </tr></thead>
        <tbody id="orderBookRows">`;
      
      html += '</tbody></table>';
      obDiv.innerHTML = html;
      
      // Render rows asynchronously
      const rowsContainer = document.getElementById('orderBookRows');
      Promise.all(bids.map(order => rowHtml(order))).then(rows => {
        rowsContainer.innerHTML = rows.join('');
      });
      
      obDiv.querySelectorAll('.ob-tab').forEach(btn=>{
        btn.onclick = ()=>{
          selectedOutcome = parseInt(btn.dataset.idx);
          renderOrderBookPro(orderBook,market,selectedOutcome);
        };
      });
    }

    async function updateTradePanel() {
      if (!currentMarket || !currentMarket.options) return;
      const opt = currentMarket.options[selectedOutcome];
      
      // Determine if this is a Yang (YES/positive) or Yin (NO/negative) option
      const isYangOption = opt.name && (opt.name.toLowerCase().includes('yes') || opt.name.toLowerCase().includes('true') || opt.name.toLowerCase().includes('支持') || selectedOutcome === 0);
      const isYinOption = opt.name && (opt.name.toLowerCase().includes('no') || opt.name.toLowerCase().includes('false') || opt.name.toLowerCase().includes('反對') || selectedOutcome === 1);
      
      // Get LMSR probabilities
      const probData = await getLMSRProbabilities(currentMarket.id);
      let probabilityText = 'Loading market sentiment...';
      let pricePerShare = 0.5; // Default fallback price
      
      if (probData && probData.prices && probData.prices[selectedOutcome]) {
        const probability = probData.probabilities[selectedOutcome];
        pricePerShare = probData.prices[selectedOutcome];
        probabilityText = `${probability}% market confidence (based on community investments)`;
      }
      
      // Show price per share with dynamic Yin Yang coloring
      let priceDisplay = '';
      if (probData && probData.prices && probData.prices[selectedOutcome]) {
        const priceColor = isYangOption ? '#06b6d4' : '#9ca3af';
        priceDisplay = `<span style='color:${priceColor};font-size:1.08em;font-weight:700;margin-left:8px;'>${pricePerShare.toFixed(3)} BNB/share</span>`;
      } else {
        priceDisplay = `<span style='color:#9ca3af;font-size:0.95em;font-weight:700;margin-left:8px;'>Loading price...</span>`;
      }
      
      // Apply dynamic symbol and coloring for option name
      const symbol = isYangOption ? '☀️' : (isYinOption ? '🌙' : '');
      const nameColor = isYangOption ? '#06b6d4' : '#9ca3af';
      const symbolDisplay = symbol ? `<span style='font-size:1.2em;margin-right:6px;'>${symbol}</span>` : '';
      
      document.getElementById('tradeOptionName').innerHTML = `${symbolDisplay}<span style='color:${nameColor};'>${opt.name}</span> ${opt.image?`<img src='${opt.image}' style='width:28px;height:28px;border-radius:50%;vertical-align:middle;margin-left:6px;border:2px solid ${nameColor};'>`:''} ${priceDisplay}`;
      document.getElementById('tradeOdds').textContent = probabilityText;
      document.getElementById('tradeAmount').value = '';
      document.getElementById('tradeMsg').textContent = '';
      
      // Update buy button text based on Yin/Yang choice
      const buyBtn = document.getElementById('buyBtn');
      if (buyBtn) {
        const actionText = isYangOption ? 'Buy' : (isYinOption ? 'Sell' : 'Trade');
        buyBtn.innerHTML = `${actionText} <span data-i18n="shares">Shares</span>`;
      }
      
      calculateProfit();
    }

    async function handleBuy() {
      const amt = parseFloat(document.getElementById('tradeAmount').value);
      const minBet = 0.007585445110418999; // $10 USD in BNB
      
      if (!amt || amt <= 0) {
        document.getElementById('tradeMsg').textContent = window.i18n.t('enterValidAmount');
        return;
      }
      
      if (amt < minBet) {
        document.getElementById('tradeMsg').textContent = `Minimum bet is ${minBet} BNB ($10 USD)`;
        return;
      }
      
      if (!walletAddress || !web3) {
        document.getElementById('tradeMsg').textContent = window.i18n.t('connectWalletFirst');
        return;
      }
      
      if (!window.ethereum) {
        document.getElementById('tradeMsg').textContent = window.i18n.t('metamaskNotConnected');
        return;
      }
      
      try {
        document.getElementById('tradeMsg').textContent = 'Processing trade...';
        document.getElementById('buyBtn').disabled = true;
        
        // Use enhanced trading engine for better calculations
        console.log('🚀 MAIN TRADING PANEL - Submitting real bet to server...');
        
        // FIRST: Submit a real bet to the server to update probabilities
        const realBetData = {
          marketId: currentMarket.id,
          bettorAddress: walletAddress,
          optionId: selectedOutcome,
          amount: amt,
          transactionSignature: 'main_trade_' + Date.now() + '_' + Math.random().toString(36)
        };
        
        console.log('📤 SUBMITTING REAL BET TO SERVER:', realBetData);
        
        // Submit bet to server to update the database
        const betResponse = await fetch(`${API_BASE_URL}/bets`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(realBetData)
        });
        
        let serverBetResult;
        if (betResponse.ok) {
          serverBetResult = await betResponse.json();
          console.log('✅ Server bet submitted successfully:', serverBetResult);
        } else {
          console.warn('⚠️ Server bet submission failed:', await betResponse.text());
          serverBetResult = { success: false };
        }
        
        // Also run local enhanced trading for UI feedback
        const tradeResult = await window.enhancedTrading.executeTrade(
          currentMarket.id, 
          selectedOutcome, 
          amt, 
          walletAddress
        );
        
        if (tradeResult.success || serverBetResult.bet) {
          // Show success message with trade details
          const details = tradeResult.tradeDetails;
          document.getElementById('tradeMsg').innerHTML = `
            <div style="color:#10b981;font-weight:600;font-size:15px;">✅ ${tradeResult.message}</div>
            <div style="color:#d1d5db;font-size:13px;margin-top:5px;font-weight:500;">
              Shares: <span style="color:#06b6d4;font-weight:600;">${details.sharesReceived.toFixed(3)}</span> | 
              Price: <span style="color:#f59e0b;font-weight:600;">${details.pricePerShare.toFixed(3)} BNB/share</span> | 
              Fee: <span style="color:#9ca3af;">${details.platformFee.toFixed(3)} BNB</span>
            </div>
          `;
          
          // Update charts and market display
          setTimeout(async () => {
            renderMarketInfo(currentMarket);
            renderChart(currentMarket, currentOrderBook);
            renderOrderBookPro(currentOrderBook, currentMarket, selectedOutcome);
            updateTradePanel();
            calculateProfit();
            
            // CRITICAL: Fetch fresh data from server after bet submission (same as order book)
            console.log('🔄 MAIN TRADING PANEL - FETCHING FRESH DATA FROM SERVER...');
            
            try {
              // Get updated probabilities from server
              const freshData = await getLMSRProbabilities(currentMarket.id);
              console.log('📊 FRESH SERVER DATA FROM MAIN TRADE:', freshData);
              
              if (freshData && freshData.probabilities) {
                const updatedDepth = {
                  probabilities: freshData.probabilities,
                  prices: freshData.prices,
                  shares: freshData.volumes || [1000, 1000],
                  totalVolume: freshData.total_volume || 1000
                };
                
                console.log(`🔄 MAIN TRADE - FORCING CHART REFRESH WITH SERVER DATA:`, updatedDepth);
                
                // Flash the chart containers to show something is happening
                const probContainer = document.getElementById('probabilityChartContainer');
                const distContainer = document.getElementById('distributionChartContainer');
                if (probContainer) {
                  probContainer.style.border = "3px solid #0066ff";
                  setTimeout(() => probContainer.style.border = "none", 2000);
                }
                if (distContainer) {
                  distContainer.style.border = "3px solid #0066ff";
                  setTimeout(() => distContainer.style.border = "none", 2000);
                }
                
                // Use enhanced order book's force chart refresh mechanism
                if (window.enhancedOrderBook && window.enhancedOrderBook.forceChartsRefresh) {
                  window.enhancedOrderBook.forceChartsRefresh(updatedDepth);
                } else {
                  console.warn('⚠️ Enhanced order book not available for chart refresh');
                }
              } else {
                console.warn('⚠️ No fresh data received from server for main trade');
              }
            } catch (error) {
              console.error('❌ Failed to fetch fresh server data for main trade:', error);
            }
          }, 1000); // Wait 1 second for server to process the bet
          
          // Add to order book simulation
          if (!currentOrderBook) currentOrderBook = [];
          currentOrderBook.push({
            id: Date.now(),
            market_id: currentMarket.id,
            option_id: selectedOutcome,
            amount: details.netAmount.toString(),
            shares_purchased: details.sharesReceived.toString(),
            execution_odds: details.pricePerShare.toString(),
            wallet_address: walletAddress,
            created_at: new Date().toISOString(),
            status: 'completed'
          });
          
          // Clear form
          document.getElementById('tradeAmount').value = '';
          
        } else {
          document.getElementById('tradeMsg').textContent = tradeResult.message || 'Trade failed';
        }
        
      } catch (error) {
        console.error('Trade execution error:', error);
        document.getElementById('tradeMsg').textContent = `Error: ${error.message}`;
      } finally {
        document.getElementById('buyBtn').disabled = false;
      }
    }

    async function handleCancelPurchase() {
      if (!walletAddress) {
        document.getElementById('tradeMsg').textContent = 'Connect your wallet first.';
        return;
      }
      document.getElementById('tradeMsg').textContent = 'Requesting cancellation...';
      try {
        await fetch(`${API_BASE_URL}/cancel`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            marketId: currentMarket.id,
            optionId: selectedOutcome,
            bettorAddress: walletAddress.toString()
          })
        });
        document.getElementById('tradeMsg').textContent = 'Prediction cancellation requested. Refunds are processed within 24 hours.';
      } catch (e) {
        document.getElementById('tradeMsg').textContent = 'Cancellation failed: ' + (e.message || e);
      }
    }

    // Chart switching functionality
    function switchChart(chartType) {
      // Update tab states
      document.querySelectorAll('.chart-tab').forEach(tab => tab.classList.remove('active'));
      document.getElementById(chartType + 'Tab').classList.add('active');
      
      // Show/hide chart containers
      document.getElementById('probabilityChartContainer').style.display = chartType === 'probability' ? 'block' : 'none';
      document.getElementById('distributionChartContainer').style.display = chartType === 'distribution' ? 'block' : 'none';
      
      // Load chart if not already loaded and chart engine is available
      if (currentMarket && window.lmsrChartEngine) {
        try {
          // Add a small delay to ensure container is visible
          setTimeout(() => {
            if (chartType === 'probability') {
              window.lmsrChartEngine.createProbabilityChart('probabilityChartContainer', currentMarket.id);
            } else if (chartType === 'distribution') {
              window.lmsrChartEngine.createCurrentDistributionChart('distributionChartContainer', currentMarket.id);
            }
          }, 100);
        } catch (error) {
          console.error('Chart creation failed:', error);
          const container = document.getElementById(chartType + 'ChartContainer');
          if (container) {
            container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#ff6b6b;font-size:14px;">⚠️ Chart failed to load</div>';
          }
        }
      }
    }

    // Updated chart rendering function
    function renderChart(market, orderBook) {
      // Only initialize probability chart once, with a delay to ensure DOM is ready
      if (window.lmsrChartEngine && !window.lmsrChartEngine.chartInstances['probabilityChart']) {
        setTimeout(() => {
          try {
            window.lmsrChartEngine.createProbabilityChart('probabilityChartContainer', market.id);
          } catch (error) {
            console.error('Chart initialization failed:', error);
            const container = document.getElementById('probabilityChartContainer');
            if (container) {
              container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#ff6b6b;font-size:14px;">⚠️ Chart failed to load</div>';
            }
          }
        }, 200);
      } else if (!window.lmsrChartEngine) {
        console.warn('Chart engine not available');
        const container = document.getElementById('probabilityChartContainer');
        if (container) {
          container.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#9ca3af;font-size:14px;">📊 Charts temporarily unavailable</div>';
        }
      }
    }

    // Create a demo market for testing
    function createDemoMarket() {
      const demoMarket = {
        id: 'demo-market-1',
        title: '2024 BNB Price Prediction - Will BNB reach $1000?',
        description: 'Predict whether BNB will reach $1000 by end of 2024',
        created_at: new Date().toISOString(),
        resolved: false,
        options: [
          {
            name: 'YES - BNB hits $1000 ☀️',
            image: null,
            isYang: true
          },
          {
            name: 'NO - BNB stays under $1000 🌙',
            image: null,
            isYang: false
          }
        ],
        metadata: {
          initialLiquidity: 10000, // Starting liquidity pool
          totalVolume: 0 // Will grow with trading
        }
      };
      
      // Initialize enhanced order book with this market (MAIN ORDER BOOK)
      setTimeout(() => {
        if (window.enhancedOrderBook) {
          window.enhancedOrderBook.renderOrderBook(demoMarket);
          console.log('✅ Enhanced order book initialized');
        }
        
        // CRITICAL: Initialize charts with the prediction market data
        if (window.lmsrChartEngine) {
          console.log('🎯 Initializing charts with demo market...');
          
          // Initialize the prediction market first
          window.predictionMarket.initializeMarket(demoMarket.id, demoMarket.options);
          
          // Set global market reference for charts
          window.currentMarket = demoMarket;
          
          // Create initial charts with live data
          setTimeout(() => {
            console.log('📊 Creating initial charts...');
            window.lmsrChartEngine.createProbabilityChart('probabilityChartContainer', demoMarket.id);
            window.lmsrChartEngine.createCurrentDistributionChart('distributionChartContainer', demoMarket.id);
            console.log('✅ Charts initialized successfully');
            
            // Test the market data connection
            const testDepth = window.predictionMarket.getMarketDepth(demoMarket.id);
            console.log('🧪 Test market depth:', testDepth);
          }, 100);
        } else {
          console.warn('⚠️ lmsrChartEngine not available, initializing fallback charts...');
          
          // Initialize prediction market anyway
          window.predictionMarket.initializeMarket(demoMarket.id, demoMarket.options);
          window.currentMarket = demoMarket;
          
          // Charts will be created by the main chart initialization logic
          console.log('✅ Demo market initialized, charts will be created automatically');
        }
      }, 200);
      
      return demoMarket;
    }

    async function loadMarketPage() {
      const marketId = getMarketId();
      if (!marketId) {
        // Create a demo market for testing the enhanced order book
        currentMarket = createDemoMarket();
        currentOrderBook = [];
        renderMarketInfo(currentMarket);
        renderChart(currentMarket, currentOrderBook);
        updateTradePanel();
        return;
      }
      
      try {
        // Fetch both market and bets data (there's no separate orderbook endpoint)
        const marketResponse = await fetch(`${API_BASE_URL}/markets/${marketId}`);
        if (!marketResponse.ok) throw new Error('Failed to fetch market');
        const marketData = await marketResponse.json();
        
        const betsResponse = await fetch(`${API_BASE_URL}/bets?marketId=${marketId}`);
        if (!betsResponse.ok) throw new Error('Failed to fetch bets');
        const betsData = await betsResponse.json();
        
        const market = marketData.market;
        const orderBook = betsData.bets || [];
        
        // CRITICAL: Force parse metadata - this is where odds are stored
        if (typeof market.metadata === 'string') {
          console.log('⚠️ Metadata came as string, parsing...');
          try {
            market.metadata = JSON.parse(market.metadata);
          } catch (e) {
            console.error('Failed to parse metadata:', e);
            market.metadata = {};
          }
        }
        
        if (!market.metadata || typeof market.metadata !== 'object') {
          console.log('⚠️ Metadata missing, creating empty object');
          market.metadata = {};
        }
        
        // Initialize TRUE prediction market (no admin manipulation!)
        if (window.predictionMarket) {
          window.predictionMarket.initializeMarket(market.id, market.options);
          console.log('🎯 Initialized pure prediction market:', market.id);
        }
        
        // Debug output
        console.log('========================================');
        console.log('✓ MARKET LOADED');
        console.log('Market ID:', market.id);
        console.log('Market title:', market.title);
        console.log('Market type: TRUE PREDICTION MARKET');
        console.log('Pricing: Market-driven (no admin control)');
        console.log('Initial state: Equal probabilities');
        console.log('Options:', market.options.length);
        market.options.forEach((option, i) => {
          console.log(`  Option ${i}: ${option.name}`);
        });
        console.log('========================================');
        
        // Set global variables
        currentMarket = market;
        currentOrderBook = orderBook;
        selectedOutcome = 0;
        window.currentMarket = currentMarket;
        window.currentOrderBook = currentOrderBook;
        window.selectedOutcome = selectedOutcome;
        
        // Render everything
        await renderMarketInfo(market);
        renderChart(market, orderBook);
        renderOrderBookPro(orderBook, market, 0);
        updateTradePanel();
        
        // Setup buttons
        document.getElementById('buyBtn').onclick = handleBuy;
        document.getElementById('cancelBtn').onclick = handleCancelPurchase;
        document.getElementById('tradeAmount').oninput = calculateProfit;
        
        // Load comments
        await loadCommentsForMarket(marketId);
        setupCommentBox(marketId);
        
      } catch (e) {
        console.error('Load market error:', e);
        document.getElementById('marketSection').innerHTML = `<div style='color:#ef4444;'>Error: ${e.message}</div>`;
      }
    }

    async function loadMyBets() {
      const container = document.getElementById('betsContainer');
      const portfolioSummaryContainer = document.getElementById('portfolioSummary');
      
      if (!walletAddress) {
        container.innerHTML = `<div class="empty-state"><h3>Connect Wallet</h3><p>Connect your wallet to view your betting history.</p></div>`;
        if (portfolioSummaryContainer) portfolioSummaryContainer.innerHTML = '';
        return;
      }
      
      try {
        const res = await fetch(`${API_BASE_URL}/bets?address=${walletAddress.toString()}`);
        const data = await res.json();
        const bets = data.bets || [];
        
        if (bets.length === 0) {
          container.innerHTML = `<div class="empty-state"><h3>No Bets Yet</h3><p>Your betting history will appear here once you place your first bet.</p></div>`;
          if (portfolioSummaryContainer) portfolioSummaryContainer.innerHTML = '';
        } else {
          // Portfolio summary variables
          let totalInvested = 0;
          let totalCurrentValue = 0;
          let totalShares = 0;
          let activeBets = 0;
          
          const betCards = await Promise.all(bets.map(async bet => {
            let optionName = '';
            let optionImage = '';
            let allOptions = [];
            let market = null;
            
            if (bet.optionId !== undefined && bet.market_id) {
              try {
                const res = await fetch(`${API_BASE_URL}/markets/${bet.market_id}`);
                if (res.ok) {
                  market = (await res.json()).market;
                  if (market && market.options) {
                    allOptions = market.options;
                    if (market.options[bet.optionId]) {
                      optionName = market.options[bet.optionId].name || '';
                      optionImage = market.options[bet.optionId].image || '';
                    }
                  }
                }
              } catch (error) {
                console.warn('Failed to load market option data:', error);
              }
            }

            // Calculate shares and PNL
            let sharesHtml = '';
            let pnlHtml = '';
            
            const originalAmount = parseFloat(bet.amount || 0);
            const platformFee = originalAmount * 0.01; // 1% platform fee
            const netInvestment = originalAmount - platformFee;
            const executionPrice = bet.execution_odds || 0.5; // Price per share at purchase
            const sharesOwned = executionPrice > 0 ? netInvestment / executionPrice : 0;
            
            // Update portfolio totals
            totalInvested += netInvestment;
            totalShares += sharesOwned;
            if (market && market.status !== 'resolved') activeBets++;
            
            if (sharesOwned > 0) {
              sharesHtml = `<div style="background:rgba(154,255,0,0.08);padding:8px 12px;border-radius:8px;margin:8px 0;">
                <div style="color:#9ca3af;font-weight:700;font-size:1.05rem;">Portfolio Position</div>
                <div style="color:#e6eef8;margin:4px 0;">
                  <span style="color:#9ca3af;font-weight:600;">${sharesOwned.toFixed(1)}</span> shares @ 
                  <span style="color:#06b6d4;">${executionPrice.toFixed(3)} BNB/share</span>
                </div>
                <div style="color:#9ca3af;font-size:0.9rem;">Net Investment: ${netInvestment.toFixed(3)} BNB (after 1% fee)</div>
              </div>`;
              
              // Get current market probabilities for PNL calculation
              try {
                const probData = await getLMSRProbabilities(bet.market_id);
                if (probData && probData.prices && probData.prices[bet.optionId] !== undefined) {
                  const currentPrice = probData.prices[bet.optionId];
                  const currentProbability = probData.probabilities[bet.optionId];
                  const currentValue = sharesOwned * currentPrice;
                  const unrealizedPnL = currentValue - netInvestment;
                  const pnlPercentage = ((unrealizedPnL / netInvestment) * 100).toFixed(1);
                  
                  // Update total current value
                  totalCurrentValue += currentValue;
                  
                  const pnlColor = unrealizedPnL >= 0 ? '#06b6d4' : '#9ca3af';
                  const pnlSign = unrealizedPnL >= 0 ? '+' : '';
                  
                  pnlHtml = `<div style="background:rgba(${unrealizedPnL >= 0 ? '16,185,129' : '255,107,107'},0.08);padding:8px 12px;border-radius:8px;margin:8px 0;">
                    <div style="color:${pnlColor};font-weight:700;font-size:1.05rem;">
                      ${unrealizedPnL >= 0 ? '📈' : '📉'} P&L: ${pnlSign}${unrealizedPnL.toFixed(3)} BNB (${pnlSign}${pnlPercentage}%)
                    </div>
                    <div style="color:#e6eef8;margin:4px 0;">
                      Current Value: <span style="color:#06b6d4;">${currentValue.toFixed(3)} BNB</span> 
                      (${currentPrice.toFixed(3)} BNB/share)
                    </div>
                    <div style="color:#9ca3af;font-size:0.9rem;">
                      Market Confidence: ${currentProbability}% | 
                      ${market?.status === 'resolved' ? 'Market Resolved' : 'Live Market'}
                    </div>
                  </div>`;
                } else {
                  // Use fallback current value if no price data
                  totalCurrentValue += netInvestment; // Conservative estimate
                  pnlHtml = `<div style="background:rgba(156,163,175,0.08);padding:8px 12px;border-radius:8px;margin:8px 0;">
                    <div style="color:#9ca3af;font-size:0.95rem;">📊 Current market data loading...</div>
                  </div>`;
                }
              } catch (error) {
                console.warn('Failed to calculate PNL for bet:', error);
                totalCurrentValue += netInvestment; // Conservative estimate
                pnlHtml = `<div style="background:rgba(156,163,175,0.08);padding:8px 12px;border-radius:8px;margin:8px 0;">
                  <div style="color:#9ca3af;font-size:0.95rem;">⚠️ Unable to calculate current P&L</div>
                </div>`;
              }
            }
            
            let optionsHtml = '';
            if (allOptions.length > 0) {
              optionsHtml = `<div style="display:flex;gap:12px;margin-top:8px;">` +
                allOptions.map((opt, idx) => {
                  const picked = idx === bet.optionId;
                  return `<div style="display:flex;flex-direction:column;align-items:center;justify-content:center;padding:6px 10px;border-radius:10px;min-width:70px;background:${picked ? '#9ca3af' : '#374151'};color:${picked ? '#111827' : '#e5e7eb'};border:2px solid ${picked ? '#9ca3af' : '#374151'};font-weight:${picked ? '800' : '600'};box-shadow:${picked ? '0 2px 8px rgba(156,163,175,0.13)' : 'none'};transition:all 0.2s;">
                    ${opt.image ? `<img src='${opt.image}' alt='' style='width:22px;height:22px;border-radius:50%;background:#1f2937;margin-bottom:4px;'>` : ''}
                    <span style="font-size:1.01rem;">${opt.name || 'Option ' + (idx+1)}</span>
                    ${picked ? '<span style=\'margin-top:3px;font-size:0.92em;font-weight:700;color:#6b7280;\'>&#10003; Picked</span>' : ''}
                  </div>`;
                }).join('') + `</div>`;
            } else if (optionName) {
              optionsHtml = `<span style='display:flex;align-items:center;gap:6px;background:#374151;padding:4px 10px;border-radius:8px;border:1.5px solid #9ca3af;font-weight:700;color:#9ca3af;'>${optionImage ? `<img src='${optionImage}' alt='' style='width:22px;height:22px;border-radius:50%;background:#1f2937;'>` : ''}<span>${optionName}</span></span>`;
            }
            
            return `<div class="admin-card" style="background:linear-gradient(135deg, #1f2937, #374151);border:1px solid #4b5563;margin-bottom:18px;padding:18px 16px;border-radius:12px;box-shadow:0 4px 14px rgba(75,85,99,0.2);">
              <div class="market-title" style="font-weight:700;font-size:1.1rem;color:#9ca3af;">${bet.market_title || 'Unknown Market'}</div>
              <div style="display:flex;align-items:center;gap:10px;margin:8px 0;"><span style="color: #9ca3af; font-weight: 700;">Original Purchase: ${originalAmount.toFixed(3)} BNB</span></div>
              ${optionsHtml}
              ${sharesHtml}
              ${pnlHtml}
              <div style="color: #9ca3af; font-size: 12px;margin-top:6px;">${new Date(bet.created_at).toLocaleDateString()}${bet.transaction_signature ? ` | <a href="https://bscscan.com/tx/${bet.transaction_signature}" target="_blank" style="color: #9ca3af;">View TX</a>` : ''}</div>
            </div>`;
          }));
          
          // Display portfolio summary
          const totalPnL = totalCurrentValue - totalInvested;
          const pnlPercentage = totalInvested > 0 ? ((totalPnL / totalInvested) * 100).toFixed(1) : '0.0';
          const pnlColor = totalPnL >= 0 ? '#06b6d4' : '#9ca3af';
          const pnlSign = totalPnL >= 0 ? '+' : '';
          
          if (portfolioSummaryContainer) {
            portfolioSummaryContainer.innerHTML = `
              <div style="background:#374151;padding:16px 20px;border-radius:12px;border:1.5px solid rgba(156,163,175,0.3);min-width:180px;">
                <div style="color:#9ca3af;font-weight:700;font-size:0.9rem;margin-bottom:6px;">${window.i18n.t('totalInvested')}</div>
                <div style="color:#e5e7eb;font-size:1.4rem;font-weight:800;">${window.i18n.formatCurrency(totalInvested)}</div>
              </div>
              <div style="background:#374151;padding:16px 20px;border-radius:12px;border:1.5px solid rgba(6,182,212,0.3);min-width:180px;">
                <div style="color:#06b6d4;font-weight:700;font-size:0.9rem;margin-bottom:6px;">${window.i18n.t('currentValue')}</div>
                <div style="color:#e5e7eb;font-size:1.4rem;font-weight:800;">${window.i18n.formatCurrency(totalCurrentValue)}</div>
              </div>
              <div style="background:#374151;padding:16px 20px;border-radius:12px;border:1.5px solid ${totalPnL >= 0 ? 'rgba(6,182,212,0.3)' : 'rgba(156,163,175,0.3)'};min-width:180px;">
                <div style="color:${pnlColor};font-weight:700;font-size:0.9rem;margin-bottom:6px;">${window.i18n.t('totalPnL')}</div>
                <div style="color:${pnlColor};font-size:1.4rem;font-weight:800;">${pnlSign}${window.i18n.formatCurrency(totalPnL)}</div>
                <div style="color:${pnlColor};font-size:0.9rem;font-weight:600;">(${pnlSign}${pnlPercentage}%)</div>
              </div>
              <div style="background:#374151;padding:16px 20px;border-radius:12px;border:1.5px solid rgba(156,163,175,0.3);min-width:160px;">
                <div style="color:#9ca3af;font-weight:700;font-size:0.9rem;margin-bottom:6px;">${window.i18n.t('portfolioStats')}</div>
                <div style="color:#e6eef8;font-size:1.1rem;font-weight:600;">${totalShares.toFixed(0)} ${window.i18n.t('shares')}</div>
                <div style="color:#e6eef8;font-size:1.1rem;font-weight:600;">${activeBets} ${window.i18n.t('activeBets')}</div>
              </div>
            `;
          }
          
          container.innerHTML = betCards.join('');
        }
      } catch (error) {
        container.innerHTML = `<div class="empty-state"><h3>Error Loading Bets</h3><p>${error.message}</p></div>`;
        if (portfolioSummaryContainer) portfolioSummaryContainer.innerHTML = '';
      }
    }

    async function loadCommentsForMarket(marketId) {
      let bets = [];
      try {
        const res = await fetch(`${API_BASE_URL}/bets?market_id=${marketId}`);
        if (res.ok) {
          const data = await res.json();
          bets = data.bets || [];
        }
      } catch (error) {
        console.warn('Failed to load user bets:', error);
      }
      
      let allComments = [];
      for (const bet of bets) {
        try {
          const res = await fetch(`${API_BASE_URL}/bets/${bet.id}/comments`);
          if (res.ok) {
            const data = await res.json();
            if (Array.isArray(data.comments)) {
              data.comments.forEach(c => c.bet = bet);
              allComments = allComments.concat(data.comments);
            }
          }
        } catch (error) {
        console.warn('Failed to load user bets:', error);
      }
      }
      
      allComments.sort((a,b) => new Date(a.created_at) - new Date(b.created_at));
      renderCommentsList(allComments);
    }

    function renderCommentsList(comments) {
      const listDiv = document.getElementById('commentsList');
      if (!comments || comments.length === 0) {
        listDiv.innerHTML = `<div style='color:#bcd3e6;'>No comments yet. Be the first to comment!</div>`;
        return;
      }
      listDiv.innerHTML = comments.map(c => {
        const shortAddr = c.user_address.slice(0,4) + '...' + c.user_address.slice(-4);
        const pfp = `<span style="display:inline-block;width:32px;height:32px;border-radius:50%;background:#374151;margin-right:10px;text-align:center;line-height:32px;font-weight:700;font-size:1.1rem;color:#9ca3af;">${c.user_address[0]}</span>`;
        const cleanText = removeLinks(escapeHtml(c.comment_text));
        return `<div style="display:flex;align-items:flex-start;gap:10px;margin-bottom:14px;">
          ${pfp}
          <div style="flex:1;">
            <a href="https://solscan.io/address/${c.user_address}" target="_blank" rel="noopener" style="font-weight:700;color:#06b6d4;font-size:1.01rem;text-decoration:none;cursor:pointer;">${shortAddr}</a>
            <div style="color:#e6eef8;font-size:1.07rem;margin:2px 0 2px 0;white-space:pre-line;">${cleanText}</div>
            <div style="color:#bcd3e6;font-size:0.97rem;">${new Date(c.created_at).toLocaleString()}</div>
          </div>
        </div>`;
      }).join('');
    }

    function escapeHtml(text) {
      return text.replace(/[&<>"']/g, function(m) {
        return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'})[m];
      });
    }

    function removeLinks(text) {
      let cleaned = text.replace(/https?:\/\/\S+/gi, '').replace(/www\.[^\s]+/gi, '');
      cleaned = cleaned.replace(/\b[a-zA-Z0-9.-]+\.(com|net|org|io|xyz|app|link|to|me|co|site|info|gov|edu)\b/gi, '');
      return cleaned;
    }

    function setupCommentBox(marketId) {
      const commentBox = document.getElementById('commentBoxContainer');
      const loginMsg = document.getElementById('commentLoginMsg');
      const postBtn = document.getElementById('postCommentBtn');
      const commentInput = document.getElementById('commentInput');
      const commentMsg = document.getElementById('commentMsg');
      
      commentBox.style.display = 'none';
      loginMsg.textContent = '';
      
      if (!walletAddress || !walletAddress.toString) {
        loginMsg.textContent = 'Connect your wallet and place a bet to comment.';
        return;
      }
      
      fetch(`${API_BASE_URL}/bets?address=${walletAddress.toString()}&market_id=${marketId}`)
        .then(res => res.json())
        .then(data => {
          if (data.bets && data.bets.length > 0) {
            commentBox.style.display = '';
            loginMsg.textContent = '';
            postBtn.onclick = async () => {
              let text = commentInput.value.trim();
              if (!text) {
                commentMsg.textContent = 'Comment cannot be empty.';
                return;
              }
              text = removeLinks(text);
              const betId = data.bets[0].id;
              postBtn.disabled = true;
              commentMsg.textContent = 'Posting...';
              try {
                const res = await fetch(`${API_BASE_URL}/bets/${betId}/comments`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ user_address: walletAddress.toString(), comment_text: text })
                });
                const resp = await res.json();
                if (res.ok && resp.comment) {
                  commentInput.value = '';
                  commentMsg.textContent = 'Comment posted!';
                  await loadCommentsForMarket(marketId);
                } else {
                  commentMsg.textContent = resp.error || 'Failed to post comment.';
                }
              } catch (e) {
                commentMsg.textContent = 'Failed to post comment.';
              }
              postBtn.disabled = false;
            };
          } else {
            loginMsg.textContent = 'You must place a bet on this market to comment.';
          }
        });
    }

    async function calculateProfit() {
      const amt = parseFloat(document.getElementById('tradeAmount').value);
      
      const feeBreakdownEl = document.getElementById('feeBreakdown');
      const platformFeeEl = document.getElementById('platformFeeAmount');
      const netBetEl = document.getElementById('netBetAmount');
      
      if (!amt || amt <= 0) {
        document.getElementById('profitCalc').textContent = `${window.i18n.t('expectedReturn')}: 0.000 BNB`;
        if (feeBreakdownEl) feeBreakdownEl.style.display = 'none';
        return;
      }
      
      // Calculate 1% platform fee on purchase
      const platformFee = amt * 0.01;
      const netPurchaseAmount = amt - platformFee;
      
      // Show fee breakdown
      if (platformFeeEl) platformFeeEl.textContent = `${platformFee.toFixed(6)} BNB`;
      if (netBetEl) netBetEl.textContent = `${netPurchaseAmount.toFixed(3)} BNB`;
      if (feeBreakdownEl) feeBreakdownEl.style.display = 'block';
      
      // Get LMSR data for proper calculation
      const probData = await getLMSRProbabilities(currentMarket.id);
      let probability = 50; // Fallback probability
      let sharesReceived = 0;
      let priceImpact = 0;
      let newProbability = probability;
      
      // Use proper LMSR mathematics if we have share data
      if (probData && probData.shares && window.lmsrEngine && selectedOutcome !== null && selectedOutcome !== undefined) {
        try {
          // Current market state
          const currentShares = probData.shares;
          const currentPrices = window.lmsrEngine.prices(currentShares);
          probability = Math.round(currentPrices[selectedOutcome] * 100);
          
          // Calculate exact shares using LMSR engine
          sharesReceived = window.lmsrEngine.sharesToBuy(currentShares, selectedOutcome, netPurchaseAmount);
          
          // Calculate price impact (new probability after purchase)
          const newShares = [...currentShares];
          newShares[selectedOutcome] += sharesReceived;
          const newPrices = window.lmsrEngine.prices(newShares);
          newProbability = Math.round(newPrices[selectedOutcome] * 100);
          priceImpact = newProbability - probability;
          
          console.log(`📊 ${window.i18n.t('lmsrCalculation')}:
            ${window.i18n.t('currentShares')}: [${currentShares.join(', ')}]
            ${window.i18n.t('currentProbability')}: ${probability}%
            ${window.i18n.t('sharesToBuy')}: ${sharesReceived.toFixed(3)}
            ${window.i18n.t('newProbability')}: ${newProbability}%
            ${window.i18n.t('priceImpact')}: +${priceImpact}%`);
          
        } catch (error) {
          console.warn('LMSR calculation failed, using fallback:', error);
          // Fallback to simple calculation
          const fallbackPrice = probData.prices?.[selectedOutcome] || 0.5;
          sharesReceived = netPurchaseAmount / fallbackPrice;
          probability = probData.probabilities?.[selectedOutcome] || 50;
        }
      } else {
        // Fallback calculation for backward compatibility
        const fallbackPrice = probData?.prices?.[selectedOutcome] || 0.5;
        sharesReceived = netPurchaseAmount / fallbackPrice;
        probability = probData?.probabilities?.[selectedOutcome] || 50;
        console.log(`📊 ${window.i18n.t('fallbackCalculation')}`);
      }
      
      // Calculate returns
      const maxReturn = sharesReceived * 1.0; // Max 1 BNB per share if wins
      const expectedReturn = sharesReceived * (newProbability / 100); // Expected value based on new market sentiment
      const avgCostPerShare = netPurchaseAmount / sharesReceived;
      
      // Price impact warning
      let priceImpactWarning = '';
      if (priceImpact > 5) {
        priceImpactWarning = `<div style="color:#ff6b6b;font-size:0.9rem;margin-top:4px;background:rgba(255,107,107,0.1);padding:4px 8px;border-radius:4px;">⚠️ ${window.i18n.t('largeTradeWarning')}: +${priceImpact}% ${window.i18n.t('priceImpact')}</div>`;
      } else if (priceImpact > 0) {
        priceImpactWarning = `<div style="color:#f59e0b;font-size:0.9rem;margin-top:4px;">📈 ${window.i18n.t('priceImpact')}: +${priceImpact}%</div>`;
      }
      
      document.getElementById('profitCalc').innerHTML = `
        <div style="color:#d1d5db;font-weight:500;">${window.i18n.t('shares')}: <span style="color:#10b981;font-weight:600;">${sharesReceived.toFixed(3)}</span> @ ${window.i18n.formatCurrency(avgCostPerShare)}/share</div>
        <div style="color:#d1d5db;font-weight:500;">${window.i18n.t('currentConfidence')}: <span style="color:#f59e0b;font-weight:600;">${probability}%</span> → <span style="color:#10b981;font-weight:600;">${newProbability}%</span></div>
        <div style="color:#d1d5db;font-weight:500;">${window.i18n.t('maxReturn')}: <span style="color:#10b981;font-weight:600;">${window.i18n.formatCurrency(maxReturn)}</span> ${window.i18n.t('ifWins')} <span style="color:#9ca3af;">(1% ${window.i18n.t('payoutFeeApplies')})</span></div>
        <div style="color:#d1d5db;font-weight:500;">${window.i18n.t('expectedReturn')}: <span style="color:#06b6d4;font-weight:600;">${window.i18n.formatCurrency(expectedReturn)}</span> <span style="color:#9ca3af;">(${newProbability}% ${window.i18n.t('finalConfidence')})</span></div>
        ${priceImpactWarning}
      `;
    }

    // Event listeners
    window.addEventListener('DOMContentLoaded', () => {
      const btn = document.getElementById('walletBtn');
      btn.onclick = () => {
        if (walletAddress) {
          if (confirm(window.i18n.t('disconnectConfirm'))) disconnectWallet();
        } else {
          connectWallet();
        }
      };

      // Language switcher functionality
      const langBtn = document.getElementById('langBtn');
      const langDropdown = document.getElementById('langDropdown');
      
      // Update language button display
      function updateLangBtn() {
        if (!window.i18n || !window.i18n.currentLanguage) {
          console.warn('I18n not initialized yet');
          return;
        }
        const currentLang = window.i18n.currentLanguage;
        const flag = currentLang === 'zh-CN' ? '🇨🇳' : '🇺🇸';
        const code = currentLang === 'zh-CN' ? 'CN' : 'EN';
        langBtn.textContent = `${flag} ${code}`;
      }
      
      // Toggle language dropdown
      langBtn.onclick = (e) => {
        e.stopPropagation();
        langDropdown.style.display = langDropdown.style.display === 'none' ? 'block' : 'none';
      };
      
      // Hide dropdown when clicking outside
      document.addEventListener('click', () => {
        langDropdown.style.display = 'none';
      });
      
      // Language option handlers
      document.querySelectorAll('.lang-option').forEach(option => {
        option.onclick = () => {
          const lang = option.dataset.lang;
          window.i18n.switchLanguage(lang);
          updateLangBtn();
          langDropdown.style.display = 'none';
          
          // Update URL parameter
          const url = new URL(window.location);
          url.searchParams.set('lang', lang);
          window.history.replaceState({}, '', url);
        };
      });
      
      // Initialize language display
      if (window.i18n && window.i18n.currentLanguage) {
        updateLangBtn();
        window.i18n.updateAllTexts();
      } else {
        console.warn('I18n not ready during initialization');
      }

      // Navigation logic for My Bets
      const myBetsNavLink = document.getElementById('myBetsNavLink');
      if (myBetsNavLink) {
        myBetsNavLink.onclick = (e) => {
          e.preventDefault();
          showMyBetsSection();
        };
      }

      // Quick bet amount buttons
      document.querySelectorAll('.quick-btn').forEach(btn => {
        btn.addEventListener('click', function() {
          const amount = this.dataset.amount;
          if (amount) {
            document.getElementById('tradeAmount').value = amount;
            calculateProfit();
          }
        });
      });

      // Max button
      const maxBtn = document.querySelector('.quick-btn-max');
      if (maxBtn) {
        maxBtn.addEventListener('click', function() {
          if (window.bnbBalance) {
            document.getElementById('tradeAmount').value = window.bnbBalance.toFixed(2);
            calculateProfit();
          }
        });
      }

      // Initialize Web3 and MetaMask
      initializeWeb3();

      document.getElementById('tradeAmount').oninput = calculateProfit;
      loadMarketPage();
    });

    // Function to show My Bets section
    function showMyBetsSection() {
      // Hide market section
      const marketSection = document.getElementById('marketSection');
      if (marketSection) marketSection.style.display = 'none';
      
      // Show My Bets section
      const mybetsSection = document.getElementById('mybetsSection');
      if (mybetsSection) {
        mybetsSection.style.display = 'block';
        loadMyBets(); // Load the user's bets with shares and PNL
      }
      
      // Update navigation highlight
      document.querySelectorAll('.nav-link').forEach(link => link.classList.remove('active'));
      const myBetsNavLink = document.getElementById('myBetsNavLink');
      if (myBetsNavLink) myBetsNavLink.classList.add('active');
    }

    // Function to show market section (for returning from My Bets)
    function showMarketSection() {
      // Show market section
      const marketSection = document.getElementById('marketSection');
      if (marketSection) marketSection.style.display = 'block';
      
      // Hide My Bets section
      const mybetsSection = document.getElementById('mybetsSection');
      if (mybetsSection) mybetsSection.style.display = 'none';
      
      // Update navigation highlight
      document.querySelectorAll('.nav-link').forEach(link => link.classList.remove('active'));
    }

    // Make functions available globally
    window.calculateProfit = calculateProfit;
    window.switchChart = switchChart;
  </script>

  <footer style="text-align:center; margin: 32px 0 16px 0;">
    <a href="https://x.com/BNBmarketCC" target="_blank" rel="noopener" class="primary" style="text-decoration:none;font-weight:600;font-size:16px;">
      Follow us on Twitter/X &rarr; @BNBmarketCC
    </a>
  </footer>
</body>
</html>
